<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JS高程（六） | Htxf-fxtH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第6章 面向对象的程序设计JS与传统的面向对象（Object-Oriented）的语言不同，它没有类的概念。
可以把JS的对象看作是散列表：无非就是一组名值对，其中值可以是数据或函数。
每个对象都是基于一个引用类型创建的，这个引用类型可以是原生引用类型（Object、Array、Date、RegExp、Function、基本包装类型（Boolean、Number、String）、Math），也可以">
<meta property="og:type" content="article">
<meta property="og:title" content="JS高程（六）">
<meta property="og:url" content="http://yoursite.com/2017/03/05/JS高程（六）/index.html">
<meta property="og:site_name" content="Htxf-fxtH">
<meta property="og:description" content="第6章 面向对象的程序设计JS与传统的面向对象（Object-Oriented）的语言不同，它没有类的概念。
可以把JS的对象看作是散列表：无非就是一组名值对，其中值可以是数据或函数。
每个对象都是基于一个引用类型创建的，这个引用类型可以是原生引用类型（Object、Array、Date、RegExp、Function、基本包装类型（Boolean、Number、String）、Math），也可以">
<meta property="og:updated_time" content="2017-03-08T09:30:58.459Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS高程（六）">
<meta name="twitter:description" content="第6章 面向对象的程序设计JS与传统的面向对象（Object-Oriented）的语言不同，它没有类的概念。
可以把JS的对象看作是散列表：无非就是一组名值对，其中值可以是数据或函数。
每个对象都是基于一个引用类型创建的，这个引用类型可以是原生引用类型（Object、Array、Date、RegExp、Function、基本包装类型（Boolean、Number、String）、Math），也可以">
  
    <link rel="alternative" href="/atom.xml" title="Htxf-fxtH" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans|">
  <link href='https://fonts.googleapis.com/css?family=Dancing+Script' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Shadows+Into+Light' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/style.css">
  

  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/home.css">
  <link rel="stylesheet" href="/css/animate.css">
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script type="text/javascript" src="http://code.jQuery.com/jquery-latest.js"></script>
  <script src="/js/base.js"></script>
  <script src="/js/jquery.cookie.js"></script>
  <script src="/fancybox/jquery.fancybox.js"></script>
  <script type="text/x-mathjax-config"> 
MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} 
}); 
</script>
<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</head>



<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
    <div id="insert" class="home_logo"></div>
    <div class="hamburger animated shake">
      <i ></i>
      <ul>
        <li class="home"><a href="/">Home<span></span></a></li>
        <li><a href="http://cpbxx.lofter.com/" target="blank">Works<span></span></a></li>
        <li class="home_notes_showon" ><a href="/">Notes<span></span></a></li>
        <li><a href="./tucaos.html">Tucaos<span></span></a></li>
      </ul>
    </div>
</header>

      <div class="outer">
        <section id="main"><div class="main_center"><article id="post-JS高程（六）" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JS高程（六）
    </h1>
  


        <div class="article-meta">
          <span class="article-date">
  <time datetime="2017-03-05T09:15:14.000Z" itemprop="datePublished">Mar 5 2017</time>
</span>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第6章-面向对象的程序设计"><a href="#第6章-面向对象的程序设计" class="headerlink" title="第6章 面向对象的程序设计"></a>第6章 面向对象的程序设计</h2><p>JS与传统的面向对象（Object-Oriented）的语言不同，它没有类的概念。</p>
<p>可以把JS的对象看作是散列表：无非就是一组名值对，其中值可以是<strong>数据</strong>或<strong>函数</strong>。</p>
<p><strong>每个对象</strong>都是基于一个<strong>引用类型</strong>创建的，这个引用类型可以是原生引用类型（Object、Array、Date、RegExp、Function、基本包装类型（Boolean、Number、String）、Math），也可以是用户自定义的类型。</p>
<a id="more"></a>
<p>两种简单的<strong>创建自定义对象</strong>的方法：</p>
<ul>
<li><p><strong>Object构造函数法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> king = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">king.name = <span class="string">"DaShuaiBi"</span>;</div><div class="line">king.job = <span class="string">"playAndPlay"</span>;</div><div class="line">king.age = <span class="number">27</span>;</div><div class="line">king.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"I\'m the king."</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>对象字面量法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 逗号隔开不同的属性 注意方法的写法</span></div><div class="line"><span class="keyword">var</span> king = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">"playAndPlay"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">27</span>,</div><div class="line">    <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"I'm the king."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-1-对象的属性"><a href="#6-1-对象的属性" class="headerlink" title="6.1 对象的属性"></a>6.1 对象的属性</h3><p>JS中对象的属性（property）有两种类型：<strong>数据属性</strong>和<strong>访问器属性</strong>，这两种属性都有自己的<strong>特性</strong>（attribute）。可以设置、更改、读取这些特性。</p>
<ul>
<li><p>数据属性<br>4个特性：[[Configurable]]（表示能否通过<strong>delete</strong>删除属性）、[[Enumerable]]（表示能否通过for-in循环返回属性）、[[Writable]]（表示能否<strong>修改属性的值</strong>）、[[Value]]</p>
<p>在对象中定义了某种属性，那么这种属性就是数据属性了？？</p>
</li>
<li><p>访问器属性<br>4个特性：[[Configurable]]、[[Enumerable]]、[[Get]]、[[Set]]</p>
<p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p>
</li>
</ul>
<p>三个方法</p>
<ul>
<li><p><strong>Object.defineProperty()</strong> 定义、修改属性<br>三个参数：属性所在对象、属性名、<span id="des">描述符对象（即属性特性的描述，属性特性名：xx）</span></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"><span class="comment">// 设置了数据属性name</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="comment">// 设置person的name属性不可修改</span></div><div class="line">    writable: <span class="literal">false</span>,</div><div class="line">    <span class="attr">value</span>: <span class="string">"DaShuaiBi"</span></div><div class="line">&#125;);</div><div class="line">alert(person.name); <span class="comment">// DaShuaiBi</span></div><div class="line">person.name = <span class="string">"HeiHeiHei"</span>;</div><div class="line"><span class="comment">// 还是DaShuaiBi</span></div><div class="line">alert(person.name); <span class="comment">// "DaShuaiBi"</span></div></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这两个_year和edition属性 是数据属性 </span></div><div class="line"><span class="comment">// 这种形式，其属性特性中的configurable、enumerable和writable都默认是true</span></div><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">_year</span>: <span class="number">2004</span>,</div><div class="line">    <span class="attr">edition</span>: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 这个year是 访问器属性，设置了getter和setter方法</span></div><div class="line"><span class="comment">// 使用访问器属性常见的方法：设置一个属性（访问器属性）的值会导致其他属性（数据属性）发生变化</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">            <span class="keyword">this</span>._year = newValue;</div><div class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">alert(book._year); <span class="comment">// 2004</span></div><div class="line">alert(book.edition); <span class="comment">// 1</span></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line"><span class="comment">// 发现可以修改</span></div><div class="line">alert(book._year); <span class="comment">// 2005</span></div><div class="line">alert(book.edition); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>，在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false；而在之前使用Object构造函数和对象字面量方法创建的对象，其属性的这几个特性都默认为true。(上边第二段代码中的book的_year和edition就是通过对象字面量定义的属性)</p>
</li>
<li><p><strong>Object.defineProperties()</strong> 定义多个属性<br>两个参数：要添加或修改其属性的对象、一个对象（与第一个参数对象要添加或修改的属性一一对应，即{属性名1: {属性特姓名1: xx}, 属性名2: {属性特性名: xx}, 属性名3: { {属性特性名1: xx}, {属性特姓名2: xx}}）</p>
<p>注意，这是上边<strong>注意</strong>的一个例子。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;&#125;;</div><div class="line"><span class="comment">// 用这种方法设置了数据属性_year和edition，还有访问器属性year</span></div><div class="line"><span class="comment">// 但是与上边的方法不同。这里属性特性configurable、enumerable和writable都默认是false</span></div><div class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</div><div class="line">    <span class="attr">_year</span>: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="number">2004</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">edition</span>: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="number">1</span>;</div><div class="line">    &#125;,  </div><div class="line"></div><div class="line">    <span class="attr">year</span>: &#123;</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">                <span class="keyword">this</span>._year = newValue;</div><div class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">alert(book._year); <span class="comment">// 2004</span></div><div class="line">alert(book.edition); <span class="comment">// 1</span></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line"><span class="comment">// 发现并不能更改_year和edition的值</span></div><div class="line">alert(book._year); <span class="comment">// 2004</span></div><div class="line">alert(book.edition); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>Object.getOwnPropertyDescriptor()</strong> 读取属性的特性<br>两个参数：属性所在对象、要读取其描述符的特性名称；返回一个对象，包含相应的属性特性。</p>
</li>
</ul>
<h3 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h3><p>《JS高级程序设计》中可以说一共提供了9种<strong>创建对象</strong>的方法。为什么会有这么多的方法？要让JS更“面向对象”，就要满足一些要求。开始的方法不能很好的满足一定的要求，就会有新的方法出现。</p>
<p>总结这些要求大概有：</p>
<ul>
<li>1.代码复用</li>
<li>2.封装性、继承性？？、多态性？？</li>
<li>3.对象识别，即可以方便的知道实例是什么自定义类型 xxx instanceof XXX</li>
<li>4.实例间要有<strong>不同</strong>的<strong>基本值的属性</strong></li>
<li>5.实例间要有<strong>不同</strong>的<strong>引用类型值的属性</strong>，除Function之外 </li>
<li>6.实例间要有<strong>相同（共享）</strong>的函数（方法），空间复用？</li>
</ul>
<h4 id="Object构造函数法、对象字面量法"><a href="#Object构造函数法、对象字面量法" class="headerlink" title="Object构造函数法、对象字面量法"></a>Object构造函数法、对象字面量法</h4><p>本篇最开始就介绍了这两种方法。<br>缺点：不满足第1点要求，创建对个实例时会产生大量重复代码。</p>
<h4 id="rarr-rarr-工厂模式-larr-larr"><a href="#rarr-rarr-工厂模式-larr-larr" class="headerlink" title="&rarr;&rarr; 工厂模式 &larr;&larr;"></a>&rarr;&rarr; 工厂模式 &larr;&larr;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(o.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 没有用 new ，只是调用函数</span></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>优点：解决了Object构造函数法和对象字面量方法的不足之处，代码可以复用。</p>
<p>缺点：不满足第3点要求（对象识别），不能知道person1和person2是什么样的自定义类型；不满足第6点，实例间的函数是不同的，（函数也是对象），占用空间。</p>
<h4 id="rarr-rarr-构造函数模式-larr-larr"><a href="#rarr-rarr-构造函数模式-larr-larr" class="headerlink" title="&rarr;&rarr; 构造函数模式 &larr;&larr;"></a>&rarr;&rarr; 构造函数模式 &larr;&larr;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用了new关键字</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>注意：Person的首字母是大写（惯例）</p>
<p>优点：解决了工厂模式的不足之一，可以进行对象识别。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></div><div class="line">alert(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><span id="construct_fault">缺点：不满足第6点，实例间的函数是不同的，（函数也是对象），占用空间。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person1.sayName == person2.sayName; <span class="comment">// false</span></div><div class="line"><span class="comment">// 不能写成</span></div><div class="line">person1.sayName() == person2.sayName(); <span class="comment">// 先运行函数，再返回true（都是function？？ 不对，因为person1的sayName()方法没有返回值，默认是undefined）</span></div></pre></td></tr></table></figure></p>
<h4 id="构造函数模式的改进"><a href="#构造函数模式的改进" class="headerlink" title="构造函数模式的改进"></a>构造函数模式的改进</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 把函数定义转移到构造函数外部</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>优点：解决了构造函数模式的缺点，实例间的函数是相同的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person1.sayName == person2.sayName; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>缺点：应是实例的方法sayName现在成了全局函数，而且要是自定义类型的方法很多时，就得定义很多个全局函数。不满足第2点中的封装性。</p>
<h4 id="rarr-rarr-原型模式-larr-larr"><a href="#rarr-rarr-原型模式-larr-larr" class="headerlink" title="&rarr;&rarr; 原型模式 &larr;&larr;"></a>&rarr;&rarr; 原型模式 &larr;&larr;</h4><p>每个<strong>函数</strong>都有一个<strong>prototype属性</strong>，这个属性是个指针，指向一个对象，这个对象包含可以由特定类型的<strong>所有实例共享</strong>的属性和方法。</p>
<p>prototype是通过调用<strong>构造函数</strong>而创建的那个<strong>对象实例</strong>的<strong>原型对象</strong>。（prototype是对象）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"DaShuaiBi"</span>;</div><div class="line">Person.prototype.age = <span class="number">27</span>;</div><div class="line">Person.prototype.job = <span class="string">"playAndPlay"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person2.name = <span class="string">"HeiHeiHei"</span>;</div><div class="line">person2.age = <span class="number">18</span>;</div><div class="line">person2.job = <span class="string">"heixiuheixiu"</span>;</div></pre></td></tr></table></figure>
<p>优点：解决了构造函数模式的不足，实例的函数是同一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person1.sayName == person2.sayName; // true</div></pre></td></tr></table></figure></p>
<p>缺点：Person.prototype.代码重复太多；不满足第4、5点要求。由于原型对象上所有属性都是实例对象所共享的，结果默认情况下实例的基本值的属性和引用类型值的属性都一样。虽然可以通过在实例上添加同名属性来<strong>屏蔽</strong>原型对象上的同名属性，但当只是<strong>简单的修改实例上的引用类型值的属性</strong>时，就比较难受了。</p>
<h4 id="更简单的原型模式"><a href="#更简单的原型模式" class="headerlink" title="更简单的原型模式"></a>更简单的原型模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 用一个包含所有属性和方法的 对象字面量 来重写整个原型对象</span></div><div class="line"><span class="comment">// 注意这儿的constructor 之后再介绍</span></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">27</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">"playAndPlay"</span>,</div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>优点：解决了Person.prototype代码复用问题</p>
<p><span id="proto_fault">缺点：原型模式的真正缺点还没有解决。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">27</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">"playAndPlay"</span>,</div><div class="line">    <span class="comment">// 引用类型值的属性 </span></div><div class="line">    friends: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>],</div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">// 假如没有更改person2的属性值</span></div><div class="line"><span class="comment">//person2.name = "HeiHeiHei";</span></div><div class="line"><span class="comment">//person2.age = 18;</span></div><div class="line"><span class="comment">//person2.job = "heixiuheixiu";</span></div><div class="line"><span class="comment">//person2.friends = ["haha","jiji"];</span></div><div class="line"></div><div class="line"><span class="comment">// 简单的修改person1的引用类型值的属性friends</span></div><div class="line">person1.friends.push(<span class="string">"SiShuai"</span>);</div><div class="line">alert(person1.friends); <span class="comment">// ErShuai,SanShuai,SiShuai</span></div><div class="line">alert(person2.friends); <span class="comment">// ErShuai,SanShuai,SiShuai !!! 注意此时并不想更改person2的friends，ErShuai,SanShuai是person1和person2共同的朋友，而SiShuai并不是。</span></div><div class="line">alert(person1.friends == person2.friends); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h4 id="hearts-hearts-hearts-rarr-rarr-组合使用构造函数模式和原型模式-larr-larr-hearts-hearts-hearts"><a href="#hearts-hearts-hearts-rarr-rarr-组合使用构造函数模式和原型模式-larr-larr-hearts-hearts-hearts" class="headerlink" title="&hearts;&hearts;&hearts; &rarr;&rarr; 组合使用构造函数模式和原型模式 &larr;&larr; &hearts;&hearts;&hearts;"></a>&hearts;&hearts;&hearts; &rarr;&rarr; 组合使用构造函数模式和原型模式 &larr;&larr; &hearts;&hearts;&hearts;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数用于定义实例的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.friends = [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 原型模式用于定义方法和共享的属性</span></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>优点：结合了构造函数模式和原型模式的优点。每个实例都有自己的一份<strong>实例属性的副本</strong>，但同时又<strong>共享着对方法的引用</strong>，最大限度地节省了内存。<br>解决了原型模式的不足。（使用最广泛、认同度最高）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 因为两个person中的属性name、age、job、friends在堆内存中两个不同的堆上。</span></div><div class="line"><span class="comment">// 两个person中friends更是在另两个堆上。</span></div><div class="line"><span class="comment">// 对象和对象的属性在内存中怎样表示？？？ 即怎样知道person1的name和age都在person1上，person1的friends在person1上同时又是一个新的堆内存上的对象？？？</span></div><div class="line">person1.friends.push(<span class="string">"SiShuai"</span>);</div><div class="line">alert(person1.friends); <span class="comment">// ErShuai,SanShuai,SiShuai</span></div><div class="line">alert(person2.friends); <span class="comment">// ErShuai,SanShuai</span></div><div class="line">alert(person1.friends == person2.friends); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>缺点：实例的不同属性（构造函数）、共享方法（原型对象）合起来才算是创建对象的方法。缺一点点封装性。</p>
<h4 id="hearts-hearts-hearts-rarr-rarr-动态原型模式-larr-larr-hearts-hearts-hearts"><a href="#hearts-hearts-hearts-rarr-rarr-动态原型模式-larr-larr-hearts-hearts-hearts" class="headerlink" title="&hearts;&hearts;&hearts; &rarr;&rarr; 动态原型模式 &larr;&larr; &hearts;&hearts;&hearts;"></a>&hearts;&hearts;&hearts; &rarr;&rarr; 动态原型模式 &larr;&larr; &hearts;&hearts;&hearts;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="comment">// 把在原型对象上添加共享方法的代码写进构造函数中，并有个判断</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</div><div class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            alert(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>优点：if(){}代码块只会在初次调用构造函数时（生成person1时）才会执行。在生成person2时就不用执行了！JS中创建对象<strong>非常完美</strong>的方法。</p>
<h4 id="rarr-rarr-寄生构造函数模式-larr-larr"><a href="#rarr-rarr-寄生构造函数模式-larr-larr" class="headerlink" title="&rarr;&rarr; 寄生构造函数模式 &larr;&larr;"></a>&rarr;&rarr; 寄生构造函数模式 &larr;&larr;</h4><p>不太理解。函数中有return一个对象，创建对象时还使用new关键字？？？</p>
<h4 id="rarr-rarr-稳妥构造函数模式-larr-larr"><a href="#rarr-rarr-稳妥构造函数模式-larr-larr" class="headerlink" title="&rarr;&rarr; 稳妥构造函数模式 &larr;&larr;"></a>&rarr;&rarr; 稳妥构造函数模式 &larr;&larr;</h4><p>不太理解。虽说是xx构造函数模式，但函数中有return一个对象，创建对象时没有使用new关键字，更像是xx工厂模式？？？</p>
<h3 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h3><p>这部分和上边创建对象有很大联系。一些模式之间的代码结构很相似。</p>
<p>创建对象的方法：Object构造函数、对象字面量、工厂模式、构造函数模式、（构造函数模式的改进）、原型模式、（更简单的形式原型模式）、组合模式（构造函数+原型模式）、动态原型模式、寄生构造函数模式、稳妥构造函数模式。</p>
<p>继承方法：原型链继承、借用构造函数继承、组合继承（构造函数+原型链）、原型式继承、寄生式继承（原型式plus）、寄生组合式继承（寄生式+构造函数+原型链）</p>
<h4 id="rarr-rarr-原型链继承-larr-larr"><a href="#rarr-rarr-原型链继承-larr-larr" class="headerlink" title="&rarr;&rarr; 原型链继承 &larr;&larr;"></a>&rarr;&rarr; 原型链继承 &larr;&larr;</h4><p>关键语句 SubType.prototype = new SuperType();</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将SuperType的实例赋给SubType的原型对象 实现继承</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line"><span class="comment">// 能使用“父类”SuperType原型对象上的方法</span></div><div class="line">alert(instance.getSuperValue()); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 注意！！！</span></div><div class="line">SuperType.prototype.constructor; <span class="comment">// function SuperType() &#123;...&#125;</span></div><div class="line"></div><div class="line">SubType.prototype.constructor; <span class="comment">// function SuperType() &#123;...&#125; 也是SupserType！！！ 本来是SubType，但将new SuperType()赋给了SubType.prototype。书中说是就断了，没有了，但实际上是跟着SuperType.prototype的步伐指向了SuperType</span></div><div class="line">instance.constructor; <span class="comment">// function SuperType() &#123;...&#125;</span></div></pre></td></tr></table></figure>
<p><span id="proto_inherit">问题1：与<a href="#proto_fault">使用原型模式创建对象</a>时的问题类似</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 原型链继承</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">// red,blue,green,black</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">// red,blue,green,black 实际上并不想要black</span></div><div class="line"></div><div class="line"><span class="comment">//因为instance1、instance2都是SubType的实例，而它们的colors属性本来是在SuperType的构造函数中，通过SubType.prototype = new SuperType();实际上是在SubType.prototype上。又是引用类型的值的属性。就和使用原型模式创建对象的问题一样了。</span></div></pre></td></tr></table></figure></p>
<p>问题2：在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
<h4 id="rarr-rarr-借用构造函数继承-larr-larr"><a href="#rarr-rarr-借用构造函数继承-larr-larr" class="headerlink" title="&rarr;&rarr; 借用构造函数继承 &larr;&larr;"></a>&rarr;&rarr; 借用构造函数继承 &larr;&larr;</h4><p>关键语句 SuperType.call(this);</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;   </div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">    <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"hi"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.name = <span class="string">"siguoyi"</span>;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 借用构造函数 在SubType的构造函数中 运行SuperType函数，将其作用域定为SubType的实例</span></div><div class="line">    <span class="comment">// 实现继承 “复制”？？？</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.subproperty); <span class="comment">// false</span></div><div class="line">alert(instance.property); <span class="comment">// true</span></div><div class="line">instance.sayHi(); <span class="comment">// 弹出hi</span></div><div class="line">alert(instance.getSubValue()); <span class="comment">//  false</span></div><div class="line"></div><div class="line"><span class="comment">// 注意1！！！ 并不能使用父类型原型对象上定义的属性、方法</span></div><div class="line">instance.getSuperValue(); <span class="comment">// 出错！！！  Uncaught TypeError: instance.getSuperValue is not a function</span></div><div class="line">alert(instance.name); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 注意2！！！</span></div><div class="line">SuperType.prototype.constructor; <span class="comment">// function SuperType() &#123;...&#125;</span></div><div class="line"></div><div class="line">SubType.prototype.constructor; <span class="comment">// function SubType() &#123;...&#125; 和原型链继承不同</span></div><div class="line">instance.constructor; <span class="comment">// function SubType() &#123;...&#125; 和原型链继承不同</span></div></pre></td></tr></table></figure>
<p>优点1：解决了原型链继承的问题1。子类型实例有各自的属性副本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 比原型链继承好的地方</span></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors);</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors);</div></pre></td></tr></table></figure></p>
<p>优点2：解决原型链继承的问题2 可以个超类型的构造函数传递参数。</p>
<p>缺点：与<a href="#construct_fault">使用构造函数模式创建对象</a>的缺点类似。函数不能复用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">instance1.sayHi == instance2.sayHi <span class="comment">// false 父类型上的函数sayHi()并没有复用</span></div><div class="line">instance1.getSubValue == instance2.getSubValue <span class="comment">// true 这个不算 这是在子类型原型对象上定义的函数</span></div></pre></td></tr></table></figure></p>
<h4 id="hearts-hearts-hearts-rarr-rarr-组合继承-larr-larr-hearts-hearts-hearts"><a href="#hearts-hearts-hearts-rarr-rarr-组合继承-larr-larr-hearts-hearts-hearts" class="headerlink" title="&hearts;&hearts;&hearts; &rarr;&rarr; 组合继承 &larr;&larr; &hearts;&hearts;&hearts;"></a>&hearts;&hearts;&hearts; &rarr;&rarr; 组合继承 &larr;&larr; &hearts;&hearts;&hearts;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="comment">// 构造函数继承</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 原型链继承</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.constructor = SubType; <span class="comment">// 推荐写法</span></div><div class="line"></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>);</div><div class="line"></div><div class="line"><span class="comment">// 注意！！！</span></div><div class="line">SuperType.prototype.constructor; <span class="comment">// function SuperType() &#123;...&#125;</span></div><div class="line">SubType.prototype.constructor; <span class="comment">// function SubType() &#123;...&#125; 改回来了</span></div><div class="line">instance1.constructor; <span class="comment">// function SubType() &#123;...&#125; 改回来了</span></div></pre></td></tr></table></figure>
<p>优点：结合了原型链继承和借用构造函数继承的优点，消除了两者的缺点。JS中<strong>最常用的继承模式</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">// red,blue,green,black</span></div><div class="line">instance1.sayName(); <span class="comment">// DaShuaiBi</span></div><div class="line">instance1.sayAge(); <span class="comment">// 27</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instacne2 = <span class="keyword">new</span> SubType(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>);</div><div class="line">alert(instacne2.colors); <span class="comment">// red,blue,green 解决了原型链继承的问题</span></div><div class="line">instacne2.sayName(); <span class="comment">// HeiHeiHei</span></div><div class="line">instacne2.sayAge(); <span class="comment">// 18</span></div><div class="line"></div><div class="line">instance1.sayName == instance2.sayName; <span class="comment">// true 解决了借用构造函数继承的问题</span></div><div class="line">instance1.sayAge == instance2.sayAge; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><sapn id="comInherit">缺点：虽然最常用，也是有缺点。会调用超类型（SubType）构造函数两次。第一次：SubType.prototype = new SuperType(); 第二次：SuperType.call(this, name); （更准确的说应该是在实例化一个SubType时（调用SubType的构造函数时，因为这一行代码就在SubType的构造函数里边）） 。</sapn></p>
<h4 id="rarr-rarr-原型式继承-larr-larr"><a href="#rarr-rarr-原型式继承-larr-larr" class="headerlink" title="&rarr;&rarr; 原型式继承 &larr;&larr;"></a>&rarr;&rarr; 原型式继承 &larr;&larr;</h4><p>有两种方式。</p>
<p>第一种：ECMAScript5增加的方法<strong>Object.create()</strong><br>（其中属性描述符与<a href="#des">前边的</a>一样）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 有两个参数</span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</div><div class="line">    <span class="comment">// 属性描述符 </span></div><div class="line">    name: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="string">"HeiHeiHei"</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name); <span class="comment">// "HeiHeiHei"</span></div><div class="line"></div><div class="line"><span class="comment">// 只有一个参数 </span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson.name = <span class="string">"HeiHeiHei"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 上面两种写法一模一样</span></div></pre></td></tr></table></figure></p>
<p>第二种 先自己定义一个函数object()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o; <span class="comment">// 把o当做是F的原型对象</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = object(person);</div><div class="line">anotherPerson.name = <span class="string">"HeiHeiHei"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 注意！！！</span></div><div class="line"><span class="comment">// 这种方法 就没有 构造函数 ！！！</span></div><div class="line">person.prototype.constructor; <span class="comment">//  错误！！！ 只有 构造函数（函数）才有prototype属性！！！</span></div><div class="line">anotherPerson.prototype.constructor; <span class="comment">// 错误！！！</span></div><div class="line"></div><div class="line">person.constructor; <span class="comment">// function Object() &#123;...&#125; 是Object的构造函数</span></div><div class="line">anotherPerson.constructor; <span class="comment">// function Object() &#123;...&#125;</span></div><div class="line"></div><div class="line">person.__proto__; <span class="comment">// 找person对象的原型对象 Object &#123;...&#125; 这个东西就是 Object.prototype 而不是Object的构造函数</span></div><div class="line"><span class="built_in">Object</span>.isPrototypeOf(person); <span class="comment">// false</span></div><div class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(person); <span class="comment">// true</span></div><div class="line"></div><div class="line">anotherPerson.__proto__; <span class="comment">// 注意 ！！！ 找anotherPerson的原型对象 Object &#123;name: "DaShuaiBi", friends: Array[2]&#125; 这个东西就是 person！！！</span></div><div class="line">anotherPerson.__proto__ == person; <span class="comment">// true</span></div><div class="line">person.isPrototypeOf(anotherPerson); <span class="comment">// true </span></div><div class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(anotherPerson); <span class="comment">// true 链起来了</span></div></pre></td></tr></table></figure></p>
<p>优点： <strong>不必兴师动众地创建构造函数</strong></p>
<p>缺点：当然没有构造函数，不能知道实例是什么“类型”，只是知道实例跟哪个对象很像；与<a href="#proto_fault">使用原型模式创建对象</a>及<a href="#proto_inherit">使用原型链继承</a>时的问题一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">anotherPerson.friends.push(<span class="string">"yoyoyo"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"bang"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"zero"</span>);</div><div class="line"></div><div class="line">alert(person.friedns); <span class="comment">// ErShuai,SanShuai,yoyoyo,zero</span></div><div class="line">alert(person.name); <span class="comment">// DaShuaiBi</span></div></pre></td></tr></table></figure></p>
<p>原型式继承中，object()函数实际上是对传入其中的对象进行了一次<a href="http://www.cnblogs.com/tracylin/p/5346314.html" target="_blank" rel="external">浅复制</a>，浅复制是针对引用类型的值而言的。上边的例子中anotherPerson对person进行了浅复制，所以改变anotherPerson上的值，person上的值也会改变。可是name是基本类型值，所以是真的复制了一个副本出来，而friends是引用类型值，准确的说是浅复制了引用类型（对象）上的引用类型（数组Array）值。</p>
<h4 id="rarr-rarr-寄生式继承-larr-larr"><a href="#rarr-rarr-寄生式继承-larr-larr" class="headerlink" title="&rarr;&rarr; 寄生式继承 &larr;&larr;"></a>&rarr;&rarr; 寄生式继承 &larr;&larr;</h4><p>寄生式继承感觉是在原型式继承的基础上，又套了一层函数用来对新实例增加一些自己的东西。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型式继承中的函数 虽然 也可以是任何可以返回对象的函数，但不太懂。。暂且理解为与原型式中的一样</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 再套一层函数，增加了sayHi方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = object(original);</div><div class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"hi"</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line"></div><div class="line"><span class="comment">// 注意！！！ 和原型式继承一样</span></div><div class="line">person.constructor; <span class="comment">// function Object() &#123; [native code] &#125;</span></div><div class="line">anotherPerson.constructor; <span class="comment">// function Object() &#123; [native code] &#125;</span></div><div class="line"></div><div class="line">person.isPrototypeOf(anotherPerson); <span class="comment">// true</span></div><div class="line">anotherPerson.__proto__; <span class="comment">// Object &#123;name: "DaShuaiBi", friends: Array[2]&#125; 即person</span></div><div class="line">anotherPerson.__proto__ == person; <span class="comment">// ture</span></div><div class="line"></div><div class="line">anotherPerson.sayHi(); <span class="comment">// hi</span></div><div class="line"></div><div class="line"><span class="comment">// 注意！！</span></div><div class="line">person.sayHi(); <span class="comment">// 错误，person上并没有这个方法</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> yetAnotherPerson = createAnother(person);</div><div class="line"></div><div class="line"><span class="comment">// 注意！！！ 函数不能复用</span></div><div class="line">anotherPerson.sayHi == yetAnotherPerson.sayHi; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>优点：貌似和原型式继承差不多？</p>
<p>缺点：貌似和原型式继承差不多？</p>
<p>书中还写说寄生式继承为对象添加函数时不能复用，就像这里所示；原型式继承也有这个问题啊！！！但没有写。是不是因为一般使用原型式继承时只是简单的复制一下某个对象，而使用寄生式继承时除了复制一下某个对象外还稍微加点方法、属性什么的？？？</p>
<h4 id="hearts-hearts-hearts-rarr-rarr-寄生组合式继承-larr-larr-hearts-hearts-hearts"><a href="#hearts-hearts-hearts-rarr-rarr-寄生组合式继承-larr-larr-hearts-hearts-hearts" class="headerlink" title="&hearts;&hearts;&hearts; &rarr;&rarr; 寄生组合式继承 &larr;&larr; &hearts;&hearts;&hearts;"></a>&hearts;&hearts;&hearts; &rarr;&rarr; 寄生组合式继承 &larr;&larr; &hearts;&hearts;&hearts;</h4><p>这个的感觉就和<strong>使用动态原型模式创建对象</strong>的地位一样。</p>
<p><strong>寄生组合式继承是引用类型最理想的继承范式</strong></p>
<p>原型式继承+寄生式继承+借用构造函数继承+原型链继承 = 寄生组合式继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型式继承中的 函数 </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 寄生式继承中的方式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);</div><div class="line">    prototype.constructor = subType; <span class="comment">// 将子类的新的原型对象（通过父类的原型对象创建出来的，但并不是父类的原型对象）上的constructor重新链到子类构造函数上</span></div><div class="line">    subType.prototype = prototype; <span class="comment">// 将子类的原型对象设置为通过父类的原型对象创建出来的一个对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="comment">// 借用构造函数继承 继承了 name、colors</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 与组合继承不同之处 通过这个方法实现 原型链继承</span></div><div class="line"><span class="comment">// 继承了sayName方法</span></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>);</div><div class="line"></div><div class="line">SuperType.prototype.constructor; <span class="comment">// function SuperType(name) &#123;...&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 注意！！！ 之前的原型链继承、组合继承应该都是这样</span></div><div class="line"><span class="comment">// 与原型式继承和寄生式继承不同，就确定是person对象了，这里是new的新对象作为子类的原型对象。</span></div><div class="line">SubType.prototype; <span class="comment">// SuperType &#123;constructor:SubType(name, age)  ayAge:()  __proto__:Object&#125;</span></div><div class="line">SubType.prototype.constructor; <span class="comment">// function SubType(name, age) &#123;...&#125; 改回来了</span></div><div class="line">SubType.prototype == SuperType <span class="comment">// false</span></div><div class="line">SubType.prototype == SuperType.prototype <span class="comment">// false</span></div><div class="line">SuperType.isPrototypeOf(SubType.prototype) <span class="comment">// false</span></div><div class="line">SuperType.prototype.isPrototypeOf(SubType.prototype) <span class="comment">// true</span></div><div class="line"></div><div class="line">instance1.constructor; <span class="comment">// function SubType(name, age) &#123;...&#125; 改回来了</span></div><div class="line">instance1.__proto__; <span class="comment">// SuperType &#123;constructor:SubType(name, age)  ayAge:()  __proto__:Object&#125; 就是 SuperType.prototype ？？并不是</span></div><div class="line">instance1.__proto__ == SuperType.prototype; <span class="comment">// false</span></div><div class="line">SuperType.prototype.isPrototypeOf(instance1); <span class="comment">// true</span></div><div class="line"></div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">// red,blue,green,black</span></div><div class="line">instance1.sayName(); <span class="comment">// DaShuaiBi</span></div><div class="line">instance1.sayAge(); <span class="comment">// 27</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instacne2 = <span class="keyword">new</span> SubType(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>);</div><div class="line">alert(instacne2.colors); <span class="comment">// red,blue,green</span></div><div class="line">instacne2.sayName(); <span class="comment">// HeiHeiHei</span></div><div class="line">instacne2.sayAge(); <span class="comment">// 18</span></div></pre></td></tr></table></figure>
<p>优点：解决了<a href="#comInherit">组合继承的问题</a>，父类型构造函数只调用了一次。</p>
<p>17-03-08</p>

      
    </div>
    <footer class="article-footer">
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基础/">js基础</a></li></ul>


    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/03/04/TensorFLow学习笔记（三）/" id="article-nav-older" class="article-nav-link-wrap">ALI</a>
  
</nav>


  
</article>


</div>
</section>
      </div>
    </div>
  </div>
</body>
</html>
