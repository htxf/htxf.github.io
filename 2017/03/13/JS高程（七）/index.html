<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JS高程（七） | Htxf-fxtH</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第七章 函数表达式函数表达式是干什么的？用来创建函数的。创建函数的方法有：函数声明、函数表达式。
函数声明，有个特征：函数声明提升。函数表达式并没有。
函数表达式的语法形式：有两种？一种，创建一个函数表达式，没有给这个函数表达式起名字。这个函数就叫做匿名函数（拉姆达函数）；另一种，创建一个函数表达式，并给这个函数表达式起了个名字。这个函数就叫做命名函数表达式。">
<meta property="og:type" content="article">
<meta property="og:title" content="JS高程（七）">
<meta property="og:url" content="http://yoursite.com/2017/03/13/JS高程（七）/index.html">
<meta property="og:site_name" content="Htxf-fxtH">
<meta property="og:description" content="第七章 函数表达式函数表达式是干什么的？用来创建函数的。创建函数的方法有：函数声明、函数表达式。
函数声明，有个特征：函数声明提升。函数表达式并没有。
函数表达式的语法形式：有两种？一种，创建一个函数表达式，没有给这个函数表达式起名字。这个函数就叫做匿名函数（拉姆达函数）；另一种，创建一个函数表达式，并给这个函数表达式起了个名字。这个函数就叫做命名函数表达式。">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case1.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case2.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case3.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case4.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case5_case6.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case6_case7.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case8.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case9.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case0.1.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\case0.2.png">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\notexpect.jpg">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\expect.jpg">
<meta property="og:image" content="http://yoursite.com/..\JS高程（七）\bibaothis.jpg">
<meta property="og:updated_time" content="2017-03-16T08:39:47.062Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS高程（七）">
<meta name="twitter:description" content="第七章 函数表达式函数表达式是干什么的？用来创建函数的。创建函数的方法有：函数声明、函数表达式。
函数声明，有个特征：函数声明提升。函数表达式并没有。
函数表达式的语法形式：有两种？一种，创建一个函数表达式，没有给这个函数表达式起名字。这个函数就叫做匿名函数（拉姆达函数）；另一种，创建一个函数表达式，并给这个函数表达式起了个名字。这个函数就叫做命名函数表达式。">
<meta name="twitter:image" content="http://yoursite.com/..\JS高程（七）\case1.png">
  
    <link rel="alternative" href="/atom.xml" title="Htxf-fxtH" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans|">
  <link href='https://fonts.googleapis.com/css?family=Dancing+Script' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Shadows+Into+Light' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/style.css">
  

  <link rel="stylesheet" href="/css/base.css">
  <link rel="stylesheet" href="/css/home.css">
  <link rel="stylesheet" href="/css/animate.css">
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script type="text/javascript" src="http://code.jQuery.com/jquery-latest.js"></script>
  <script src="/js/base.js"></script>
  <script src="/js/jquery.cookie.js"></script>
  <script src="/fancybox/jquery.fancybox.js"></script>
  <script type="text/x-mathjax-config"> 
MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} 
}); 
</script>
<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

</head>



<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
    <div id="insert" class="home_logo"></div>
    <div class="hamburger animated shake">
      <i ></i>
      <ul>
        <li class="home"><a href="/">Home<span></span></a></li>
        <li><a href="http://cpbxx.lofter.com/" target="blank">Works<span></span></a></li>
        <li class="home_notes_showon" ><a href="/">Notes<span></span></a></li>
        <li><a href="./tucaos.html">Tucaos<span></span></a></li>
      </ul>
    </div>
</header>

      <div class="outer">
        <section id="main"><div class="main_center"><article id="post-JS高程（七）" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JS高程（七）
    </h1>
  


        <div class="article-meta">
          <span class="article-date">
  <time datetime="2017-03-13T11:25:47.000Z" itemprop="datePublished">Mar 13 2017</time>
</span>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h2><p>函数表达式是干什么的？用来创建函数的。创建函数的方法有：<strong>函数声明</strong>、<strong>函数表达式</strong>。</p>
<p>函数声明，有个特征：<strong>函数声明提升</strong>。函数表达式并没有。</p>
<p>函数表达式的语法形式：有两种？一种，创建一个函数表达式，没有给这个函数表达式起名字。这个函数就叫做<strong>匿名函数（拉姆达函数）</strong>；另一种，创建一个函数表达式，并给这个函数表达式起了个名字。这个函数就叫做<strong>命名函数表达式</strong>。</p>
<a id="more"></a>
<h3 id="1-1-匿名函数"><a href="#1-1-匿名函数" class="headerlink" title="1.1 匿名函数"></a>1.1 匿名函数</h3><p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个function() &#123;...&#125;就是匿名函数（它并没有名字，但是sayHi指向了它），函数表达式。</span></div><div class="line"><span class="keyword">var</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Hi!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-2-命名函数表达式"><a href="#1-2-命名函数表达式" class="headerlink" title="1.2 命名函数表达式"></a>1.2 命名函数表达式</h3><p>举个例子。</p>
<p>先介绍下<strong>递归</strong>，在第五章的<strong>函数的属性和方法</strong>中，讲到<strong>函数内部的对象arguments的属性callee</strong>时并没有搞懂。arguments是传给函数的参数所在地，callee是指向拥有这个arguments对象的函数（指针）。（callee不知道什么意思，但像caller，召唤者）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 阶乘，典型的用到了递归</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 有个问题 就是 当factorial指向了其他地方，函数内部的factorial也不能用了。</span></div><div class="line"><span class="keyword">var</span> anotherFactorial = factorial;</div><div class="line">factorial = <span class="literal">null</span>;</div><div class="line"><span class="comment">// 函数名只是个指针！！！ </span></div><div class="line"><span class="comment">// 所以其实可以进行递归的函数还在堆内存中，只是现在找不到指引到它的指针了 ？？貌似不能这样解释</span></div><div class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">// 错误！！！ factorial已经被置成空了</span></div><div class="line"></div><div class="line"><span class="comment">// 用arguments.callee来解决这个问题</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>); <span class="comment">// 注意！！！</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherFactorial = factorial;</div><div class="line">factorial = <span class="literal">null</span>;</div><div class="line"><span class="comment">// 用来阶乘的函数在对象中，其内部并没有用其他的函数名（指针），而是用了自己（arguments.callee），所以就不会再“迷路”了？？能这样解释吗？？</span></div><div class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">// 24 成功</span></div></pre></td></tr></table></figure></p>
<p>貌似用arguments.callee很好的解决了递归问题，但是在严格模式下，并不能访问arguments.callee！！！此时用命名函数表达式可以解决这个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;); </div><div class="line"></div><div class="line"><span class="keyword">var</span> anoterFactorial = factorial;</div><div class="line">factorial = <span class="literal">null</span>;</div><div class="line">alert(anoterFactorial(<span class="number">4</span>)); <span class="comment">// 24</span></div><div class="line"></div><div class="line"><span class="comment">// 对上边的代码进行类似英语阅读理解中的长句分析……</span></div><div class="line"><span class="comment">// var factorial = (); ！！！</span></div><div class="line"><span class="comment">// 本来function f(num) &#123;...&#125; 是声明了一个名叫f(num)的函数，但是把它放进了()中！！！</span></div><div class="line"><span class="comment">// (function f(num) &#123;...&#125;) 这样，这就是一个表达式！！！ 这是一个什么表达式呢？函数表达式！！！而且这个函数表达式是有名字的，叫f(num)！！！</span></div><div class="line"><span class="comment">// 所以堆内存中有一个叫做f(num)的函数，anotherFactorail就指向它</span></div><div class="line"><span class="comment">// 上边一句的解释貌似不对。应该是当 var factorial = ();时在内存中创建了一个命名函数，factorial指向了它，之后anotherFactorial也指向了它。但是f(num)这个名字并不是在栈内存中声明的一个值，f()并不能指向它？？</span></div><div class="line">alert(f(<span class="number">4</span>)); <span class="comment">// 错误！！！ f is not defined</span></div><div class="line"><span class="comment">// 这样就用 命名函数表达式 解决递归问题</span></div></pre></td></tr></table></figure></p>
<p>函数表达式定义的函数怎样才能运行？可以让一个指针指向它，或者创建就立即执行。要不像上边的f(num)，在全局下就顶是没有定义。</p>
<h3 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h3><blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数</p>
</blockquote>
<p>再进行下长句分析，闭包是函数。</p>
<p>创建闭包的常见方式：在一个函数内部创建另一个函数。</p>
<p>理解闭包就要理解第四章中的<strong>执行环境及作用域</strong>当中的一系列概念。</p>
<p>最基本的概念：<strong>执行环境</strong>，所有“活动”都有其执行环境。最外层的执行环境就叫做<strong>全局执行环境</strong>。<br>每个执行环境都有之关联的<strong>变量对象</strong>，其中保存着在执行环境中定义的变量和函数。浏览器的全局执行环境的变量对象就是<strong>window对象</strong>。<br>每个函数也有自己的执行环境，它的<strong>变量对象</strong>也叫做<strong>活动对象</strong>？？<br>书中说是当代码在一个执行环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，其实感觉应该表达为创建一个<strong>该执行环境可以访问到的所有变量对象的一个作用域链</strong>，该链就把所有变量对象链起来了。（注意这儿是变量对象，是自身及其他执行环境的变量对象，而不是说某个变量、某个函数）</p>
<p>书中P179值得多看几遍。</p>
<p>可以把作用域链看做一个栈，其中保存的都是变量对象。先压哪些变量对象入栈、再压哪些变量对象入栈。</p>
<p>没有闭包，只有一个函数，执行到函数时，对于该函数的作用域链，先压该函数的活动对象（变量对象），再压全局的变量对象。在函数中访问某个变量时，就沿着这个链一步步去查。若是在该函数的活动对象上找见了，就不会再去全局的变量对象上找了。</p>
<p>若有闭包。（闭包 有人理解为 必须是在一个函数内部，并且访问了其包含函数的变量；但按照这书上的定义，闭包有权访问另一个函数上的变量就可。具体见<a href="https://www.zhihu.com/question/20479109" target="_blank" rel="external">这里</a>的讨论）对于包含函数和上边的解释一样。对于闭包，闭包的作用域链，先压闭包的活动对象，再压包含函数的变量对象，最后压全局的变量对象。</p>
<p>看几个例子。没有闭包的情况。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况1</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName(); <span class="comment">// Window</span></div><div class="line"></div><div class="line"><span class="comment">// 情况2.1</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName(); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 情况2.2</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name); </div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName(); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 情况3</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">    alert(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意在一个执行环境中有了var xxx，那么xxx就已经挂在该执行环境的变量对象上了。要是你在该执行环境中var xxx 之前使用xxx，实际上相当于该执行环境中已经声明了xxx，只不过是还未赋值，所以是undefined。</p>
<p><img src="..\JS高程（七）\case1.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case2.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case3.png" width="50%" height="50%"></p>
<p>看几个例子。有闭包。（我理解的函数中的函数？）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况4 有闭包</span></div><div class="line"><span class="comment">// 注意 这里都是getName后两个()！！！先执行getName再执行其返回的函数</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name); </div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Window Window</span></div><div class="line"></div><div class="line"><span class="comment">// 情况5 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// undefined undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 情况6 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// undefined Local</span></div><div class="line"></div><div class="line"><span class="comment">// 情况7 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Local Local</span></div><div class="line"></div><div class="line"><span class="comment">// 情况8 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">        <span class="keyword">var</span> name = <span class="string">"Local-Local"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Window undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 情况9 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> name = <span class="string">"Local-Local"</span>;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Window Local-Local</span></div><div class="line"></div><div class="line"><span class="comment">// 补充一种 和 本质和情况8一样</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Window undefined </span></div><div class="line"><span class="comment">// 形参的name也挂在了匿名函数的变量对象上了。</span></div></pre></td></tr></table></figure></p>
<p><img src="..\JS高程（七）\case4.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case5_case6.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case6_case7.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case8.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case9.png" width="50%" height="50%"></p>
<p>为什么会想这么多。因为今天看到一个题目：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> z = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(z);</div><div class="line">&#125;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">funArg</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> z = <span class="number">20</span>;</div><div class="line">    funArg();</div><div class="line">&#125;)(foo); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>开始想成了外边是一个匿名函数，并且立即执行了，把foo传进去，错误的把funArg()当成了匿名函数中存在的一个闭包……以为funArg()先去自身的变量对象上找z，没有；再去其包含函数(function(){…})上找z，找到了，是20，那么就打印出20……<br>这个问题还不是说什么情况下才是闭包？而是说<strong>函数名只是个指针</strong>。首先声明了一个foo函数，该函数的变量对象上啥也没，但它能访问到全局执行环境的变量对象上的z，是10。而执行匿名函数时，只是相当于 var funArg = foo; funArg也指向了该函数，它并不是外边匿名函数的闭包。实际上如下图所示：</p>
<p><img src="..\JS高程（七）\case0.1.png" width="50%" height="50%"></p>
<p>若是像这样的话：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> z = <span class="number">10</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> z = <span class="number">20</span>;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(z)</div><div class="line">    &#125;)();</div><div class="line">&#125;)(); <span class="comment">// 20</span></div></pre></td></tr></table></figure></p>
<p>有两个匿名函数，并且都立即执行了。内部的匿名函数的作用域链0号指向自己的活动对象（无z），1号指向外部匿名函数的活动对象（有z），2号指向全局的变量对象（有z 但找不到这儿了）。这儿的匿名函数就是闭包。</p>
<p><img src="..\JS高程（七）\case0.2.png" width="50%" height="50%"></p>
<h4 id="2-1-闭包与变量"><a href="#2-1-闭包与变量" class="headerlink" title="2.1 闭包与变量"></a>2.1 闭包与变量</h4><p>闭包可以访问到的变量都是存在它的作用域链链起来的各个<strong>变量对象</strong>上，并不是某个变量或者某个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 预想的是创建一个函数数组，每一个都返回其在数组中的索引</span></div><div class="line"><span class="comment">// 这里匿名函数就是闭包，并且访问了其包含函数上的变量i</span></div><div class="line"><span class="comment">// 但这个有问题。循环中创建的所有匿名函数访问到的i都只是同一个i</span></div><div class="line"><span class="comment">// 所以在循环过程中i在变，但i每变一次，已经创建好的匿名函数所访问到的i也就变了，</span></div><div class="line"><span class="comment">// 最终i就是10</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> functions = createFunctions();</div><div class="line"></div><div class="line">functions[<span class="number">0</span>](); <span class="comment">// 10</span></div><div class="line">functions[<span class="number">1</span>](); <span class="comment">// 10</span></div><div class="line">functions[<span class="number">2</span>](); <span class="comment">// 10</span></div><div class="line"><span class="comment">// ... 10</span></div><div class="line">functions[<span class="number">9</span>](); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p><img src="..\JS高程（七）\notexpect.jpg" width="50%" height="50%"></p>
<p>这就是使用闭包访问变量时要注意的地方。可能和自己想要的结果不同。书中的解决方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 先创建了一个带参的匿名函数，并马上执行了，传入了i。我理解这个也是一个闭包，只是没有访问其包含函数的变量。</span></div><div class="line"><span class="comment">// 在这个匿名函数内，返回了一个匿名函数，所以这里边的匿名函数也是一个闭包，只不过访问到了它的包含函数上的变量num。（num在外层匿名函数的变量对象上。）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> num;</div><div class="line">            &#125;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> functions = createFunctions();</div><div class="line"></div><div class="line">functions[<span class="number">0</span>](); <span class="comment">// 0</span></div><div class="line">functions[<span class="number">1</span>](); <span class="comment">// 1</span></div><div class="line">functions[<span class="number">2</span>](); <span class="comment">// 2</span></div><div class="line"><span class="comment">// ... // </span></div><div class="line">functions[<span class="number">9</span>](); <span class="comment">// 9</span></div></pre></td></tr></table></figure></p>
<p><img src="..\JS高程（七）\expect.jpg" width="50%" height="50%"></p>
<p><a href="https://www.zhihu.com/question/20479109" target="_blank" rel="external">这里</a>大家讨论上边的解法是不是为了闭包而闭包。不用里层的匿名函数，直接返回num就好了。但是我认为，这只是为了统一例子内容。上边两个的result都是存的是函数，而这里的result存的是数字。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我认为这个匿名函数，也是闭包，虽然没有访问到包含函数中的变量。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> num;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> results = createFunctions();</div><div class="line"></div><div class="line">result; <span class="comment">// [0,1,2,3,4,5,6,7,8,9]</span></div></pre></td></tr></table></figure></p>
<h4 id="2-2-闭包中this对象"><a href="#2-2-闭包中this对象" class="headerlink" title="2.2 闭包中this对象"></a>2.2 闭包中this对象</h4><blockquote>
<p>匿名函数的执行环境具有全局性，因此其this对象通常指向window。</p>
</blockquote>
<p>其实不光是匿名函数，在全局作用域下定义的函数，在其中使用this，也指的是window。应该考虑到对象时才有意思。在对象中定义函数，在这个函数中使用this，那指的就是这个对象的实例。要是在这个<strong>对象的函数中还有匿名函数，或者命名函数表达式（即有函数表达式）</strong>？然后再在函数表达式中使用this，就是window而不是对象的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况1 没有闭包 全局作用域下定义的函数 使用this也是window对象</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">    alert(<span class="keyword">this</span>.name); <span class="comment">// Window</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 情况2 有闭包 对象的方法中的函数 匿名函数方式</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// object.getNameFunc()是一个函数，再加() 就是执行了这个函数</span></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// The Window</span></div><div class="line"></div><div class="line"><span class="comment">// 情况3 有闭包 对象的方法中的函数 命名函数表达式</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// The Window</span></div></pre></td></tr></table></figure>
<p>这是因为内部函数表达式上的变量对象上已经有了自己的this和arguments，不会再往上找其包含函数的变量对象的this了。</p>
<p>若是想要在闭包中使用包含函数的this：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 注意，这里的this就是getNameFunc变量对象上的this对象</span></div><div class="line">        <span class="comment">// 赋值给that that其实就指向了object。</span></div><div class="line">        <span class="comment">// 对象名 只是个指针！！！</span></div><div class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// My Object</span></div></pre></td></tr></table></figure></p>
<p>这种方式之后很常见。刚看了看Vue的例子，里边就有这种使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">new Vue() &#123;</div><div class="line">    el:xx,</div><div class="line">    data:&#123;</div><div class="line">        xx:xx;</div><div class="line">    &#125;,</div><div class="line">    methods:&#123;</div><div class="line">        getAnswer: function () &#123;</div><div class="line">            // 虽然这里的this 在Vue中已经被处理过了，但这里赋值给vm意思和上边的差不多</div><div class="line">            var vm = this</div><div class="line">            if (this.question.indexOf(&apos;?&apos;) === -1) &#123;</div><div class="line">                vm.answer = &apos;Questions usually contain a question mark. ;-)&apos;</div><div class="line">                return</div><div class="line">            &#125;</div><div class="line">            vm.answer = &apos;Thinking...&apos;</div><div class="line">            axios.get(&apos;https://yesno.wtf/api&apos;)</div><div class="line">                .then(function (response) &#123;</div><div class="line">                    vm.answer = _.capitalize(response.data.answer)</div><div class="line">                &#125;)</div><div class="line">                .catch(function (error) &#123;</div><div class="line">                    vm.answer = &apos;Error! Could not reach the API. &apos; + error</div><div class="line">                &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>书中最后一个例子挺有意思。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">object.getName(); <span class="comment">// My Objcet</span></div><div class="line">(object.getName)(); <span class="comment">// My Object</span></div><div class="line">(object.getName = object.getName)(); <span class="comment">// The Window</span></div></pre></td></tr></table></figure></p>
<p>前两个好理解。注意要把函数名当做是指针！！！</p>
<p>第三个要注意的是括号括起来()是一个表达式，一个赋值表达式，将object.getName(是个指针)，赋值给了object.getName(也是个指针)，最后这个表达式会返回一个函数，就是后边object.getName所指向的函数！！！（就相当于 var a; 控制台返回undefined，然后 a = 4; 控制台返回4）再跟着使用()就是调用函数，就等于是在全局直接调用了这个函数。所以this是window。</p>
<p>这样画图应该不太对？栈内存应该在一块儿。object用到了它自己的一块。这样画图更清晰一点。<br><img src="..\JS高程（七）\bibaothis.jpg" width="50%" height="50%"></p>
<h3 id="3-使用函数表达式中匿名函数可以模仿块儿级作用域"><a href="#3-使用函数表达式中匿名函数可以模仿块儿级作用域" class="headerlink" title="3. 使用函数表达式中匿名函数可以模仿块儿级作用域"></a>3. 使用函数表达式中匿名函数可以模仿块儿级作用域</h3><p><strong>块儿级作用域</strong>，也叫作<strong>私有作用域</strong>。比如一个for循环，其他语言会把在其中定义的变量只用在for循环内，循环结束后这些变量也就被销毁了。但是JavaScript中并没有这样的私有作用域。但是可以用匿名函数模拟私有作用域。</p>
<p>定义一个匿名函数，并且立即执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里是私有作用域</span></div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// 这样是不行的，会认为function是关键字，声明一个函数，但没有跟函数名，会产生错误</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。</p>
</blockquote>
<h3 id="4-私有变量"><a href="#4-私有变量" class="headerlink" title="4. 私有变量"></a>4. 私有变量</h3><p>JS没有<strong>私有成员</strong>？？<br>JS<strong>对象属性是公有的</strong>？？<br>怎样理解？私有成员说的是什么呢？对象属性，对象的属性？</p>
<p>JS中有<strong>私有变量</strong>的概念。私有变量是在函数中定义的变量，所谓私有，是指不能在函数外部访问这些变量。私有变量包括：<strong>函数的参数</strong>、<strong>局部变量</strong>、<strong>在函数内部定义的其他函数</strong>。</p>
<p>想要在函数外访问到这些私有变量，即用一些<strong>公有方法</strong>，访问私有变量，这样的公有方法被称作<strong>特权方法</strong>。</p>
<p>可以使用<strong>函数表达式</strong>创建特权方法。</p>
<h4 id="4-1-法一：在构造函数中使用匿名函数，闭包，访问私有变量"><a href="#4-1-法一：在构造函数中使用匿名函数，闭包，访问私有变量" class="headerlink" title="4.1 法一：在构造函数中使用匿名函数，闭包，访问私有变量"></a>4.1 法一：在构造函数中使用匿名函数，闭包，访问私有变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// name 是一个私有变量，注意这里只有一个name，就是Person函数的参数</span></div><div class="line"><span class="comment">// getName中的name很好理解。</span></div><div class="line"><span class="comment">// setName中的name也是构造函数的参数。</span></div><div class="line"><span class="comment">// setName和getName中的name是一回事。都是在闭包中访问包含函数上的变量。</span></div><div class="line"><span class="comment">// 先在自己的活动对象上找，没有，然后再去包含函数的活动对象上找。找到了参数name。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>);</div><div class="line">alert(person.getName()); <span class="comment">// DaShuaiBi</span></div><div class="line">person.setName(<span class="string">"HeiHeiHei"</span>);</div><div class="line">alert(person.getName()); <span class="comment">// HeiHeiHei</span></div><div class="line"></div><div class="line"><span class="comment">// 继续上边的解释，如果在getName和setName的包含函数上再定义一个局部变量</span></div><div class="line"><span class="comment">// 也叫做name的话，那闭包中找的name应该是局部变量的name而不是参数上的name！！！</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"局部变量"</span>;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span> + <span class="string">"参数进来的"</span>);</div><div class="line">alert(person.getName()); <span class="comment">// 局部变量 （注意！！！）</span></div><div class="line">person.setName(<span class="string">"HeiHeiHei"</span>);</div><div class="line">alert(person.getName()); <span class="comment">// HeiHeiHei</span></div></pre></td></tr></table></figure>
<p>缺点：和之前使用构造函数创建对象的缺点类似。每个实例的方法都是不一样的，浪费空间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"ErShuai"</span>);</div><div class="line"></div><div class="line">person.getName == person2.getName; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h4 id="4-2-法二：利用匿名函数创建私有作用域，在私有作用域定义私有变量，在其中再创建函数，这些函数就是特权方法了。"><a href="#4-2-法二：利用匿名函数创建私有作用域，在私有作用域定义私有变量，在其中再创建函数，这些函数就是特权方法了。" class="headerlink" title="4.2 法二：利用匿名函数创建私有作用域，在私有作用域定义私有变量，在其中再创建函数，这些函数就是特权方法了。"></a>4.2 法二：利用匿名函数创建私有作用域，在私有作用域定义私有变量，在其中再创建函数，这些函数就是特权方法了。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// name 就是私有变量（外部匿名函数的），在这里逻辑上是Person的属性！！！！</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">""</span>;</div><div class="line">    <span class="comment">// 注意这里没有用 function Person(value) &#123;name = value&#125;</span></div><div class="line">    <span class="comment">// 因为函数声明只能创建局部函数！！！</span></div><div class="line">    <span class="comment">// 没有使用var的变量初始化，将创建全局变量！！！</span></div><div class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuai"</span>);</div><div class="line">alert(person1.getName()); <span class="comment">// DaShuai</span></div><div class="line">person1.setName(<span class="string">"HeiHeiHei"</span>);  </div><div class="line">alert(person1.getName()); <span class="comment">// HeiHeiHei</span></div></pre></td></tr></table></figure>
<p>优点：解决了使用构造函数，在闭包中访问私有变量时，每个实例方法都是独立的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"ErShuai"</span>);</div><div class="line">alert(person1.getName == person2.getName); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>缺点：每个实例都没有自己的私有变量。就类似使用原型模式创建对象时的问题。但是可惜的是，那时在实例中可以<strong>覆盖</strong>掉原型上的同名属性。这里不行了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person2.getName()); <span class="comment">// ErShuai</span></div><div class="line">alert(person1.getName()); <span class="comment">// ErShuai</span></div></pre></td></tr></table></figure></p>
<p>问，可以像之前使用<strong>组合使用构造函数和原型模式创建对象</strong>那样，在这里创建特权方法吗？貌似是不行的，私有变量，特权方法，和之前的对象还是很不一样的。比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// 构造函数中name是私有变量了，但getName和setName并不是Person函数的闭包，不能访问name</span></div><div class="line"><span class="comment">// 而且getName和setName中的name都算是全局中的变量了！！！没有使用var，在其作用域链上也找不到name。</span></div><div class="line"><span class="comment">// 最重要的，外部的匿名函数虽说创建了一个私有作用域，但根本就没用……</span></div></pre></td></tr></table></figure></p>
<p>这样呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = value;</div><div class="line"></div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuai"</span>); </div><div class="line">alert(person1.getName()); <span class="comment">// DaShuai</span></div><div class="line">person1.setName(<span class="string">"HeiHeiHei"</span>); </div><div class="line">alert(person1.getName()); <span class="comment">// HeiHeiHei</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"ErShuai"</span>);</div><div class="line">alert(person1.getName == person2.getName); <span class="comment">// true 这里符合期望 是在原型上创建的方法</span></div><div class="line">alert(person2.getName()); <span class="comment">// ErShuai </span></div><div class="line">alert(person1.getName()); <span class="comment">// ErShuai ！！！注意，这里就不符合期望了，</span></div><div class="line"><span class="comment">//这个name是在Person这个函数的活动对象上局部变量，这里注意不应该说是person1和person2的name，而是说getName和setName是Person中的闭包，它们沿着作用域链去找name，找到的都是同一个！！！</span></div></pre></td></tr></table></figure></p>
<p>书中还有两部分讲为<strong>单例</strong>创建私有变量和特权方法的<strong>模块模式</strong>和<strong>增强的模块儿模式</strong>。但不知道具体的使用方式、场景？？？</p>
<p>还有整个<strong>私有变量</strong>和<strong>特权方法</strong>这块儿感觉比较乱……</p>
<p>2017.03.16</p>

      
    </div>
    <footer class="article-footer">
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基础/">js基础</a></li></ul>


    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/03/29/Python爬虫-爬取孙艺珍Instagram上的照片和视频/" id="article-nav-newer" class="article-nav-link-wrap">WEI</a>
  
  
    <a href="/2017/03/05/JS高程（六）/" id="article-nav-older" class="article-nav-link-wrap">ALI</a>
  
</nav>


  
</article>


</div>
</section>
      </div>
    </div>
  </div>
</body>
</html>
