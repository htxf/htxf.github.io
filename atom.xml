<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Htxf-fxtH</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-16T08:39:47.062Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>htxf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS高程（七）</title>
    <link href="http://yoursite.com/2017/03/13/JS%E9%AB%98%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/13/JS高程（七）/</id>
    <published>2017-03-13T11:25:47.000Z</published>
    <updated>2017-03-16T08:39:47.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h2><p>函数表达式是干什么的？用来创建函数的。创建函数的方法有：<strong>函数声明</strong>、<strong>函数表达式</strong>。</p>
<p>函数声明，有个特征：<strong>函数声明提升</strong>。函数表达式并没有。</p>
<p>函数表达式的语法形式：有两种？一种，创建一个函数表达式，没有给这个函数表达式起名字。这个函数就叫做<strong>匿名函数（拉姆达函数）</strong>；另一种，创建一个函数表达式，并给这个函数表达式起了个名字。这个函数就叫做<strong>命名函数表达式</strong>。</p>
<a id="more"></a>
<h3 id="1-1-匿名函数"><a href="#1-1-匿名函数" class="headerlink" title="1.1 匿名函数"></a>1.1 匿名函数</h3><p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个function() &#123;...&#125;就是匿名函数（它并没有名字，但是sayHi指向了它），函数表达式。</span></div><div class="line"><span class="keyword">var</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Hi!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-2-命名函数表达式"><a href="#1-2-命名函数表达式" class="headerlink" title="1.2 命名函数表达式"></a>1.2 命名函数表达式</h3><p>举个例子。</p>
<p>先介绍下<strong>递归</strong>，在第五章的<strong>函数的属性和方法</strong>中，讲到<strong>函数内部的对象arguments的属性callee</strong>时并没有搞懂。arguments是传给函数的参数所在地，callee是指向拥有这个arguments对象的函数（指针）。（callee不知道什么意思，但像caller，召唤者）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 阶乘，典型的用到了递归</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * factorial(num - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 有个问题 就是 当factorial指向了其他地方，函数内部的factorial也不能用了。</span></div><div class="line"><span class="keyword">var</span> anotherFactorial = factorial;</div><div class="line">factorial = <span class="literal">null</span>;</div><div class="line"><span class="comment">// 函数名只是个指针！！！ </span></div><div class="line"><span class="comment">// 所以其实可以进行递归的函数还在堆内存中，只是现在找不到指引到它的指针了 ？？貌似不能这样解释</span></div><div class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">// 错误！！！ factorial已经被置成空了</span></div><div class="line"></div><div class="line"><span class="comment">// 用arguments.callee来解决这个问题</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>); <span class="comment">// 注意！！！</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherFactorial = factorial;</div><div class="line">factorial = <span class="literal">null</span>;</div><div class="line"><span class="comment">// 用来阶乘的函数在对象中，其内部并没有用其他的函数名（指针），而是用了自己（arguments.callee），所以就不会再“迷路”了？？能这样解释吗？？</span></div><div class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">// 24 成功</span></div></pre></td></tr></table></figure></p>
<p>貌似用arguments.callee很好的解决了递归问题，但是在严格模式下，并不能访问arguments.callee！！！此时用命名函数表达式可以解决这个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> num * f(num - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;); </div><div class="line"></div><div class="line"><span class="keyword">var</span> anoterFactorial = factorial;</div><div class="line">factorial = <span class="literal">null</span>;</div><div class="line">alert(anoterFactorial(<span class="number">4</span>)); <span class="comment">// 24</span></div><div class="line"></div><div class="line"><span class="comment">// 对上边的代码进行类似英语阅读理解中的长句分析……</span></div><div class="line"><span class="comment">// var factorial = (); ！！！</span></div><div class="line"><span class="comment">// 本来function f(num) &#123;...&#125; 是声明了一个名叫f(num)的函数，但是把它放进了()中！！！</span></div><div class="line"><span class="comment">// (function f(num) &#123;...&#125;) 这样，这就是一个表达式！！！ 这是一个什么表达式呢？函数表达式！！！而且这个函数表达式是有名字的，叫f(num)！！！</span></div><div class="line"><span class="comment">// 所以堆内存中有一个叫做f(num)的函数，anotherFactorail就指向它</span></div><div class="line"><span class="comment">// 上边一句的解释貌似不对。应该是当 var factorial = ();时在内存中创建了一个命名函数，factorial指向了它，之后anotherFactorial也指向了它。但是f(num)这个名字并不是在栈内存中声明的一个值，f()并不能指向它？？</span></div><div class="line">alert(f(<span class="number">4</span>)); <span class="comment">// 错误！！！ f is not defined</span></div><div class="line"><span class="comment">// 这样就用 命名函数表达式 解决递归问题</span></div></pre></td></tr></table></figure></p>
<p>函数表达式定义的函数怎样才能运行？可以让一个指针指向它，或者创建就立即执行。要不像上边的f(num)，在全局下就顶是没有定义。</p>
<h3 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h3><blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数</p>
</blockquote>
<p>再进行下长句分析，闭包是函数。</p>
<p>创建闭包的常见方式：在一个函数内部创建另一个函数。</p>
<p>理解闭包就要理解第四章中的<strong>执行环境及作用域</strong>当中的一系列概念。</p>
<p>最基本的概念：<strong>执行环境</strong>，所有“活动”都有其执行环境。最外层的执行环境就叫做<strong>全局执行环境</strong>。<br>每个执行环境都有之关联的<strong>变量对象</strong>，其中保存着在执行环境中定义的变量和函数。浏览器的全局执行环境的变量对象就是<strong>window对象</strong>。<br>每个函数也有自己的执行环境，它的<strong>变量对象</strong>也叫做<strong>活动对象</strong>？？<br>书中说是当代码在一个执行环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，其实感觉应该表达为创建一个<strong>该执行环境可以访问到的所有变量对象的一个作用域链</strong>，该链就把所有变量对象链起来了。（注意这儿是变量对象，是自身及其他执行环境的变量对象，而不是说某个变量、某个函数）</p>
<p>书中P179值得多看几遍。</p>
<p>可以把作用域链看做一个栈，其中保存的都是变量对象。先压哪些变量对象入栈、再压哪些变量对象入栈。</p>
<p>没有闭包，只有一个函数，执行到函数时，对于该函数的作用域链，先压该函数的活动对象（变量对象），再压全局的变量对象。在函数中访问某个变量时，就沿着这个链一步步去查。若是在该函数的活动对象上找见了，就不会再去全局的变量对象上找了。</p>
<p>若有闭包。（闭包 有人理解为 必须是在一个函数内部，并且访问了其包含函数的变量；但按照这书上的定义，闭包有权访问另一个函数上的变量就可。具体见<a href="https://www.zhihu.com/question/20479109" target="_blank" rel="external">这里</a>的讨论）对于包含函数和上边的解释一样。对于闭包，闭包的作用域链，先压闭包的活动对象，再压包含函数的变量对象，最后压全局的变量对象。</p>
<p>看几个例子。没有闭包的情况。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况1</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName(); <span class="comment">// Window</span></div><div class="line"></div><div class="line"><span class="comment">// 情况2.1</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName(); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 情况2.2</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name); </div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName(); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 情况3</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">    alert(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意在一个执行环境中有了var xxx，那么xxx就已经挂在该执行环境的变量对象上了。要是你在该执行环境中var xxx 之前使用xxx，实际上相当于该执行环境中已经声明了xxx，只不过是还未赋值，所以是undefined。</p>
<p><img src="..\JS高程（七）\case1.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case2.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case3.png" width="50%" height="50%"></p>
<p>看几个例子。有闭包。（我理解的函数中的函数？）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况4 有闭包</span></div><div class="line"><span class="comment">// 注意 这里都是getName后两个()！！！先执行getName再执行其返回的函数</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name); </div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Window Window</span></div><div class="line"></div><div class="line"><span class="comment">// 情况5 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// undefined undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 情况6 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// undefined Local</span></div><div class="line"></div><div class="line"><span class="comment">// 情况7 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Local Local</span></div><div class="line"></div><div class="line"><span class="comment">// 情况8 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">        <span class="keyword">var</span> name = <span class="string">"Local-Local"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Window undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 情况9 有闭包</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> name = <span class="string">"Local-Local"</span>;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Window Local-Local</span></div><div class="line"></div><div class="line"><span class="comment">// 补充一种 和 本质和情况8一样</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        alert(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getName()(); <span class="comment">// Window undefined </span></div><div class="line"><span class="comment">// 形参的name也挂在了匿名函数的变量对象上了。</span></div></pre></td></tr></table></figure></p>
<p><img src="..\JS高程（七）\case4.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case5_case6.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case6_case7.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case8.png" width="50%" height="50%"><br><img src="..\JS高程（七）\case9.png" width="50%" height="50%"></p>
<p>为什么会想这么多。因为今天看到一个题目：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> z = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(z);</div><div class="line">&#125;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">funArg</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> z = <span class="number">20</span>;</div><div class="line">    funArg();</div><div class="line">&#125;)(foo); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>开始想成了外边是一个匿名函数，并且立即执行了，把foo传进去，错误的把funArg()当成了匿名函数中存在的一个闭包……以为funArg()先去自身的变量对象上找z，没有；再去其包含函数(function(){…})上找z，找到了，是20，那么就打印出20……<br>这个问题还不是说什么情况下才是闭包？而是说<strong>函数名只是个指针</strong>。首先声明了一个foo函数，该函数的变量对象上啥也没，但它能访问到全局执行环境的变量对象上的z，是10。而执行匿名函数时，只是相当于 var funArg = foo; funArg也指向了该函数，它并不是外边匿名函数的闭包。实际上如下图所示：</p>
<p><img src="..\JS高程（七）\case0.1.png" width="50%" height="50%"></p>
<p>若是像这样的话：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> z = <span class="number">10</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> z = <span class="number">20</span>;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(z)</div><div class="line">    &#125;)();</div><div class="line">&#125;)(); <span class="comment">// 20</span></div></pre></td></tr></table></figure></p>
<p>有两个匿名函数，并且都立即执行了。内部的匿名函数的作用域链0号指向自己的活动对象（无z），1号指向外部匿名函数的活动对象（有z），2号指向全局的变量对象（有z 但找不到这儿了）。这儿的匿名函数就是闭包。</p>
<p><img src="..\JS高程（七）\case0.2.png" width="50%" height="50%"></p>
<h4 id="2-1-闭包与变量"><a href="#2-1-闭包与变量" class="headerlink" title="2.1 闭包与变量"></a>2.1 闭包与变量</h4><p>闭包可以访问到的变量都是存在它的作用域链链起来的各个<strong>变量对象</strong>上，并不是某个变量或者某个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 预想的是创建一个函数数组，每一个都返回其在数组中的索引</span></div><div class="line"><span class="comment">// 这里匿名函数就是闭包，并且访问了其包含函数上的变量i</span></div><div class="line"><span class="comment">// 但这个有问题。循环中创建的所有匿名函数访问到的i都只是同一个i</span></div><div class="line"><span class="comment">// 所以在循环过程中i在变，但i每变一次，已经创建好的匿名函数所访问到的i也就变了，</span></div><div class="line"><span class="comment">// 最终i就是10</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> functions = createFunctions();</div><div class="line"></div><div class="line">functions[<span class="number">0</span>](); <span class="comment">// 10</span></div><div class="line">functions[<span class="number">1</span>](); <span class="comment">// 10</span></div><div class="line">functions[<span class="number">2</span>](); <span class="comment">// 10</span></div><div class="line"><span class="comment">// ... 10</span></div><div class="line">functions[<span class="number">9</span>](); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p><img src="..\JS高程（七）\notexpect.jpg" width="50%" height="50%"></p>
<p>这就是使用闭包访问变量时要注意的地方。可能和自己想要的结果不同。书中的解决方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 先创建了一个带参的匿名函数，并马上执行了，传入了i。我理解这个也是一个闭包，只是没有访问其包含函数的变量。</span></div><div class="line"><span class="comment">// 在这个匿名函数内，返回了一个匿名函数，所以这里边的匿名函数也是一个闭包，只不过访问到了它的包含函数上的变量num。（num在外层匿名函数的变量对象上。）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> num;</div><div class="line">            &#125;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> functions = createFunctions();</div><div class="line"></div><div class="line">functions[<span class="number">0</span>](); <span class="comment">// 0</span></div><div class="line">functions[<span class="number">1</span>](); <span class="comment">// 1</span></div><div class="line">functions[<span class="number">2</span>](); <span class="comment">// 2</span></div><div class="line"><span class="comment">// ... // </span></div><div class="line">functions[<span class="number">9</span>](); <span class="comment">// 9</span></div></pre></td></tr></table></figure></p>
<p><img src="..\JS高程（七）\expect.jpg" width="50%" height="50%"></p>
<p><a href="https://www.zhihu.com/question/20479109" target="_blank" rel="external">这里</a>大家讨论上边的解法是不是为了闭包而闭包。不用里层的匿名函数，直接返回num就好了。但是我认为，这只是为了统一例子内容。上边两个的result都是存的是函数，而这里的result存的是数字。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 我认为这个匿名函数，也是闭包，虽然没有访问到包含函数中的变量。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> num;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> results = createFunctions();</div><div class="line"></div><div class="line">result; <span class="comment">// [0,1,2,3,4,5,6,7,8,9]</span></div></pre></td></tr></table></figure></p>
<h4 id="2-2-闭包中this对象"><a href="#2-2-闭包中this对象" class="headerlink" title="2.2 闭包中this对象"></a>2.2 闭包中this对象</h4><blockquote>
<p>匿名函数的执行环境具有全局性，因此其this对象通常指向window。</p>
</blockquote>
<p>其实不光是匿名函数，在全局作用域下定义的函数，在其中使用this，也指的是window。应该考虑到对象时才有意思。在对象中定义函数，在这个函数中使用this，那指的就是这个对象的实例。要是在这个<strong>对象的函数中还有匿名函数，或者命名函数表达式（即有函数表达式）</strong>？然后再在函数表达式中使用this，就是window而不是对象的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况1 没有闭包 全局作用域下定义的函数 使用this也是window对象</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Local"</span>;</div><div class="line">    alert(<span class="keyword">this</span>.name); <span class="comment">// Window</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 情况2 有闭包 对象的方法中的函数 匿名函数方式</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// object.getNameFunc()是一个函数，再加() 就是执行了这个函数</span></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// The Window</span></div><div class="line"></div><div class="line"><span class="comment">// 情况3 有闭包 对象的方法中的函数 命名函数表达式</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// The Window</span></div></pre></td></tr></table></figure>
<p>这是因为内部函数表达式上的变量对象上已经有了自己的this和arguments，不会再往上找其包含函数的变量对象的this了。</p>
<p>若是想要在闭包中使用包含函数的this：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 注意，这里的this就是getNameFunc变量对象上的this对象</span></div><div class="line">        <span class="comment">// 赋值给that that其实就指向了object。</span></div><div class="line">        <span class="comment">// 对象名 只是个指针！！！</span></div><div class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> that.name;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// My Object</span></div></pre></td></tr></table></figure></p>
<p>这种方式之后很常见。刚看了看Vue的例子，里边就有这种使用。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue() &#123;</div><div class="line">    el:xx,</div><div class="line">    data:&#123;</div><div class="line">        xx:xx;</div><div class="line">    &#125;,</div><div class="line">    methods:&#123;</div><div class="line">        getAnswer: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 虽然这里的this 在Vue中已经被处理过了，但这里赋值给vm意思和上边的差不多</span></div><div class="line">            <span class="keyword">var</span> vm = <span class="keyword">this</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</div><div class="line">                vm.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            vm.answer = <span class="string">'Thinking...'</span></div><div class="line">            axios.get(<span class="string">'https://yesno.wtf/api'</span>)</div><div class="line">                .then(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> </span>&#123;</div><div class="line">                    vm.answer = _.capitalize(response.data.answer)</div><div class="line">                &#125;)</div><div class="line">                .<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> </span>&#123;</div><div class="line">                    vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</div><div class="line">                &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>书中最后一个例子挺有意思。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line"></div><div class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">object.getName(); <span class="comment">// My Objcet</span></div><div class="line">(object.getName)(); <span class="comment">// My Object</span></div><div class="line">(object.getName = object.getName)(); <span class="comment">// The Window</span></div></pre></td></tr></table></figure></p>
<p>前两个好理解。注意要把函数名当做是指针！！！</p>
<p>第三个要注意的是括号括起来()是一个表达式，一个赋值表达式，将object.getName(是个指针)，赋值给了object.getName(也是个指针)，最后这个表达式会返回一个函数，就是后边object.getName所指向的函数！！！（就相当于 var a; 控制台返回undefined，然后 a = 4; 控制台返回4）再跟着使用()就是调用函数，就等于是在全局直接调用了这个函数。所以this是window。</p>
<p>这样画图应该不太对？栈内存应该在一块儿。object用到了它自己的一块。这样画图更清晰一点。<br><img src="..\JS高程（七）\bibaothis.jpg" width="50%" height="50%"></p>
<h3 id="3-使用函数表达式中匿名函数可以模仿块儿级作用域"><a href="#3-使用函数表达式中匿名函数可以模仿块儿级作用域" class="headerlink" title="3. 使用函数表达式中匿名函数可以模仿块儿级作用域"></a>3. 使用函数表达式中匿名函数可以模仿块儿级作用域</h3><p><strong>块儿级作用域</strong>，也叫作<strong>私有作用域</strong>。比如一个for循环，其他语言会把在其中定义的变量只用在for循环内，循环结束后这些变量也就被销毁了。但是JavaScript中并没有这样的私有作用域。但是可以用匿名函数模拟私有作用域。</p>
<p>定义一个匿名函数，并且立即执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里是私有作用域</span></div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// 这样是不行的，会认为function是关键字，声明一个函数，但没有跟函数名，会产生错误</span></div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。</p>
</blockquote>
<h3 id="4-私有变量"><a href="#4-私有变量" class="headerlink" title="4. 私有变量"></a>4. 私有变量</h3><p>JS没有<strong>私有成员</strong>？？<br>JS<strong>对象属性是公有的</strong>？？<br>怎样理解？私有成员说的是什么呢？对象属性，对象的属性？</p>
<p>JS中有<strong>私有变量</strong>的概念。私有变量是在函数中定义的变量，所谓私有，是指不能在函数外部访问这些变量。私有变量包括：<strong>函数的参数</strong>、<strong>局部变量</strong>、<strong>在函数内部定义的其他函数</strong>。</p>
<p>想要在函数外访问到这些私有变量，即用一些<strong>公有方法</strong>，访问私有变量，这样的公有方法被称作<strong>特权方法</strong>。</p>
<p>可以使用<strong>函数表达式</strong>创建特权方法。</p>
<h4 id="4-1-法一：在构造函数中使用匿名函数，闭包，访问私有变量"><a href="#4-1-法一：在构造函数中使用匿名函数，闭包，访问私有变量" class="headerlink" title="4.1 法一：在构造函数中使用匿名函数，闭包，访问私有变量"></a>4.1 法一：在构造函数中使用匿名函数，闭包，访问私有变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// name 是一个私有变量，注意这里只有一个name，就是Person函数的参数</span></div><div class="line"><span class="comment">// getName中的name很好理解。</span></div><div class="line"><span class="comment">// setName中的name也是构造函数的参数。</span></div><div class="line"><span class="comment">// setName和getName中的name是一回事。都是在闭包中访问包含函数上的变量。</span></div><div class="line"><span class="comment">// 先在自己的活动对象上找，没有，然后再去包含函数的活动对象上找。找到了参数name。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>);</div><div class="line">alert(person.getName()); <span class="comment">// DaShuaiBi</span></div><div class="line">person.setName(<span class="string">"HeiHeiHei"</span>);</div><div class="line">alert(person.getName()); <span class="comment">// HeiHeiHei</span></div><div class="line"></div><div class="line"><span class="comment">// 继续上边的解释，如果在getName和setName的包含函数上再定义一个局部变量</span></div><div class="line"><span class="comment">// 也叫做name的话，那闭包中找的name应该是局部变量的name而不是参数上的name！！！</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"局部变量"</span>;</div><div class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span> + <span class="string">"参数进来的"</span>);</div><div class="line">alert(person.getName()); <span class="comment">// 局部变量 （注意！！！）</span></div><div class="line">person.setName(<span class="string">"HeiHeiHei"</span>);</div><div class="line">alert(person.getName()); <span class="comment">// HeiHeiHei</span></div></pre></td></tr></table></figure>
<p>缺点：和之前使用构造函数创建对象的缺点类似。每个实例的方法都是不一样的，浪费空间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"ErShuai"</span>);</div><div class="line"></div><div class="line">person.getName == person2.getName; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h4 id="4-2-法二：利用匿名函数创建私有作用域，在私有作用域定义私有变量，在其中再创建函数，这些函数就是特权方法了。"><a href="#4-2-法二：利用匿名函数创建私有作用域，在私有作用域定义私有变量，在其中再创建函数，这些函数就是特权方法了。" class="headerlink" title="4.2 法二：利用匿名函数创建私有作用域，在私有作用域定义私有变量，在其中再创建函数，这些函数就是特权方法了。"></a>4.2 法二：利用匿名函数创建私有作用域，在私有作用域定义私有变量，在其中再创建函数，这些函数就是特权方法了。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// name 就是私有变量（外部匿名函数的），在这里逻辑上是Person的属性！！！！</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">""</span>;</div><div class="line">    <span class="comment">// 注意这里没有用 function Person(value) &#123;name = value&#125;</span></div><div class="line">    <span class="comment">// 因为函数声明只能创建局部函数！！！</span></div><div class="line">    <span class="comment">// 没有使用var的变量初始化，将创建全局变量！！！</span></div><div class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuai"</span>);</div><div class="line">alert(person1.getName()); <span class="comment">// DaShuai</span></div><div class="line">person1.setName(<span class="string">"HeiHeiHei"</span>);  </div><div class="line">alert(person1.getName()); <span class="comment">// HeiHeiHei</span></div></pre></td></tr></table></figure>
<p>优点：解决了使用构造函数，在闭包中访问私有变量时，每个实例方法都是独立的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"ErShuai"</span>);</div><div class="line">alert(person1.getName == person2.getName); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>缺点：每个实例都没有自己的私有变量。就类似使用原型模式创建对象时的问题。但是可惜的是，那时在实例中可以<strong>覆盖</strong>掉原型上的同名属性。这里不行了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person2.getName()); <span class="comment">// ErShuai</span></div><div class="line">alert(person1.getName()); <span class="comment">// ErShuai</span></div></pre></td></tr></table></figure></p>
<p>问，可以像之前使用<strong>组合使用构造函数和原型模式创建对象</strong>那样，在这里创建特权方法吗？貌似是不行的，私有变量，特权方法，和之前的对象还是很不一样的。比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="comment">// 构造函数中name是私有变量了，但getName和setName并不是Person函数的闭包，不能访问name</span></div><div class="line"><span class="comment">// 而且getName和setName中的name都算是全局中的变量了！！！没有使用var，在其作用域链上也找不到name。</span></div><div class="line"><span class="comment">// 最重要的，外部的匿名函数虽说创建了一个私有作用域，但根本就没用……</span></div></pre></td></tr></table></figure></p>
<p>这样呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = value;</div><div class="line"></div><div class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuai"</span>); </div><div class="line">alert(person1.getName()); <span class="comment">// DaShuai</span></div><div class="line">person1.setName(<span class="string">"HeiHeiHei"</span>); </div><div class="line">alert(person1.getName()); <span class="comment">// HeiHeiHei</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"ErShuai"</span>);</div><div class="line">alert(person1.getName == person2.getName); <span class="comment">// true 这里符合期望 是在原型上创建的方法</span></div><div class="line">alert(person2.getName()); <span class="comment">// ErShuai </span></div><div class="line">alert(person1.getName()); <span class="comment">// ErShuai ！！！注意，这里就不符合期望了，</span></div><div class="line"><span class="comment">//这个name是在Person这个函数的活动对象上局部变量，这里注意不应该说是person1和person2的name，而是说getName和setName是Person中的闭包，它们沿着作用域链去找name，找到的都是同一个！！！</span></div></pre></td></tr></table></figure></p>
<p>书中还有两部分讲为<strong>单例</strong>创建私有变量和特权方法的<strong>模块模式</strong>和<strong>增强的模块儿模式</strong>。但不知道具体的使用方式、场景？？？</p>
<p>还有整个<strong>私有变量</strong>和<strong>特权方法</strong>这块儿感觉比较乱……</p>
<p>2017.03.16</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第七章-函数表达式&quot;&gt;&lt;a href=&quot;#第七章-函数表达式&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数表达式&quot;&gt;&lt;/a&gt;第七章 函数表达式&lt;/h2&gt;&lt;p&gt;函数表达式是干什么的？用来创建函数的。创建函数的方法有：&lt;strong&gt;函数声明&lt;/strong&gt;、&lt;strong&gt;函数表达式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;函数声明，有个特征：&lt;strong&gt;函数声明提升&lt;/strong&gt;。函数表达式并没有。&lt;/p&gt;
&lt;p&gt;函数表达式的语法形式：有两种？一种，创建一个函数表达式，没有给这个函数表达式起名字。这个函数就叫做&lt;strong&gt;匿名函数（拉姆达函数）&lt;/strong&gt;；另一种，创建一个函数表达式，并给这个函数表达式起了个名字。这个函数就叫做&lt;strong&gt;命名函数表达式&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JS高程（六）</title>
    <link href="http://yoursite.com/2017/03/05/JS%E9%AB%98%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/05/JS高程（六）/</id>
    <published>2017-03-05T09:15:14.000Z</published>
    <updated>2017-03-08T12:18:16.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第6章-面向对象的程序设计"><a href="#第6章-面向对象的程序设计" class="headerlink" title="第6章 面向对象的程序设计"></a>第6章 面向对象的程序设计</h2><p>JS与传统的面向对象（Object-Oriented）的语言不同，它没有类的概念。</p>
<p>可以把JS的对象看作是散列表：无非就是一组名值对，其中值可以是<strong>数据</strong>或<strong>函数</strong>。</p>
<p><strong>每个对象</strong>都是基于一个<strong>引用类型</strong>创建的，这个引用类型可以是原生引用类型（Object、Array、Date、RegExp、Function、基本包装类型（Boolean、Number、String）、Math），也可以是用户自定义的类型。</p>
<a id="more"></a>
<p>两种简单的<strong>创建自定义对象</strong>的方法：</p>
<ul>
<li><p><strong>Object构造函数法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> king = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">king.name = <span class="string">"DaShuaiBi"</span>;</div><div class="line">king.job = <span class="string">"playAndPlay"</span>;</div><div class="line">king.age = <span class="number">27</span>;</div><div class="line">king.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"I\'m the king."</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>对象字面量法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 逗号隔开不同的属性 注意方法的写法</span></div><div class="line"><span class="keyword">var</span> king = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">"playAndPlay"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">27</span>,</div><div class="line">    <span class="attr">say</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"I'm the king."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-1-对象的属性"><a href="#6-1-对象的属性" class="headerlink" title="6.1 对象的属性"></a>6.1 对象的属性</h3><p>JS中对象的属性（property）有两种类型：<strong>数据属性</strong>和<strong>访问器属性</strong>，这两种属性都有自己的<strong>特性</strong>（attribute）。可以设置、更改、读取这些特性。</p>
<ul>
<li><p>数据属性<br>4个特性：[[Configurable]]（表示能否通过<strong>delete</strong>删除属性）、[[Enumerable]]（表示能否通过for-in循环返回属性）、[[Writable]]（表示能否<strong>修改属性的值</strong>）、[[Value]]</p>
<p>在对象中定义了某种属性，那么这种属性就是数据属性了？？</p>
</li>
<li><p>访问器属性<br>4个特性：[[Configurable]]、[[Enumerable]]、[[Get]]、[[Set]]</p>
<p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p>
</li>
</ul>
<p>三个方法</p>
<ul>
<li><p><strong>Object.defineProperty()</strong> 定义、修改属性<br>三个参数：属性所在对象、属性名、<span id="des">描述符对象（即属性特性的描述，属性特性名：xx）</span></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;&#125;;</div><div class="line"><span class="comment">// 设置了数据属性name</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</div><div class="line">    <span class="comment">// 设置person的name属性不可修改</span></div><div class="line">    writable: <span class="literal">false</span>,</div><div class="line">    <span class="attr">value</span>: <span class="string">"DaShuaiBi"</span></div><div class="line">&#125;);</div><div class="line">alert(person.name); <span class="comment">// DaShuaiBi</span></div><div class="line">person.name = <span class="string">"HeiHeiHei"</span>;</div><div class="line"><span class="comment">// 还是DaShuaiBi</span></div><div class="line">alert(person.name); <span class="comment">// "DaShuaiBi"</span></div></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这两个_year和edition属性 是数据属性 </span></div><div class="line"><span class="comment">// 这种形式，其属性特性中的configurable、enumerable和writable都默认是true</span></div><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">    <span class="attr">_year</span>: <span class="number">2004</span>,</div><div class="line">    <span class="attr">edition</span>: <span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 这个year是 访问器属性，设置了getter和setter方法</span></div><div class="line"><span class="comment">// 使用访问器属性常见的方法：设置一个属性（访问器属性）的值会导致其他属性（数据属性）发生变化</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">            <span class="keyword">this</span>._year = newValue;</div><div class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">alert(book._year); <span class="comment">// 2004</span></div><div class="line">alert(book.edition); <span class="comment">// 1</span></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line"><span class="comment">// 发现可以修改</span></div><div class="line">alert(book._year); <span class="comment">// 2005</span></div><div class="line">alert(book.edition); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p><strong>注意</strong>，在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false；而在之前使用Object构造函数和对象字面量方法创建的对象，其属性的这几个特性都默认为true。(上边第二段代码中的book的_year和edition就是通过对象字面量定义的属性)</p>
</li>
<li><p><strong>Object.defineProperties()</strong> 定义多个属性<br>两个参数：要添加或修改其属性的对象、一个对象（与第一个参数对象要添加或修改的属性一一对应，即{属性名1: {属性特姓名1: xx}, 属性名2: {属性特性名: xx}, 属性名3: { {属性特性名1: xx}, {属性特姓名2: xx}}）</p>
<p>注意，这是上边<strong>注意</strong>的一个例子。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;&#125;;</div><div class="line"><span class="comment">// 用这种方法设置了数据属性_year和edition，还有访问器属性year</span></div><div class="line"><span class="comment">// 但是与上边的方法不同。这里属性特性configurable、enumerable和writable都默认是false</span></div><div class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</div><div class="line">    <span class="attr">_year</span>: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="number">2004</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">edition</span>: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="number">1</span>;</div><div class="line">    &#125;,  </div><div class="line"></div><div class="line">    <span class="attr">year</span>: &#123;</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</div><div class="line">                <span class="keyword">this</span>._year = newValue;</div><div class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">alert(book._year); <span class="comment">// 2004</span></div><div class="line">alert(book.edition); <span class="comment">// 1</span></div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line"><span class="comment">// 发现并不能更改_year和edition的值</span></div><div class="line">alert(book._year); <span class="comment">// 2004</span></div><div class="line">alert(book.edition); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>Object.getOwnPropertyDescriptor()</strong> 读取属性的特性<br>两个参数：属性所在对象、要读取其描述符的特性名称；返回一个对象，包含相应的属性特性。</p>
</li>
</ul>
<h3 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h3><p>《JS高级程序设计》中可以说一共提供了9种<strong>创建对象</strong>的方法。为什么会有这么多的方法？要让JS更“面向对象”，就要满足一些要求。开始的方法不能很好的满足一定的要求，就会有新的方法出现。</p>
<p>总结这些要求大概有：</p>
<ul>
<li>1.代码复用</li>
<li>2.封装性、继承性？？、多态性？？</li>
<li>3.对象识别，即可以方便的知道实例是什么自定义类型 xxx instanceof XXX</li>
<li>4.实例间要有<strong>不同</strong>的<strong>基本值的属性</strong></li>
<li>5.实例间要有<strong>不同</strong>的<strong>引用类型值的属性</strong>，除Function之外 </li>
<li>6.实例间要有<strong>相同（共享）</strong>的函数（方法），空间复用？</li>
</ul>
<h4 id="Object构造函数法、对象字面量法"><a href="#Object构造函数法、对象字面量法" class="headerlink" title="Object构造函数法、对象字面量法"></a>Object构造函数法、对象字面量法</h4><p>本篇最开始就介绍了这两种方法。<br>缺点：不满足第1点要求，创建对个实例时会产生大量重复代码。</p>
<h4 id="rarr-rarr-工厂模式-larr-larr"><a href="#rarr-rarr-工厂模式-larr-larr" class="headerlink" title="&rarr;&rarr; 工厂模式 &larr;&larr;"></a>&rarr;&rarr; 工厂模式 &larr;&larr;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o.name = name;</div><div class="line">    o.age = age;</div><div class="line">    o.job = job;</div><div class="line">    o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(o.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 没有用 new ，只是调用函数</span></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>优点：解决了Object构造函数法和对象字面量方法的不足之处，代码可以复用。</p>
<p>缺点：不满足第3点要求（对象识别），不能知道person1和person2是什么样的自定义类型；不满足第6点，实例间的函数是不同的，（函数也是对象），占用空间。</p>
<h4 id="rarr-rarr-构造函数模式-larr-larr"><a href="#rarr-rarr-构造函数模式-larr-larr" class="headerlink" title="&rarr;&rarr; 构造函数模式 &larr;&larr;"></a>&rarr;&rarr; 构造函数模式 &larr;&larr;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用了new关键字</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>注意：Person的首字母是大写（惯例）</p>
<p>优点：解决了工厂模式的不足之一，可以进行对象识别。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></div><div class="line">alert(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></div><div class="line">alert(person2 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><span id="construct_fault">缺点：不满足第6点，实例间的函数是不同的，（函数也是对象），占用空间。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person1.sayName == person2.sayName; <span class="comment">// false</span></div><div class="line"><span class="comment">// 不能写成</span></div><div class="line">person1.sayName() == person2.sayName(); <span class="comment">// 先运行函数，再返回true（都是function？？ 不对，因为person1的sayName()方法没有返回值，默认是undefined）</span></div></pre></td></tr></table></figure></p>
<h4 id="构造函数模式的改进"><a href="#构造函数模式的改进" class="headerlink" title="构造函数模式的改进"></a>构造函数模式的改进</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.sayName = sayName;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 把函数定义转移到构造函数外部</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>优点：解决了构造函数模式的缺点，实例间的函数是相同的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person1.sayName == person2.sayName; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>缺点：应是实例的方法sayName现在成了全局函数，而且要是自定义类型的方法很多时，就得定义很多个全局函数。不满足第2点中的封装性。</p>
<h4 id="rarr-rarr-原型模式-larr-larr"><a href="#rarr-rarr-原型模式-larr-larr" class="headerlink" title="&rarr;&rarr; 原型模式 &larr;&larr;"></a>&rarr;&rarr; 原型模式 &larr;&larr;</h4><p>每个<strong>函数</strong>都有一个<strong>prototype属性</strong>，这个属性是个指针，指向一个对象，这个对象包含可以由特定类型的<strong>所有实例共享</strong>的属性和方法。</p>
<p>prototype是通过调用<strong>构造函数</strong>而创建的那个<strong>对象实例</strong>的<strong>原型对象</strong>。（prototype是对象）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"DaShuaiBi"</span>;</div><div class="line">Person.prototype.age = <span class="number">27</span>;</div><div class="line">Person.prototype.job = <span class="string">"playAndPlay"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person2.name = <span class="string">"HeiHeiHei"</span>;</div><div class="line">person2.age = <span class="number">18</span>;</div><div class="line">person2.job = <span class="string">"heixiuheixiu"</span>;</div></pre></td></tr></table></figure>
<p>优点：解决了构造函数模式的不足，实例的函数是同一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person1.sayName == person2.sayName; // true</div></pre></td></tr></table></figure></p>
<p>缺点：Person.prototype.代码重复太多；不满足第4、5点要求。由于原型对象上所有属性都是实例对象所共享的，结果默认情况下实例的基本值的属性和引用类型值的属性都一样。虽然可以通过在实例上添加同名属性来<strong>屏蔽</strong>原型对象上的同名属性，但当只是<strong>简单的修改实例上的引用类型值的属性</strong>时，就比较难受了。</p>
<h4 id="更简单的原型模式"><a href="#更简单的原型模式" class="headerlink" title="更简单的原型模式"></a>更简单的原型模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">// 用一个包含所有属性和方法的 对象字面量 来重写整个原型对象</span></div><div class="line"><span class="comment">// 注意这儿的constructor 之后再介绍</span></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">27</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">"playAndPlay"</span>,</div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>优点：解决了Person.prototype代码复用问题</p>
<p><span id="proto_fault">缺点：原型模式的真正缺点还没有解决。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">age</span>: <span class="number">27</span>,</div><div class="line">    <span class="attr">job</span>: <span class="string">"playAndPlay"</span>,</div><div class="line">    <span class="comment">// 引用类型值的属性 </span></div><div class="line">    friends: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>],</div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">// 假如没有更改person2的属性值</span></div><div class="line"><span class="comment">//person2.name = "HeiHeiHei";</span></div><div class="line"><span class="comment">//person2.age = 18;</span></div><div class="line"><span class="comment">//person2.job = "heixiuheixiu";</span></div><div class="line"><span class="comment">//person2.friends = ["haha","jiji"];</span></div><div class="line"></div><div class="line"><span class="comment">// 简单的修改person1的引用类型值的属性friends</span></div><div class="line">person1.friends.push(<span class="string">"SiShuai"</span>);</div><div class="line">alert(person1.friends); <span class="comment">// ErShuai,SanShuai,SiShuai</span></div><div class="line">alert(person2.friends); <span class="comment">// ErShuai,SanShuai,SiShuai !!! 注意此时并不想更改person2的friends，ErShuai,SanShuai是person1和person2共同的朋友，而SiShuai并不是。</span></div><div class="line">alert(person1.friends == person2.friends); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h4 id="hearts-hearts-hearts-rarr-rarr-组合使用构造函数模式和原型模式-larr-larr-hearts-hearts-hearts"><a href="#hearts-hearts-hearts-rarr-rarr-组合使用构造函数模式和原型模式-larr-larr-hearts-hearts-hearts" class="headerlink" title="&hearts;&hearts;&hearts; &rarr;&rarr; 组合使用构造函数模式和原型模式 &larr;&larr; &hearts;&hearts;&hearts;"></a>&hearts;&hearts;&hearts; &rarr;&rarr; 组合使用构造函数模式和原型模式 &larr;&larr; &hearts;&hearts;&hearts;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数用于定义实例的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="keyword">this</span>.friends = [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 原型模式用于定义方法和共享的属性</span></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person,</div><div class="line">    <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>优点：结合了构造函数模式和原型模式的优点。每个实例都有自己的一份<strong>实例属性的副本</strong>，但同时又<strong>共享着对方法的引用</strong>，最大限度地节省了内存。<br>解决了原型模式的不足。（使用最广泛、认同度最高）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 因为两个person中的属性name、age、job、friends在堆内存中两个不同的堆上。</span></div><div class="line"><span class="comment">// 两个person中friends更是在另两个堆上。</span></div><div class="line"><span class="comment">// 对象和对象的属性在内存中怎样表示？？？ 即怎样知道person1的name和age都在person1上，person1的friends在person1上同时又是一个新的堆内存上的对象？？？</span></div><div class="line">person1.friends.push(<span class="string">"SiShuai"</span>);</div><div class="line">alert(person1.friends); <span class="comment">// ErShuai,SanShuai,SiShuai</span></div><div class="line">alert(person2.friends); <span class="comment">// ErShuai,SanShuai</span></div><div class="line">alert(person1.friends == person2.friends); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>缺点：实例的不同属性（构造函数）、共享方法（原型对象）合起来才算是创建对象的方法。缺一点点封装性。</p>
<h4 id="hearts-hearts-hearts-rarr-rarr-动态原型模式-larr-larr-hearts-hearts-hearts"><a href="#hearts-hearts-hearts-rarr-rarr-动态原型模式-larr-larr-hearts-hearts-hearts" class="headerlink" title="&hearts;&hearts;&hearts; &rarr;&rarr; 动态原型模式 &larr;&larr; &hearts;&hearts;&hearts;"></a>&hearts;&hearts;&hearts; &rarr;&rarr; 动态原型模式 &larr;&larr; &hearts;&hearts;&hearts;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.job = job;</div><div class="line">    <span class="comment">// 把在原型对象上添加共享方法的代码写进构造函数中，并有个判断</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</div><div class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            alert(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>, <span class="string">"playAndPlay"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>, <span class="string">"heixiuheixiu"</span>);</div></pre></td></tr></table></figure>
<p>优点：if(){}代码块只会在初次调用构造函数时（生成person1时）才会执行。在生成person2时就不用执行了！JS中创建对象<strong>非常完美</strong>的方法。</p>
<h4 id="rarr-rarr-寄生构造函数模式-larr-larr"><a href="#rarr-rarr-寄生构造函数模式-larr-larr" class="headerlink" title="&rarr;&rarr; 寄生构造函数模式 &larr;&larr;"></a>&rarr;&rarr; 寄生构造函数模式 &larr;&larr;</h4><p>不太理解。函数中有return一个对象，创建对象时还使用new关键字？？？</p>
<h4 id="rarr-rarr-稳妥构造函数模式-larr-larr"><a href="#rarr-rarr-稳妥构造函数模式-larr-larr" class="headerlink" title="&rarr;&rarr; 稳妥构造函数模式 &larr;&larr;"></a>&rarr;&rarr; 稳妥构造函数模式 &larr;&larr;</h4><p>不太理解。虽说是xx构造函数模式，但函数中有return一个对象，创建对象时没有使用new关键字，更像是xx工厂模式？？？</p>
<h3 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h3><p>这部分和上边创建对象有很大联系。一些模式之间的代码结构很相似。</p>
<p>创建对象的方法：Object构造函数、对象字面量、工厂模式、构造函数模式、（构造函数模式的改进）、原型模式、（更简单的形式原型模式）、组合模式（构造函数+原型模式）、动态原型模式、寄生构造函数模式、稳妥构造函数模式。</p>
<p>继承方法：原型链继承、借用构造函数继承、组合继承（构造函数+原型链）、原型式继承、寄生式继承（原型式plus）、寄生组合式继承（寄生式+构造函数+原型链）</p>
<h4 id="rarr-rarr-原型链继承-larr-larr"><a href="#rarr-rarr-原型链继承-larr-larr" class="headerlink" title="&rarr;&rarr; 原型链继承 &larr;&larr;"></a>&rarr;&rarr; 原型链继承 &larr;&larr;</h4><p>关键语句 SubType.prototype = new SuperType();</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将SuperType的实例赋给SubType的原型对象 实现继承</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line"><span class="comment">// 能使用“父类”SuperType原型对象上的方法</span></div><div class="line">alert(instance.getSuperValue()); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 注意！！！</span></div><div class="line">SuperType.prototype.constructor; <span class="comment">// function SuperType() &#123;...&#125;</span></div><div class="line"></div><div class="line">SubType.prototype.constructor; <span class="comment">// function SuperType() &#123;...&#125; 也是SupserType！！！ 本来是SubType，但将new SuperType()赋给了SubType.prototype。书中说是就断了，没有了，但实际上是跟着SuperType.prototype的步伐指向了SuperType</span></div><div class="line">instance.constructor; <span class="comment">// function SuperType() &#123;...&#125;</span></div></pre></td></tr></table></figure>
<p><span id="proto_inherit">问题1：与<a href="#proto_fault">使用原型模式创建对象</a>时的问题类似</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 原型链继承</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">// red,blue,green,black</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">// red,blue,green,black 实际上并不想要black</span></div><div class="line"></div><div class="line"><span class="comment">//因为instance1、instance2都是SubType的实例，而它们的colors属性本来是在SuperType的构造函数中，通过SubType.prototype = new SuperType();实际上是在SubType.prototype上。又是引用类型的值的属性。就和使用原型模式创建对象的问题一样了。</span></div></pre></td></tr></table></figure></p>
<p>问题2：在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
<h4 id="rarr-rarr-借用构造函数继承-larr-larr"><a href="#rarr-rarr-借用构造函数继承-larr-larr" class="headerlink" title="&rarr;&rarr; 借用构造函数继承 &larr;&larr;"></a>&rarr;&rarr; 借用构造函数继承 &larr;&larr;</h4><p>关键语句 SuperType.call(this);</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;   </div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">    <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"hi"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.name = <span class="string">"siguoyi"</span>;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 借用构造函数 在SubType的构造函数中 运行SuperType函数，将其作用域定为SubType的实例</span></div><div class="line">    <span class="comment">// 实现继承 “复制”？？？</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.subproperty); <span class="comment">// false</span></div><div class="line">alert(instance.property); <span class="comment">// true</span></div><div class="line">instance.sayHi(); <span class="comment">// 弹出hi</span></div><div class="line">alert(instance.getSubValue()); <span class="comment">//  false</span></div><div class="line"></div><div class="line"><span class="comment">// 注意1！！！ 并不能使用父类型原型对象上定义的属性、方法</span></div><div class="line">instance.getSuperValue(); <span class="comment">// 出错！！！  Uncaught TypeError: instance.getSuperValue is not a function</span></div><div class="line">alert(instance.name); <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 注意2！！！</span></div><div class="line">SuperType.prototype.constructor; <span class="comment">// function SuperType() &#123;...&#125;</span></div><div class="line"></div><div class="line">SubType.prototype.constructor; <span class="comment">// function SubType() &#123;...&#125; 和原型链继承不同</span></div><div class="line">instance.constructor; <span class="comment">// function SubType() &#123;...&#125; 和原型链继承不同</span></div></pre></td></tr></table></figure>
<p>优点1：解决了原型链继承的问题1。子类型实例有各自的属性副本。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 比原型链继承好的地方</span></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors);</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors);</div></pre></td></tr></table></figure></p>
<p>优点2：解决原型链继承的问题2 可以个超类型的构造函数传递参数。</p>
<p>缺点：与<a href="#construct_fault">使用构造函数模式创建对象</a>的缺点类似。函数不能复用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">instance1.sayHi == instance2.sayHi <span class="comment">// false 父类型上的函数sayHi()并没有复用</span></div><div class="line">instance1.getSubValue == instance2.getSubValue <span class="comment">// true 这个不算 这是在子类型原型对象上定义的函数</span></div></pre></td></tr></table></figure></p>
<h4 id="hearts-hearts-hearts-rarr-rarr-组合继承-larr-larr-hearts-hearts-hearts"><a href="#hearts-hearts-hearts-rarr-rarr-组合继承-larr-larr-hearts-hearts-hearts" class="headerlink" title="&hearts;&hearts;&hearts; &rarr;&rarr; 组合继承 &larr;&larr; &hearts;&hearts;&hearts;"></a>&hearts;&hearts;&hearts; &rarr;&rarr; 组合继承 &larr;&larr; &hearts;&hearts;&hearts;</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="comment">// 构造函数继承</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 原型链继承</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line">SubType.prototype.constructor = SubType; <span class="comment">// 推荐写法</span></div><div class="line"></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>);</div><div class="line"></div><div class="line"><span class="comment">// 注意！！！</span></div><div class="line">SuperType.prototype.constructor; <span class="comment">// function SuperType() &#123;...&#125;</span></div><div class="line">SubType.prototype.constructor; <span class="comment">// function SubType() &#123;...&#125; 改回来了</span></div><div class="line">instance1.constructor; <span class="comment">// function SubType() &#123;...&#125; 改回来了</span></div></pre></td></tr></table></figure>
<p>优点：结合了原型链继承和借用构造函数继承的优点，消除了两者的缺点。JS中<strong>最常用的继承模式</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">// red,blue,green,black</span></div><div class="line">instance1.sayName(); <span class="comment">// DaShuaiBi</span></div><div class="line">instance1.sayAge(); <span class="comment">// 27</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instacne2 = <span class="keyword">new</span> SubType(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>);</div><div class="line">alert(instacne2.colors); <span class="comment">// red,blue,green 解决了原型链继承的问题</span></div><div class="line">instacne2.sayName(); <span class="comment">// HeiHeiHei</span></div><div class="line">instacne2.sayAge(); <span class="comment">// 18</span></div><div class="line"></div><div class="line">instance1.sayName == instance2.sayName; <span class="comment">// true 解决了借用构造函数继承的问题</span></div><div class="line">instance1.sayAge == instance2.sayAge; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><sapn id="comInherit">缺点：虽然最常用，也是有缺点。会调用超类型（SubType）构造函数两次。第一次：SubType.prototype = new SuperType(); 第二次：SuperType.call(this, name); （更准确的说应该是在实例化一个SubType时（调用SubType的构造函数时，因为这一行代码就在SubType的构造函数里边）） 。</sapn></p>
<h4 id="rarr-rarr-原型式继承-larr-larr"><a href="#rarr-rarr-原型式继承-larr-larr" class="headerlink" title="&rarr;&rarr; 原型式继承 &larr;&larr;"></a>&rarr;&rarr; 原型式继承 &larr;&larr;</h4><p>有两种方式。</p>
<p>第一种：ECMAScript5增加的方法<strong>Object.create()</strong><br>（其中属性描述符与<a href="#des">前边的</a>一样）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 有两个参数</span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</div><div class="line">    <span class="comment">// 属性描述符 </span></div><div class="line">    name: &#123;</div><div class="line">        <span class="attr">value</span>: <span class="string">"HeiHeiHei"</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name); <span class="comment">// "HeiHeiHei"</span></div><div class="line"></div><div class="line"><span class="comment">// 只有一个参数 </span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson.name = <span class="string">"HeiHeiHei"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 上面两种写法一模一样</span></div></pre></td></tr></table></figure></p>
<p>第二种 先自己定义一个函数object()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o; <span class="comment">// 把o当做是F的原型对象</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = object(person);</div><div class="line">anotherPerson.name = <span class="string">"HeiHeiHei"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 注意！！！</span></div><div class="line"><span class="comment">// 这种方法 就没有 构造函数 ！！！</span></div><div class="line">person.prototype.constructor; <span class="comment">//  错误！！！ 只有 构造函数（函数）才有prototype属性！！！</span></div><div class="line">anotherPerson.prototype.constructor; <span class="comment">// 错误！！！</span></div><div class="line"></div><div class="line">person.constructor; <span class="comment">// function Object() &#123;...&#125; 是Object的构造函数</span></div><div class="line">anotherPerson.constructor; <span class="comment">// function Object() &#123;...&#125;</span></div><div class="line"></div><div class="line">person.__proto__; <span class="comment">// 找person对象的原型对象 Object &#123;...&#125; 这个东西就是 Object.prototype 而不是Object的构造函数</span></div><div class="line"><span class="built_in">Object</span>.isPrototypeOf(person); <span class="comment">// false</span></div><div class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(person); <span class="comment">// true</span></div><div class="line"></div><div class="line">anotherPerson.__proto__; <span class="comment">// 注意 ！！！ 找anotherPerson的原型对象 Object &#123;name: "DaShuaiBi", friends: Array[2]&#125; 这个东西就是 person！！！</span></div><div class="line">anotherPerson.__proto__ == person; <span class="comment">// true</span></div><div class="line">person.isPrototypeOf(anotherPerson); <span class="comment">// true </span></div><div class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(anotherPerson); <span class="comment">// true 链起来了</span></div></pre></td></tr></table></figure></p>
<p>优点： <strong>不必兴师动众地创建构造函数</strong></p>
<p>缺点：当然没有构造函数，不能知道实例是什么“类型”，只是知道实例跟哪个对象很像；与<a href="#proto_fault">使用原型模式创建对象</a>及<a href="#proto_inherit">使用原型链继承</a>时的问题一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">anotherPerson.friends.push(<span class="string">"yoyoyo"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = <span class="string">"bang"</span>;</div><div class="line">yetAnotherPerson.friends.push(<span class="string">"zero"</span>);</div><div class="line"></div><div class="line">alert(person.friedns); <span class="comment">// ErShuai,SanShuai,yoyoyo,zero</span></div><div class="line">alert(person.name); <span class="comment">// DaShuaiBi</span></div></pre></td></tr></table></figure></p>
<p>原型式继承中，object()函数实际上是对传入其中的对象进行了一次<a href="http://www.cnblogs.com/tracylin/p/5346314.html" target="_blank" rel="external">浅复制</a>，浅复制是针对引用类型的值而言的。上边的例子中anotherPerson对person进行了浅复制，所以改变anotherPerson上的值，person上的值也会改变。可是name是基本类型值，所以是真的复制了一个副本出来，而friends是引用类型值，准确的说是浅复制了引用类型（对象）上的引用类型（数组Array）值。</p>
<h4 id="rarr-rarr-寄生式继承-larr-larr"><a href="#rarr-rarr-寄生式继承-larr-larr" class="headerlink" title="&rarr;&rarr; 寄生式继承 &larr;&larr;"></a>&rarr;&rarr; 寄生式继承 &larr;&larr;</h4><p>寄生式继承感觉是在原型式继承的基础上，又套了一层函数用来对新实例增加一些自己的东西。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型式继承中的函数 虽然 也可以是任何可以返回对象的函数，但不太懂。。暂且理解为与原型式中的一样</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"><span class="comment">// 再套一层函数，增加了sayHi方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> clone = object(original);</div><div class="line">    clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"hi"</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> clone;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"DaShuaiBi"</span>,</div><div class="line">    <span class="attr">friends</span>: [<span class="string">"ErShuai"</span>, <span class="string">"SanShuai"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line"></div><div class="line"><span class="comment">// 注意！！！ 和原型式继承一样</span></div><div class="line">person.constructor; <span class="comment">// function Object() &#123; [native code] &#125;</span></div><div class="line">anotherPerson.constructor; <span class="comment">// function Object() &#123; [native code] &#125;</span></div><div class="line"></div><div class="line">person.isPrototypeOf(anotherPerson); <span class="comment">// true</span></div><div class="line">anotherPerson.__proto__; <span class="comment">// Object &#123;name: "DaShuaiBi", friends: Array[2]&#125; 即person</span></div><div class="line">anotherPerson.__proto__ == person; <span class="comment">// ture</span></div><div class="line"></div><div class="line">anotherPerson.sayHi(); <span class="comment">// hi</span></div><div class="line"></div><div class="line"><span class="comment">// 注意！！</span></div><div class="line">person.sayHi(); <span class="comment">// 错误，person上并没有这个方法</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> yetAnotherPerson = createAnother(person);</div><div class="line"></div><div class="line"><span class="comment">// 注意！！！ 函数不能复用</span></div><div class="line">anotherPerson.sayHi == yetAnotherPerson.sayHi; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>优点：貌似和原型式继承差不多？</p>
<p>缺点：貌似和原型式继承差不多？</p>
<p>书中还写说寄生式继承为对象添加函数时不能复用，就像这里所示；原型式继承也有这个问题啊！！！但没有写。是不是因为一般使用原型式继承时只是简单的复制一下某个对象，而使用寄生式继承时除了复制一下某个对象外还稍微加点方法、属性什么的？？？</p>
<h4 id="hearts-hearts-hearts-rarr-rarr-寄生组合式继承-larr-larr-hearts-hearts-hearts"><a href="#hearts-hearts-hearts-rarr-rarr-寄生组合式继承-larr-larr-hearts-hearts-hearts" class="headerlink" title="&hearts;&hearts;&hearts; &rarr;&rarr; 寄生组合式继承 &larr;&larr; &hearts;&hearts;&hearts;"></a>&hearts;&hearts;&hearts; &rarr;&rarr; 寄生组合式继承 &larr;&larr; &hearts;&hearts;&hearts;</h4><p>这个的感觉就和<strong>使用动态原型模式创建对象</strong>的地位一样。</p>
<p><strong>寄生组合式继承是引用类型最理想的继承范式</strong></p>
<p>原型式继承+寄生式继承+借用构造函数继承+原型链继承 = 寄生组合式继承</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 原型式继承中的 函数 </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 寄生式继承中的方式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);</div><div class="line">    prototype.constructor = subType; <span class="comment">// 将子类的新的原型对象（通过父类的原型对象创建出来的，但并不是父类的原型对象）上的constructor重新链到子类构造函数上</span></div><div class="line">    subType.prototype = prototype; <span class="comment">// 将子类的原型对象设置为通过父类的原型对象创建出来的一个对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">    <span class="comment">// 借用构造函数继承 继承了 name、colors</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>, name);</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 与组合继承不同之处 通过这个方法实现 原型链继承</span></div><div class="line"><span class="comment">// 继承了sayName方法</span></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"DaShuaiBi"</span>, <span class="number">27</span>);</div><div class="line"></div><div class="line">SuperType.prototype.constructor; <span class="comment">// function SuperType(name) &#123;...&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 注意！！！ 之前的原型链继承、组合继承应该都是这样</span></div><div class="line"><span class="comment">// 与原型式继承和寄生式继承不同，就确定是person对象了，这里是new的新对象作为子类的原型对象。</span></div><div class="line">SubType.prototype; <span class="comment">// SuperType &#123;constructor:SubType(name, age)  ayAge:()  __proto__:Object&#125;</span></div><div class="line">SubType.prototype.constructor; <span class="comment">// function SubType(name, age) &#123;...&#125; 改回来了</span></div><div class="line">SubType.prototype == SuperType <span class="comment">// false</span></div><div class="line">SubType.prototype == SuperType.prototype <span class="comment">// false</span></div><div class="line">SuperType.isPrototypeOf(SubType.prototype) <span class="comment">// false</span></div><div class="line">SuperType.prototype.isPrototypeOf(SubType.prototype) <span class="comment">// true</span></div><div class="line"></div><div class="line">instance1.constructor; <span class="comment">// function SubType(name, age) &#123;...&#125; 改回来了</span></div><div class="line">instance1.__proto__; <span class="comment">// SuperType &#123;constructor:SubType(name, age)  ayAge:()  __proto__:Object&#125; 就是 SuperType.prototype ？？并不是</span></div><div class="line">instance1.__proto__ == SuperType.prototype; <span class="comment">// false</span></div><div class="line">SuperType.prototype.isPrototypeOf(instance1); <span class="comment">// true</span></div><div class="line"></div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">// red,blue,green,black</span></div><div class="line">instance1.sayName(); <span class="comment">// DaShuaiBi</span></div><div class="line">instance1.sayAge(); <span class="comment">// 27</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instacne2 = <span class="keyword">new</span> SubType(<span class="string">"HeiHeiHei"</span>, <span class="number">18</span>);</div><div class="line">alert(instacne2.colors); <span class="comment">// red,blue,green</span></div><div class="line">instacne2.sayName(); <span class="comment">// HeiHeiHei</span></div><div class="line">instacne2.sayAge(); <span class="comment">// 18</span></div></pre></td></tr></table></figure>
<p>优点：解决了<a href="#comInherit">组合继承的问题</a>，父类型构造函数只调用了一次。</p>
<p>17-03-08</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第6章-面向对象的程序设计&quot;&gt;&lt;a href=&quot;#第6章-面向对象的程序设计&quot; class=&quot;headerlink&quot; title=&quot;第6章 面向对象的程序设计&quot;&gt;&lt;/a&gt;第6章 面向对象的程序设计&lt;/h2&gt;&lt;p&gt;JS与传统的面向对象（Object-Oriented）的语言不同，它没有类的概念。&lt;/p&gt;
&lt;p&gt;可以把JS的对象看作是散列表：无非就是一组名值对，其中值可以是&lt;strong&gt;数据&lt;/strong&gt;或&lt;strong&gt;函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个对象&lt;/strong&gt;都是基于一个&lt;strong&gt;引用类型&lt;/strong&gt;创建的，这个引用类型可以是原生引用类型（Object、Array、Date、RegExp、Function、基本包装类型（Boolean、Number、String）、Math），也可以是用户自定义的类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>TensorFLow学习笔记（三）</title>
    <link href="http://yoursite.com/2017/03/04/TensorFLow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/04/TensorFLow学习笔记（三）/</id>
    <published>2017-03-04T12:35:50.000Z</published>
    <updated>2017-03-05T06:55:28.607Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档第三篇。<a href="https://www.tensorflow.org/get_started/mnist/pros" target="_blank" rel="external">Deep MNIST for Experts</a></p>
<p>这篇的前半部分和上一篇一样，用单一线性层构建了一个softmax回归模型，其预测准确度是92%。重点是后半部分，用多层卷积神经网络构建了一个softmax回归模型（或者说多层卷积神经网络+softmax回归），其准确度可以达到99.2%。</p>
<p>整个网络的结构是：第一层卷积 + 第一层池化 + 第二层卷积 + 第二层池化 + 全连接层 + Dropout层 + softmax回归。</p>
<a id="more"></a>
<h3 id="1-定义函数"><a href="#1-定义函数" class="headerlink" title="1. 定义函数"></a>1. 定义函数</h3><p>为了之后使用方便，定义了几个函数，方便地使用权值、偏差及方便地构建卷积层、池化层。</p>
<p>输入想要的权值和偏差的tensor的shape形状就能获得想要的权值和偏差。权值开始时是一些随机数，满足正态分布，有少量的标准差，为了防止梯度为0（to prevent 0 gradients）？？？至于偏差，之后要使用<a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks" target="_blank" rel="external">ReLU</a>激活函数，为了不产生“dead neurons”,初始值是很小的正数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight_variable</span><span class="params">(shape)</span>:</span></div><div class="line">  initial = tf.truncated_normal(shape, stddev=<span class="number">0.1</span>)</div><div class="line">  <span class="keyword">return</span> tf.Variable(initial)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bias_variable</span><span class="params">(shape)</span>:</span></div><div class="line">  initial = tf.constant(<span class="number">0.1</span>, shape=shape)</div><div class="line">  <span class="keyword">return</span> tf.Variable(initial)</div></pre></td></tr></table></figure></p>
<p>提供想要被卷积的数据及相应的权值就可以获得相应的卷积层；提供想要被池化的数据就可以获得相应的池化层。卷积时要知道一些超参数的设置，padding是多少？stride是多少？池化时要知道选择的是什么样的方法，平均池化？最大池化？在多大的区块池化？这里两层的卷积和池化都是选择的vanilla version。padding是SAME，stride是1，在2x2的区块上最大池化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// conv--Convolutional <span class="number">2</span>d代表什么？<span class="number">2</span>维？</div><div class="line">// tf.nn.conv2d strides这四个值怎样理解？stride取<span class="number">2</span>时怎么写？</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(x, W)</span>:</span></div><div class="line">  <span class="keyword">return</span> tf.nn.conv2d(x, W, strides=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</div><div class="line">// tf.nn.max_pool 这几个参数怎样理解？</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool_2x2</span><span class="params">(x)</span>:</span></div><div class="line">  <span class="keyword">return</span> tf.nn.max_pool(x, ksize=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">                        strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</div></pre></td></tr></table></figure>
<h3 id="2-第一层卷积、池化"><a href="#2-第一层卷积、池化" class="headerlink" title="2. 第一层卷积、池化"></a>2. 第一层卷积、池化</h3><p>输入到网络中的数据是28x28=784个数字，要对其进行卷积时先要把它再转变成28x28的格式。28宽，28高，1个通道（灰度图）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// <span class="number">-1</span>代表什么？</div><div class="line">x_image = tf.reshape(x, [<span class="number">-1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>])</div></pre></td></tr></table></figure>
<p>卷积神经网络的原理是什么？人看一张图片时，是根据一小块儿一小块儿的图组合起来看。卷积神经网络就模拟这个过程，扫描图片上一小块儿一小块儿的区域，然后对这些信息进行加工（不同的权值、不同的组合），抽象出一些新的信息来代表这张图。人们对这些信息到底是代表着图片中的什么东西并不知道（也并不关心）。反正可以使用这些信息很好的代表这张图片。但这些信息，量还有点大，经过池化，可以用更少的信息来表示。可以进行这样好几次卷积、池化，反正最后就是将图片抽象成了一些信息。对每张图片都进行这样同样的操作，就可以用得到的信息去做图片的分类、识别等工作了。这只是粗浅的解释，还有统计不变性、权值共享等概念。<a href="https://classroom.udacity.com/courses/ud730/lessons/6377263405/concepts/63741833610923#" target="_blank" rel="external">Udacity</a>上有很好的解释。</p>
<p>具体到这篇教程，第一层卷积时从每5x5的patch中提取、组合32个特征；池化时从每2x2的block中选取一个最大的做代表。第一层的卷积、池化过程大概如下图所示。</p>
<p><img src="..\TensorFLow学习笔记（三）\first-conv-pool.jpg" width="100%" height="100%"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 先定义权值，<span class="number">5</span> <span class="number">5</span> 是patch的大小，<span class="number">1</span>是输入的通道数，<span class="number">32</span>是输入的通道数</div><div class="line">W_conv1 = weight_variable([<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">32</span>])</div><div class="line">// 每个输出的通道加一个偏置</div><div class="line">b_conv1 = bias_variable([<span class="number">32</span>])</div><div class="line">// 卷积层 relu只是激活函数 h_conv1代表<span class="number">28</span>x28x32个数 根据上边的x_image，它的shape应该是[<span class="number">-1</span> <span class="number">28</span> <span class="number">28</span> <span class="number">32</span>]  </div><div class="line">h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)</div><div class="line">// 池化层 h_pool1的shape应该是[<span class="number">-1</span> <span class="number">14</span> <span class="number">14</span> <span class="number">32</span>]</div><div class="line">h_pool1 = max_pool_2x2(h_conv1)</div></pre></td></tr></table></figure>
<h3 id="3-第二层卷积、池化"><a href="#3-第二层卷积、池化" class="headerlink" title="3. 第二层卷积、池化"></a>3. 第二层卷积、池化</h3><p>第二层以第一层的输出h_pool1做输入，这一次卷积时从5x5的patch中提取、组合64个特征；池化时仍是从2x2的block中选取最大的做代表。其过程如下图所示。</p>
<p><img src="..\TensorFLow学习笔记（三）\second-conv-pool.jpg" width="100%" height="100%"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 权值</div><div class="line">W_conv2 = weight_variable([<span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>])</div><div class="line">// 偏置</div><div class="line">b_conv2 = bias_variable([<span class="number">64</span>])</div><div class="line">// 卷积</div><div class="line">h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)</div><div class="line">// 池化</div><div class="line">h_pool2 = max_pool_2x2(h_conv2)</div></pre></td></tr></table></figure>
<h3 id="4-全连接层"><a href="#4-全连接层" class="headerlink" title="4. 全连接层"></a>4. 全连接层</h3><p>全连接层以第二层的输出做输入，这一次是从7x7x64=3136个数中，提取1024个数来作为代表。</p>
<p><img src="..\TensorFLow学习笔记（三）\full-connect.jpg" width="30%" height="30%"></p>
<p>代码和之前的线性模型很像，外层再加上ReLU激活函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 权值的shape是[<span class="number">3136</span>, <span class="number">1024</span>] 即有<span class="number">3136</span>个输入 <span class="number">1024</span>个输出</div><div class="line">W_fc1 = weight_variable([<span class="number">7</span> * <span class="number">7</span> * <span class="number">64</span>, <span class="number">1024</span>])</div><div class="line">b_fc1 = bias_variable([<span class="number">1024</span>])</div><div class="line">// 这一步是将第二层卷积池化的输出<span class="number">7</span>x7x64展平为<span class="number">3136</span>个数</div><div class="line">h_pool2_flat = tf.reshape(h_pool2, [<span class="number">-1</span>, <span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>])</div><div class="line">// 与之前的线性模型类似，外边再加上ReLU激活函数</div><div class="line">h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)</div></pre></td></tr></table></figure></p>
<h3 id="5-Dropout层"><a href="#5-Dropout层" class="headerlink" title="5. Dropout层"></a>5. Dropout层</h3><p>Dropout的原理？它可以防止模型的过拟合（在训练集上表现很好，而再未知的数据集上表现不好）。大概就是在训练过程中，丢掉一些已经学习到的知识。这个教程中，先设置了一个placeholder，存放要保留的知识的百分比，这样在训练过程中可以保证一定的dropout，在测试过程中可以将其设置为100%来取消dropout。</p>
<p>这一层的输入是上一层全连接层的输出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">keep_prob = tf.placeholder(tf.float32)</div><div class="line">h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</div></pre></td></tr></table></figure></p>
<h3 id="6-softmax回归"><a href="#6-softmax回归" class="headerlink" title="6. softmax回归"></a>6. softmax回归</h3><p>根据Dropout层的输出，1024个数（特征），来产生10个类别的evidence，然后再应用softmax函数将evidence转化为相应的概率。教程中这一步只是简单的应用线性模型产生了10个evidence，而softmax的应用放到了计算损失——交叉熵中了。</p>
<p><img src="..\TensorFLow学习笔记（三）\final.jpg" width="30%" height="30%"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 权值的shape是[<span class="number">1024</span>, <span class="number">10</span>] 即<span class="number">1024</span>个输入 <span class="number">10</span>个输出</div><div class="line">W_fc2 = weight_variable([<span class="number">1024</span>, <span class="number">10</span>])</div><div class="line">b_fc2 = bias_variable([<span class="number">10</span>])</div><div class="line">// 线性模型</div><div class="line">y_conv = tf.matmul(h_fc1_drop, W_fc2) + b_fc2</div></pre></td></tr></table></figure>
<h3 id="7-训练、验证模型"><a href="#7-训练、验证模型" class="headerlink" title="7. 训练、验证模型"></a>7. 训练、验证模型</h3><p>剩下的工作和之前一篇的就差不多一样了。算出损失<strong>交叉熵</strong>，这次使用了<strong>AdamOptimizer优化器</strong>，使得损失减小。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 交叉熵的算法和上一篇不同</div><div class="line">cross_entropy = tf.reduce_mean(</div><div class="line">    tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y_conv))</div><div class="line">// 训练过程 沿着AdamOptimizer的方向 使得损失越来越小</div><div class="line">train_step = tf.train.AdamOptimizer(<span class="number">1e-4</span>).minimize(cross_entropy)</div></pre></td></tr></table></figure></p>
<p>模型预测的准确度的计算方法和上一篇一样。然后初始化变量。之后一共训练20000次，每次取50个样本数据进行训练，每次都丢弃一半已学到的知识；每训练一百次输出一次此时模型对于训练数据预测的准确度，此时不用dropout。最后在测试集上验证模型的预测准确率，不用dropout。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 预测准确度的计算</div><div class="line">correct_prediction = tf.equal(tf.argmax(y_conv, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</div><div class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</div><div class="line">// 设置会话Session  Session和InteractiveSession的区别？？？</div><div class="line">sess = tf.InteractiveSession()</div><div class="line">// 初始化变量</div><div class="line">sess.run(tf.global_variables_initializer())</div><div class="line">// 训练模型</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20000</span>):</div><div class="line">    batch = mnist.train.next_batch(<span class="number">50</span>)</div><div class="line">    // 每一百次 输出一次此时模型对于训练集的预测准确率</div><div class="line">    <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</div><div class="line">        train_accuracy = accuracy.eval(</div><div class="line">            feed_dict=&#123;x: batch[<span class="number">0</span>], y_: batch[<span class="number">1</span>], keep_prob: <span class="number">1.0</span>&#125;)</div><div class="line">        print(<span class="string">"step %d, train accuracy %g"</span> % (i, train_accuracy))</div><div class="line">    train_step.run(feed_dict=&#123;x: batch[<span class="number">0</span>], y_: batch[<span class="number">1</span>], keep_prob: <span class="number">0.5</span>&#125;)</div><div class="line">// 最后输出模型在测试集上预测的准确率</div><div class="line">print(<span class="string">"test accuracy %g"</span> % accuracy.eval(</div><div class="line">    feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels, keep_prob: <span class="number">1.0</span>&#125;))</div></pre></td></tr></table></figure></p>
<h3 id="8-底层知识"><a href="#8-底层知识" class="headerlink" title="8. 底层知识"></a>8. 底层知识</h3><p>这一篇中，<strong>卷积神经网络</strong>、<strong>Dropout</strong>、<strong>AdamOptimizer优化函数</strong>的具体原理还没有完全搞明白。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方文档第三篇。&lt;a href=&quot;https://www.tensorflow.org/get_started/mnist/pros&quot;&gt;Deep MNIST for Experts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇的前半部分和上一篇一样，用单一线性层构建了一个softmax回归模型，其预测准确度是92%。重点是后半部分，用多层卷积神经网络构建了一个softmax回归模型（或者说多层卷积神经网络+softmax回归），其准确度可以达到99.2%。&lt;/p&gt;
&lt;p&gt;整个网络的结构是：第一层卷积 + 第一层池化 + 第二层卷积 + 第二层池化 + 全连接层 + Dropout层 + softmax回归。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tensorflow学习" scheme="http://yoursite.com/tags/tensorflow%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TensorFLow学习笔记（二）</title>
    <link href="http://yoursite.com/2017/02/28/TensorFLow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/28/TensorFLow学习笔记（二）/</id>
    <published>2017-02-28T09:09:08.000Z</published>
    <updated>2017-03-04T12:10:57.314Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档第二篇。<a href="https://www.tensorflow.org/get_started/mnist/beginners" target="_blank" rel="external">MNIST for ML Beginners</a><br>先介绍MNIST，还有softmax regression（softmax回归），然后利用tensorflow构建一个模型。</p>
<h3 id="1-MNIST"><a href="#1-MNIST" class="headerlink" title="1. MNIST"></a>1. MNIST</h3><p>MNIST对于机器学习就相当于Hello World对于一门编程语言。</p>
<p>MNIST是一个简单的计算机视觉数据集。有好多手写数字图片，并有相应的<strong>label标记</strong>，说明这张图片是数字几（0~9）。</p>
<p>一个简单的任务就是，训练一个模型，然后给它一张图片，它会预测出这张图片是数字几。（是一个分类Classification问题，多分类）</p>
<a id="more"></a>
<p>MNIST是放在<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="external">Yann LeCun’s website</a> (CNN的提出者)，Google提供代码可以将数据下载下来，并已经把数据分为了<strong>training data</strong>训练数据、<strong>validation data</strong>验证数据、<strong>test data</strong>测试数据。训练数据是训练模型用，验证数据也是在训练模型的过程中用（比如防止模型对于训练数据的过拟合，模型对于训练数据的表现在越来越好，而对于验证数据的表现并没有越来越好），测试数据是为了验证模型的泛化能力，在训练过程中是不能被模型“看到的“。这些数据是很多的。</p>
<p>具体到计算机上的数据表示。图片本身是28像素 X 28像素的，用一个28 X 28的数字矩阵表示。图片上越黑，对应数字矩阵的数字越大（图片都是灰度的）。然后将这个数字矩阵“压扁”成为一个28 * 28 = 784维的向量。用x表示一张图片，那么 <del>x = [0.1, 0.2, 0., 0.5……]</del> x中的值应该是0~255中的一个，数字越大，像素点越黑，一共784个值。对于这张图片的标签，用y表示，它是一个“<strong>one-hot vector</strong>”，假设这张图片是数字3，那y就是[0, 0, 1, 0, 0, 0, 0, 0, 0]。</p>
<h3 id="2-Softmax-Regressions"><a href="#2-Softmax-Regressions" class="headerlink" title="2. Softmax Regressions"></a>2. Softmax Regressions</h3><p>Softmax回归。机器学习的问题分为两种，一种分类Classification问题，一种回归Regression问题。分类问题的输出是离散值，回归问题的输出是连续值。虽然Softmax Regressions有个回归，但它是解决分类问题的，而且是多分类问题。对应的，二分类问题有<strong>Logistic Regression</strong>方法。</p>
<p>给定一个输入，比如一张动物图片，经过模型的推理，它告诉我们这张图片有20%的概率是猪，20%的概率是猫，60%的概率是马。Softmax回归就是干这件事儿的。它先算出根据图片中的哪些东西推断出这张图片是猪、是猫、是马（三个类别的<strong>evidence</strong>）。比如，图片中有个尖尖的耳朵，那 evidence(猫) 和 evidence(马)就比evidence(猪)要大，但图片中还有长腿，那evidence(马)就比evidence(猫)和evidence(猪)要大许多了。就这样找好多特征，算出每个特征对应的每个类别的evidence，最后总和起来就得到了这张图片可能是某个类别的evidence。（对于每个类别再加上一定的偏差。）之后softmax回归可以把这些evidence“映射”到每个类别的概率上。</p>
<p>具体到这个例子。图片有10个类别。每个类别i的evidence为：$\text{evidence}_i = \sum_j W x_j + b_i$ </p>
<p>（其中W为 $W_{i,~j}$）。i 是0-9；j 是0-783（或者是1-784）共784个；W一共有10 X 784个，每个W代表每一个像素是某个类别的权重是多少；b是每个类别的偏置。<br>softmax回归的功能就是将这些evidence（共10个）映射到10个概率上。即：$y = \text{softmax}(\text{evidence})$ 这里的y其实是一个数组，其中的每个值代表图片是某个类别的概率。</p>
<h3 id="3-设计模型、训练模型、评估模型"><a href="#3-设计模型、训练模型、评估模型" class="headerlink" title="3. 设计模型、训练模型、评估模型"></a>3. 设计模型、训练模型、评估模型</h3><p>接下来在代码中实现这个softmax回归。</p>
<p>首先设置输入。图像数据x，及其对应的标签y_。使用placeholder。<br>这里的[None, 784]是x这个tensor的形状shape。None表示任意数字。这个tensor是一个2-D（2维）的tensor，秩也为2。但要注意，其中的数据是784维的，即784个数字。2-D的tensor可以当成一个矩阵来看待。每一行代表一个数据，每一行中的每一个数代表一个数据中的一个维度。MNIST中一共有55000个图片，要让计算机一下处理这么多数据很慢。所以可以批量次的“喂给”计算机一部分数据。这里的None就是代表，等会儿“送”None个数据进来。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line">x = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">784</span>])</div><div class="line">y_ = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">10</span>])</div></pre></td></tr></table></figure></p>
<p>之后搭建softmax模型。根据上边介绍的公式，需要参数W和b。<br>参数在训练过程中是不停的变的，用tensorflow中的变量Variable。<br>W的shape是[784, 10]，是2-D的tensor，秩为2。相当于一个矩阵。其实它可以是784 X 10也可以是10 X 784的。前者每一行代表图中一个像素是某个类的权重，一行10个数，对应10个类别；后者则是每一列代表图中一个像素是某个类的权重，一列10个数，对应10个类别。<br>b的shape是[10]，是1-D的tensor，秩为1。相当于一个向量，共10个数，即每个类别的偏置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">W = tf.Variable(tf.zeros([<span class="number">784</span>, <span class="number">10</span>]))</div><div class="line">b = tf.Variable(tf.zeros([<span class="number">10</span>]))</div></pre></td></tr></table></figure></p>
<p>之后就是利用数据x，参数W和b和及softmax回归产生每个类别的概率了（tensorflow的厉害之处……）。<br>matmul应该是matrix multiplication的简写，矩阵乘法，x X W 是 None x 784 X 784 x 10，得到的是None X 10的矩阵，再加上b（1 X 10），得到的就是None个图片数据是某个类别的evidence。<br>tensorflow用tf.nn.softmax就可以把evidence映射到每个类别的概率上，而且这里的y的shape是[None, 10]，即None X 10的矩阵，表示None个数据是每个类别的概率。（等等……，现在这个y中存的是概率呢还是进一步被tensorflow转换成“one-hot”数据了呢（这个应该很简单，每一行找出最大值，设为1，其余位置设为0。）？从后边的代码看，应该是前者。）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">y = tf.nn.softmax(tf.matmul(x, W) + b)</div></pre></td></tr></table></figure></p>
<p>现在我们有了预测值，和<a href="http://htxf.github.io/2017/02/23/TensorFlow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">上一篇</a>一样，我们需要算出当前预测的loss（cost）。上一篇中用的是预测值和实际值的差值的平方和。这一篇利用<strong>cross-entropy 交叉熵</strong>。公式是$H_{y’}(y) = -\sum_i y’_i \log(y_i)$ y 是预测值，y’ 是实际值，i 代表每个类别。根据公式写代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cross_entropy = tf.reduce_mean(-tf.reduce_sum(y_ * log(y)), reduction_indices=[<span class="number">1</span>])</div></pre></td></tr></table></figure></p>
<p>代码中（y_ * log(y)）的shape，是[None, 10]，reduction_indices=[1]表示做reduce_sum加法时作用在第2维的tensor上。所以（-tf.reduce_sum(y_ * log(y)), reduction_indices=[1]）的shape就成了[None, 1]。最后算出这None个交叉熵的平均值，即用tf.reduce_mean。我们的目的还是为了把模型预测的结果的损失降到最小。即，使得cross_entropy最小。这一篇仍然使用<strong>梯度下降</strong>优化器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>).minimize(cross_entropy)</div></pre></td></tr></table></figure></p>
<p>最后就是把数据“喂给”建好的模型，不断的训练模型，训练出使得损失最小的W和b。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 初始化参数变量</div><div class="line">init = tf.global_variables_initializer()</div><div class="line">sess = tf.InteractiveSession()</div><div class="line">sess.run(init)</div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</div><div class="line">    // 每次随机取<span class="number">100</span>个数据来feed给模型进行训练</div><div class="line">    // <span class="number">100</span>就代替了上边的<span class="keyword">None</span></div><div class="line">    batch_xs, batch_ys = mnist.train.next_batch(<span class="number">100</span>)</div><div class="line">    sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;)</div></pre></td></tr></table></figure></p>
<p>最后的最后，对模型进行评估。这里只是算了下模型在测试数据上预测的准确性。<br>tf.argmax能返回一个tensor某个维度上最大值的位置。y_ 是实际数据，由0、1组成，而且其shape是[None, 10]，第2维上，最大值是1，它的位置（0~9）就刚好是该数据的类别。y 是预测数据，由0到1的小数组成，其shape也是[None, 10]，第2维上，最大值的索引也就代表了该数据被预测为了该索引值。（有个问题！！！要是预测到某两个类别的可能性一样大呢？又刚好是最大的？）tf.equal返回一个布尔值的列表，比较的两者相同就为true。<br>tf.argmax(y, 1)和tf.argmax(y_, 1)的shape是[None, 1]，correct_prediction的shape是[None, 1]，或者是[None]？<br>tf.cast能将布尔值true、false转化为1、0。<br>然后对None个0、1求平均reduce_mean，就刚好是预测的准确率。如：[true false false true]，预测的准确率是50%，对[1 0 0 1]求平均刚好时0.5。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 预测的正确与否</div><div class="line">correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</div><div class="line">// 预测的准确性</div><div class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</div></pre></td></tr></table></figure></p>
<p>给这块儿的y、y_中的x“喂”测试集上的数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;))</div></pre></td></tr></table></figure></p>
<h3 id="4-tensorflow中的tensor"><a href="#4-tensorflow中的tensor" class="headerlink" title="4. tensorflow中的tensor"></a>4. tensorflow中的tensor</h3><p>TensorFlow中数据都存在tensor中。上一篇文章没有搞明白tensor的shape、rank。后来又查资料、想了很多。做如下的测试。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">x0 = tf.Variable(tf.random_uniform([]))</div><div class="line">x1 = tf.Variable(tf.random_uniform([<span class="number">3</span>]))</div><div class="line">x2 = tf.Variable(tf.random_uniform([<span class="number">2</span>, <span class="number">3</span>]))</div><div class="line">x3 = tf.Variable(tf.random_uniform([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</div><div class="line">x4 = tf.Variable(tf.ones([<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</div><div class="line"></div><div class="line">init = tf.global_variables_initializer()</div><div class="line"></div><div class="line">sess = tf.Session()</div><div class="line"></div><div class="line">sess.run(init)</div><div class="line"></div><div class="line">print(sess.run(x0))</div><div class="line">print(sess.run(x1))</div><div class="line">print(sess.run(x2))</div><div class="line">print(sess.run(x3))</div><div class="line">print(sess.run(x4))</div><div class="line"></div><div class="line">print(sess.run(x1[<span class="number">1</span>]))</div><div class="line">print(sess.run(x2[<span class="number">1</span>, <span class="number">2</span>]))</div><div class="line">print(sess.run(x3[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]))</div><div class="line">print(sess.run(x4[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]))</div></pre></td></tr></table></figure></p>
<p>对得到的数据的rank、shape、dimension做如下整理。</p>
<p><img src="..\TensorFLow学习笔记（二）\tensor.jpg" width="100%" height="100%"></p>
<h3 id="5-底层知识"><a href="#5-底层知识" class="headerlink" title="5. 底层知识"></a>5. 底层知识</h3><p>其实本篇所训练出的模型，核心在于<strong>Softmax Regression</strong>、<strong>cross-entropy</strong>以及<strong>gradient decent</strong>。现在只是简单的知道了它们是干什么的。虽然也看过它们的原理、公式的推导过程，但都没有记住……哦多给？？？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方文档第二篇。&lt;a href=&quot;https://www.tensorflow.org/get_started/mnist/beginners&quot;&gt;MNIST for ML Beginners&lt;/a&gt;&lt;br&gt;先介绍MNIST，还有softmax regression（softmax回归），然后利用tensorflow构建一个模型。&lt;/p&gt;
&lt;h3 id=&quot;1-MNIST&quot;&gt;&lt;a href=&quot;#1-MNIST&quot; class=&quot;headerlink&quot; title=&quot;1. MNIST&quot;&gt;&lt;/a&gt;1. MNIST&lt;/h3&gt;&lt;p&gt;MNIST对于机器学习就相当于Hello World对于一门编程语言。&lt;/p&gt;
&lt;p&gt;MNIST是一个简单的计算机视觉数据集。有好多手写数字图片，并有相应的&lt;strong&gt;label标记&lt;/strong&gt;，说明这张图片是数字几（0~9）。&lt;/p&gt;
&lt;p&gt;一个简单的任务就是，训练一个模型，然后给它一张图片，它会预测出这张图片是数字几。（是一个分类Classification问题，多分类）&lt;/p&gt;
    
    </summary>
    
    
      <category term="tensorflow学习" scheme="http://yoursite.com/tags/tensorflow%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JS高程（五）</title>
    <link href="http://yoursite.com/2017/02/27/JS%E9%AB%98%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/27/JS高程（五）/</id>
    <published>2017-02-27T06:00:42.000Z</published>
    <updated>2017-03-08T12:18:06.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第5章-引用类型（二）（Function类型、基本包装类型、单体内置对象）"><a href="#第5章-引用类型（二）（Function类型、基本包装类型、单体内置对象）" class="headerlink" title="第5章 引用类型（二）（Function类型、基本包装类型、单体内置对象）"></a>第5章 引用类型（二）（Function类型、基本包装类型、单体内置对象）</h2><h3 id="5-5-Function类型"><a href="#5-5-Function类型" class="headerlink" title="5.5 Function类型"></a>5.5 Function类型</h3><blockquote>
<p>函数是对象。<br>函数名实际上是一个指向对象的指针。</p>
</blockquote>
<p><strong>函数的定义</strong></p>
<ul>
<li>法一：<strong>函数声明</strong></li>
<li>法二：<strong>函数表达式</strong></li>
<li>法三：使用Function构造函数</li>
</ul>
<a id="more"></a>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数声明语法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Hi"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 函数表达式 没有函数名，通过变量sayHi即可引用；函数末尾有分号，是"var sayHi = XXX;"中的分号</span></div><div class="line"><span class="comment">// 要执行函数时，应是sayHi()而不是sayHi</span></div><div class="line"><span class="keyword">var</span> sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Hi"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 使用Function构造函数 不要用</span></div><div class="line"><span class="keyword">var</span> sayHi = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"name"</span>, <span class="string">"alert("</span>Hi<span class="string">" + name)"</span>);</div></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>法一和法二，函数声明和函数表达式的异同。</p>
<ul>
<li>同：两者的sayHi都是指针，指向函数对象；执行函数时都是sayHi()，要加圆括号。</li>
<li><p>异：解析器会率先读取函数声明，并在其执行任何代码之前可用。（<strong>函数声明提升</strong>function declaration hoisting）;函数表达式没有这个待遇。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数声明提升</span></div><div class="line">sayHi(<span class="string">"Dashuaibi"</span>); <span class="comment">// 没问题</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Hi "</span> + name + <span class="string">"!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 至于函数表达式</span></div><div class="line">sayHi2(<span class="string">"Dashuaibi"</span>); <span class="comment">// 发生错误！！！</span></div><div class="line"><span class="keyword">var</span> sayHi2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Hi "</span> + name + <span class="string">"!"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>函数没有重载</strong></p>
<p>第3章也曾经讲过。其他语言中的函数重载是通过相同的函数名而不同的参数形成的，但在JS中，定义函数时并不真正的关心形参，它只是个便利，调用函数时想传递多少参数都可以，在函数内部通过<strong>arguments对象</strong>来访问具体传递的参数。所以真正的函数重载在JS中不可能实现。</p>
<p>另一方面，函数是对象，函数名是指向栈内存对象的一个指针。如果连续定义了两个同名的不同函数体的函数A和函数B，相当于函数名从开始的指向栈内存函数A对象，变成了后来函数名指向栈内存函数B对象了。</p>
<p><strong>函数作为值</strong></p>
<ul>
<li><p>情形1：函数作为参数。注意此时是传递someFunction，而不是传递someFunction()。前一篇<strong>数组排序问题</strong>时就用到了compare函数做参数。</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">funAsArg1</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    alert(<span class="string">"Let's party, "</span> + name + <span class="string">"!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 函数2</span></div><div class="line"><span class="keyword">var</span> funAsArg2 = <span class="function"><span class="keyword">function</span> (<span class="params">curPro</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> end = <span class="number">100</span>; </div><div class="line">    alert(<span class="string">"还有百分之"</span> + (end - cuPro) + <span class="string">"了~"</span>);</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 用函数做参数的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFun</span> (<span class="params">someFun, someArg</span>) </span>&#123;</div><div class="line">    someFun(someArg);</div><div class="line">&#125; </div><div class="line"><span class="comment">// 调用函数 函数做参数 不要圆括号</span></div><div class="line">callSomeFun(funAsArg1, <span class="string">"DaShuaiBi"</span>);</div><div class="line">callSomeFun(funAsArg2, <span class="number">50</span>);</div><div class="line"><span class="comment">// 这次会弹出 Let's party, undefined! 但是callSomeFun中会出现错误，说someFun不是一个Function。总之和预想的不同</span></div><div class="line">callSomeFun(funAsArg1(), <span class="string">"DaShuaiBi"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>情形2：函数作为返回值。书中的例子还是比较好的。有个数据是对象数组，每个对象都有name和age，这样要对这个数组排序的话，可以按照name排也可以按照age排。<br>如果还是和上一次一样，compare函数的参数是两个值，之前数组中是两个数字，而现在则是两个对象，<del>就不存在顺序了</del> ，而应该是对象的属性的值才对。对象也可以存在顺序，但是是根据对象属性的值排序的</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 降序</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareDown</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 升序</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareUp</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 数值数组</span></div><div class="line"><span class="keyword">var</span> numArr = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>];</div><div class="line">numArr.sort(compareDown); </div><div class="line">numArr; <span class="comment">// numArr 变成 5 4 3 2 1</span></div><div class="line">numArr.sort(compareUp); </div><div class="line">numArr; <span class="comment">// numArr变成 1 2 3 4 5</span></div><div class="line"><span class="comment">// 对象数组</span></div><div class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span> : <span class="number">29</span>&#125;];</div><div class="line">data.sort(compareDown); </div><div class="line">data; <span class="comment">// data 不变</span></div><div class="line">data.sort(compareUp);</div><div class="line">data; <span class="comment">// data 不变</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 函数作为返回值，多传递一个参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareObjectArray</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">    <span class="comment">// 这个函数是返回一个比较函数，比较函数可以用到对象的属性名了</span></div><div class="line">    <span class="comment">// 这里compare函数的两个参数就成了对象，而不是values了。虽然只是个形参。</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">object1, object2</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> value1 = object1[propertyName]; <span class="comment">// 可以用.方法吗？ 不可以。</span></div><div class="line">        <span class="keyword">var</span> value2 = object2[propertyName]; <span class="comment">// 可以用.方法吗？ 不可以</span></div><div class="line">        <span class="comment">// 升序的</span></div><div class="line">        <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vale1 &lt; value2) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            retrun <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">data.sort(compareObjectArray(<span class="string">"name"</span>)); <span class="comment">// 为什么传"name"，而不是name呢？函数中用的是[]法，不是.法访问属性值。而且name是个变量名，并没有在哪儿定义。</span></div><div class="line">data[<span class="number">0</span>]; <span class="comment">// Object &#123;name: "Nicholas", age: 29&#125;</span></div><div class="line">data.sort(compareObjectArray(<span class="string">"age"</span>));</div><div class="line">data[<span class="number">0</span>]; <span class="comment">// Object &#123;name: "Zachary", age: 28&#125;</span></div></pre></td></tr></table></figure>
<p>还有疑问说对于对象数组的排序多了一个参数（属性名），那在写compare比较函数时直接传递不行吗？可是貌似就不行。。compare只有两个参数，就是要<del>比较的东西</del> 应该是要排序的“对象”吧。那在写sort排序函数时传递行吗？即使可以传，它再怎样传递给compare呢？所以还是上边的方法可以解决问题。将compare函数作为返回值，传递给sort函数，而所需的属性名参数通过外层函数传递给compare函数（不算是传递给compare函数，应该说是compare可以使用该属性名参数）。</p>
</li>
</ul>
<p><strong>函数的属性和方法</strong> ！@#%&amp;……&amp;%#@！</p>
<p> 函数是对象，是对象就是有属性和方法。这些属性和方法没有闹明白……不知在何时用？？？也挺绕的……</p>
<ul>
<li>函数内部的对象arguments的属性<strong>callee</strong><blockquote>
<p>callee是一个指针，指向拥有这个arguments对象的函数。</p>
</blockquote>
</li>
<li><p>函数内部的对象<strong>this</strong></p>
<blockquote>
<p>this引用的是函数据以执行的<strong>环境对象</strong>，或者说是this值。</p>
</blockquote>
<p> 那什么是环境对象呢？在第4章 <em>执行环境及作用域</em> 一节中，有<strong>执行环境</strong>、<strong>变量对象</strong>、<strong>活动对象</strong>、<strong>作用域链</strong>。 </p>
</li>
<li>函数对象的属性<strong>caller</strong><blockquote>
<p>caller中保存着调用当前函数的函数的引用。</p>
</blockquote>
</li>
<li><strong>length</strong>属性<blockquote>
<p>length属性表示函数希望接收的命名参数（形参？）的个数。</p>
</blockquote>
</li>
<li><strong>prototype</strong>属性<blockquote>
<p>prototype中保存了引用类型的所有实例方法。</p>
</blockquote>
</li>
<li><span id="apply"><strong>apply()</strong>方法和<strong>call()</strong>方法</span><blockquote>
<p>两者都是在特殊作用域中调用函数，等于设置函数体的this（对象）值。<br>可以扩充函数赖以运行的作用域。</p>
</blockquote>
</li>
</ul>
<h3 id="5-6-基本包装类型"><a href="#5-6-基本包装类型" class="headerlink" title="5.6 基本包装类型"></a>5.6 基本包装类型</h3><p>基本包装类型有三个：Boolean、Number和String。</p>
<p>基本包装类型本质上是对象。但我们知道JS有五种<strong>基本数据类型</strong>，Undefined、Null、Boolean、Number和String，一种<strong>复杂数据类型</strong>，Object。所以Boolean、Number和String三者比较特殊，它们既有基本类型的特殊行为，也有引用类型的特点，即有属性、有方法。</p>
<p><strong>基本类型值</strong>不是对象，它们不应该有方法，但它们真的有……比如下边的substring()方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="string">"HeiHei, Jian Gui le."</span>;</div><div class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">3</span>);</div><div class="line">s2; <span class="comment">//</span></div></pre></td></tr></table></figure></p>
<p>这是因为：</p>
<blockquote>
<p>每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而能够调用一些方法来操作这些数据。</p>
</blockquote>
<p>那<strong>基本包装类型</strong>和<strong>引用类型</strong>的<strong>区别</strong>是什么？区别在于<strong>对象的生存期</strong>。</p>
<blockquote>
<p>引用类型的实例只要执行操作还没离开作用域，它就一直活在内存中。<br>自动创建的基本包装类型的对象，只存在于一行代码的执行瞬间。</p>
</blockquote>
<p>既然Boolean、Number和String是基本包装类型，是特殊的引用类型，就可以<strong>显式地</strong>用new来创建对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">250</span>;</div><div class="line">num.name = <span class="string">"sb"</span>;</div><div class="line">alert(num.name); <span class="comment">// undefined 为什么呢？基本包装类型的对象只存在于一行代码的执行瞬间。</span></div><div class="line"><span class="comment">// 显式地创建基本包装类型 这样与上边的情况就不同了。</span></div><div class="line"><span class="keyword">var</span> numObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">250</span>);</div><div class="line">numObj; <span class="comment">// Number &#123;[[PrimitiveValue]]: 250&#125;</span></div><div class="line">alert(numObj); <span class="comment">// 250</span></div><div class="line"><span class="comment">// 此时numObj还可以添加属性、方法</span></div><div class="line">numObj.name = <span class="string">"SB"</span>;</div><div class="line">numObj; <span class="comment">// Number &#123;name: "SB", [[PrimitiveValue]]: 250&#125;</span></div><div class="line">alert(numObj); <span class="comment">// 但这块儿还是 250</span></div><div class="line"><span class="comment">// 如果是</span></div><div class="line"><span class="keyword">var</span> ob = &#123;<span class="attr">name</span>: <span class="string">"SB"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</div><div class="line">alert(ob); <span class="comment">// [object Object]</span></div></pre></td></tr></table></figure></p>
<h4 id="5-6-1-Boolean类型"><a href="#5-6-1-Boolean类型" class="headerlink" title="5.6.1 Boolean类型"></a>5.6.1 Boolean类型</h4><blockquote>
<p>永远不要使用Boolean对象！！！</p>
</blockquote>
<p>比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line">alert(falseObject); <span class="comment">// false 与预想相同</span></div><div class="line"><span class="keyword">var</span> result1 = falseObject &amp;&amp; <span class="literal">true</span>;</div><div class="line">result1; <span class="comment">// true 与预想不同 falseObject &amp;&amp; true做布尔运算，实际上是一个对象和true做&amp;&amp;，对象会被转化为true，本质上是true&amp;&amp;true。</span></div><div class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> result2 = <span class="literal">false</span> &amp;&amp; <span class="literal">true</span>;</div><div class="line">result2; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h4 id="5-6-2-Number类型"><a href="#5-6-2-Number类型" class="headerlink" title="5.6.2 Number类型"></a>5.6.2 Number类型</h4><p><strong>toFixed()</strong>，参数是指定的小数位，四舍五入<br><strong>toExponential()</strong>，参数也是指定的小数位，用科学计数法（e表示法）做返回值<br><strong>toPrecision()</strong>，以上两者的综合，自动选择合适的表达，不一定是四舍五入了。传递的参数是要保留几位数字，不是小数。</p>
<blockquote>
<p>不建议直接实例化Number类型！！！</p>
</blockquote>
<p>原因同Boolean包装类型。</p>
<h4 id="5-6-3-String类型"><a href="#5-6-3-String类型" class="headerlink" title="5.6.3 String类型"></a>5.6.3 String类型</h4><ul>
<li><p><strong>length属性</strong></p>
<blockquote>
<p>返回字符串包含多少个字符。<br>占双字节的字符，每个字符也只算一个字符。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>charAt()方法</strong>、<strong>charCodeAt()方法</strong>、<strong>fromeCharCode()方法</strong><br>前两个方法接收基于0的字符位置，最后一个方法接收一个或多个字符编码。<br>第一个方法返回该位置的字符，第二个方法返回该位置的字符相应的字符编码，第三个方法返回字符编码相应的字符。</p>
</li>
<li><p><strong>concat()方法</strong>、<strong>slice()方法</strong>、<strong>substr()方法</strong>、<strong>substring()方法</strong><br>第一个方法用来拼接字符串。在Array类型中也有。不常用，都用+。后三个方法用来切割字符串。slice()在Array类型中也有。<br>但是很麻烦……！@#%&amp;……&amp;%#@！</p>
</li>
<li><p><strong>indexOf()方法</strong>、<strong>lastIndexOf()方法</strong><br>和Array类型中的一样。接收一个给定的子字符串，返回相应位置。<br>书中有个例子，在一个句子中<strong>找到所有匹配的子字符串的位置</strong>。自己写一下，现在，就现在！！！</p>
</li>
<li><p><strong>trim()方法</strong></p>
<blockquote>
<p>创建一个字符串副本，删除前置及后缀的所有空格，然后返回结果。</p>
</blockquote>
</li>
<li><p><strong>toLowerCase()方法</strong>、<strong>toUpperCase()方法</strong>、<strong>toLocaleLowerCase()方法</strong>、<strong>toLocaleUpperCase()方法</strong><br> 比较简单。还要看一些<strong>字符编码</strong>的知识。这一下小节中length、charCodeAt()、还有这里都用到了。</p>
</li>
<li><p><strong>localeCompare()方法</strong><br>比较两个字符串的排序情况。xxx.localeCompare(XXX);<br>这个和之前数组Array的排序sort，用的compare比较函数很类似。value1在value2之前，返回-1；value1在value2之后，返回1；两者一样，返回0。xxx相当于value1，XXX相当于value2。</p>
</li>
<li><p><strong>HTML()方法</strong></p>
<blockquote>
<p>尽量不要使用</p>
</blockquote>
</li>
<li><p>字符串的模式匹配方法 正则表达式 ！@#%&amp;……&amp;%#@！</p>
</li>
</ul>
<h4 id="5-7-单体内置对象"><a href="#5-7-单体内置对象" class="headerlink" title="5.7 单体内置对象"></a>5.7 单体内置对象</h4><p>内置对象：</p>
<blockquote>
<p>由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。<br>不必显式地实例化内置对象，因为已经实例化了。如Object、Array、String。 </p>
</blockquote>
<p>单体内置对象：单体？？？</p>
<ul>
<li><p><strong>Global对象</strong></p>
<blockquote>
<p>这个对象不存在……WTF…；<br>不属于任何其他对象的属性和方法，最终属于Global对象；<br>在全局作用域定义的属性和函数，都属于Global对象。diao的1比</p>
</blockquote>
<ul>
<li>encodeURI()和encodeURIComponent()、decodeURI()和decodeURIComponent()<br>处理URI(Uniform Resource Identifiers)通用（统一）资源标识符的。<br>接收URI字符串做参数。<br><strong>有效的URI中不能包含空格！！！</strong><br>encodeURI能将空格编码成%20，（UTF-8）。<br>encodeURIComponent还能对任何<strong>非标准字符</strong>（如 : / ? #）进行编码，而encodeURI不行。</li>
<li><p>eval()方法 python中也有eval()函数。但具体的用法不清楚……<br>JS中的eval()接收一个参数，要执行的JS字符串。但有什么用呢？？？</p>
</li>
<li><p>Global对象的属性<br>好多。</p>
</li>
<li>window对象<br>不知怎样访问Global对象，但在Web浏览器中，会把Global对象作为window对象的一部分加以实现。所以是Global的都成了window的了。</li>
</ul>
</li>
<li><p><strong>Math对象</strong></p>
<ul>
<li><p>Math对象的属性<br>如：Math.E、Math.PI（π）……</p>
</li>
<li><p>min()和max()函数<br>接收多个数值做参数。但是不能接收一个数组！！!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>);</div><div class="line">alert(max); <span class="comment">// 8</span></div><div class="line"><span class="keyword">var</span> values = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>];</div><div class="line"><span class="keyword">var</span> max2 = <span class="built_in">Math</span>.max(values);</div><div class="line">alert(max2); <span class="comment">// NaN !!!</span></div></pre></td></tr></table></figure>
<p>书中有一个技巧。应用了 <em>函数的属性和方法</em> 中的<a href="#apply">apply()</a>方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>];</div><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values); apply的第一个参数设置了<span class="keyword">this</span>值为<span class="built_in">Math</span>，第二个参数可以是数组。？？？还是不懂。</div><div class="line">alert(max); <span class="comment">// 8</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>ceil()、floor()、round()方法<br> 分别是向上舍入、向下舍入、四舍五入</p>
</li>
<li><p>random()方法</p>
<blockquote>
<p>Math.random()方法返回<strong>大于等于0小于1</strong>的一个随机数。</p>
</blockquote>
<p> 书中有一个公式利用Math.random()<strong>从某个整数范围内</strong>随机选择一个值。是什么？？？自己写！！！就现在！！！<br> 还有一中情况，告诉你最小值和最大值，怎样随机取其范围中的某个整数值？？？</p>
</li>
</ul>
<h4 id="上边两个问题的代码"><a href="#上边两个问题的代码" class="headerlink" title="!!上边两个问题的代码!!"></a>!!上边两个问题的代码!!</h4><h5 id="1-找到所有匹配的子字符串。"><a href="#1-找到所有匹配的子字符串。" class="headerlink" title="1. 找到所有匹配的子字符串。"></a>1. 找到所有匹配的子字符串。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hw = <span class="string">"A \"Hello, World!\" program is a computer program that outputs or displays \"Hello, World!\" to the user. "</span>;</div><div class="line"><span class="comment">// 错误！！！ 死循环了，浏览器崩溃了！？</span></div><div class="line"><span class="keyword">var</span> position = [];</div><div class="line"><span class="keyword">var</span> pos = hw.indexOf(<span class="string">"e"</span>);</div><div class="line">position.push(pos);</div><div class="line"><span class="keyword">for</span> (pos = pos + <span class="number">1</span>; pos &gt; <span class="number">-1</span>; pos++) &#123;</div><div class="line">    pos = hw.indexOf(<span class="string">"e"</span>, pos);</div><div class="line">    position.push(pos);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 改成 pos++ 和indexOf中换了下 就对了？？ 感觉一样啊</span></div><div class="line"><span class="comment">// 不过最后还多一个 -1</span></div><div class="line"><span class="keyword">var</span> position = [];</div><div class="line"><span class="keyword">var</span> pos = hw.indexOf(<span class="string">"e"</span>);</div><div class="line">position.push(pos);</div><div class="line"><span class="keyword">for</span> (pos = pos + <span class="number">1</span>; pos &gt; <span class="number">-1</span>;) &#123;</div><div class="line">    pos = hw.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>);</div><div class="line">    position.push(pos);</div><div class="line">&#125;</div><div class="line">position; <span class="comment">// [4, 37, 75, 94, 98, -1]</span></div><div class="line"></div><div class="line"><span class="comment">// 书中做法</span></div><div class="line"><span class="keyword">var</span> position = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> pos = hw.indexOf(<span class="string">"e"</span>);</div><div class="line"></div><div class="line"><span class="keyword">while</span>(pos &gt; <span class="number">1</span>)&#123;</div><div class="line">    position.push(pos);</div><div class="line">    pos = hw.indexOf(<span class="string">"e"</span>, pos + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">position; <span class="comment">// [4, 37, 75, 94, 98]</span></div></pre></td></tr></table></figure>
<h5 id="2-从某个整数范围内随机选择一个值"><a href="#2-从某个整数范围内随机选择一个值" class="headerlink" title="2. 从某个整数范围内随机选择一个值"></a>2. 从某个整数范围内随机选择一个值</h5><blockquote>
<p><strong>整数随机值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值 )</strong></p>
</blockquote>
<p>反推：<br>s &lt;= XXX &lt; N + s<br>0 &lt;= XXX -s &lt; N<br>0 &lt;= (XXX - s) / N &lt; 1<br>则 ((XXX - s) / N) = Math.random()，推出XXX = Math.random() * N + s<br>这样 s &lt; XXX &lt; N + s<br>刚好<strong>向下取整</strong>就可以取到s和最大值N+S-1了。</p>
<p>另一种：<br>lowValue &lt;= XXX &lt;= upValue<br>0 &lt;= XXX - lowValue &lt;= upValue - lowValue<br>0 &lt;= (XXX - lowValue) / (upValue - lowValue) &lt;= 1<br>则 (XXX - lowValue) / (upValue - lowValue) = Math.random()，推出XXX = (upValue - lowValue) * Math.random() + lowValue<br>但这样下来<br>lowValue &lt; XXX &lt; upValue<br>取不到最小值和最大值，<strong>向下取整</strong>或<strong>向上取整</strong>只能解决一半问题。</p>
<p>设m大于0小于1，则<br>lowValue + m &lt; XXX &lt; upValue + m<br>然后两边都<strong>向下取整</strong>，才可以使得XXX取到lowValue和upValue。<br>又，m就是Math.random()，所以开始时<br>lowValue &lt; XXX - Math.random()&lt; upValue<br>……<br>XXX = (upValue - lowValue + 1) * Math.random() + lowValue<br>所以：<br><strong> 整数随机值 = Math.floor((最大值 - 最小值 + 1) * Math.random() + 最小值) </strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 已知最大值和最小值，取一个区间内的整数</span></div><div class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatRanIntNum</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor((upperValue - lowerValue + <span class="number">1</span>) * <span class="built_in">Math</span>.random() + lowerValue);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ranNums1 = [];</div><div class="line"><span class="keyword">var</span> ranNums2 = [];</div><div class="line"><span class="keyword">var</span> ranNums3 = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">    ranNums1.push(creatRanIntNum(<span class="number">1</span>, <span class="number">9</span>));</div><div class="line">    ranNums2.push(creatRanIntNum(<span class="number">10</span>, <span class="number">16</span>));</div><div class="line">    ranNums3.push(creatRanIntNum(<span class="number">0</span>, <span class="number">50</span>));</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now();</div><div class="line">alert(<span class="string">"花了"</span> + (stop - start) + <span class="string">"ms"</span> ); <span class="comment">// 有时候是0ms...加大随机个数到10000，差不多10ms左右</span></div><div class="line"><span class="comment">// var start = Date.now(); 这一句应该写在哪儿呢？？</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第5章-引用类型（二）（Function类型、基本包装类型、单体内置对象）&quot;&gt;&lt;a href=&quot;#第5章-引用类型（二）（Function类型、基本包装类型、单体内置对象）&quot; class=&quot;headerlink&quot; title=&quot;第5章 引用类型（二）（Function类型、基本包装类型、单体内置对象）&quot;&gt;&lt;/a&gt;第5章 引用类型（二）（Function类型、基本包装类型、单体内置对象）&lt;/h2&gt;&lt;h3 id=&quot;5-5-Function类型&quot;&gt;&lt;a href=&quot;#5-5-Function类型&quot; class=&quot;headerlink&quot; title=&quot;5.5 Function类型&quot;&gt;&lt;/a&gt;5.5 Function类型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;函数是对象。&lt;br&gt;函数名实际上是一个指向对象的指针。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;函数的定义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;法一：&lt;strong&gt;函数声明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;法二：&lt;strong&gt;函数表达式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;法三：使用Function构造函数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow学习笔记（一）</title>
    <link href="http://yoursite.com/2017/02/23/TensorFlow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/23/TensorFlow学习笔记（一）/</id>
    <published>2017-02-23T11:30:06.000Z</published>
    <updated>2017-02-27T06:02:58.063Z</updated>
    
    <content type="html"><![CDATA[<p>按照<a href="https://www.tensorflow.org/" target="_blank" rel="external">官网</a>的介绍、教程学习。整理、记录知识点。</p>
<p>这一篇是最开始的一篇。<a href="https://www.tensorflow.org/get_started/get_started" target="_blank" rel="external">Getting Started With TensorFlow</a></p>
<p>现在的TesorFlow的API可以分为两个，一个低级一点的，称为TensorFlow Core，更适合研究人员使用，对所构建的模型有更深层的控制；另一个高级一点的，使用更简单，但还在开发中。学会了更底层的东西，更简答的用法可以很快掌握。这里只记录TensorFlow Core中的知识点。</p>
<p>这篇文章其实可以分为两部分。一部分介绍TensorFlow中的一些名词、类、方法等等。另一部分介绍了一个简单的机器学习模型——线性回归。<br><a id="more"></a></p>
<h3 id="1-一些概念"><a href="#1-一些概念" class="headerlink" title="1. 一些概念"></a>1. 一些概念</h3><ul>
<li><p><strong>Tensor</strong></p>
<ul>
<li>tensor可以说是一种<strong>数据结构</strong>，TensorFlow中所有的数据都是用这种数据结构表示的</li>
<li>可以将一个tensor看成是一个n-维的数组或列表</li>
<li>一个tensor的维度可以是静态的也可以是动态的</li>
<li>只有tensor可以在计算图中传递（流动flow）</li>
<li><p>tensor的<strong>rank 秩</strong>？？？</p>
</li>
<li><p>tensro的<strong>shape 形状</strong>？？？</p>
</li>
</ul>
</li>
<li><p><strong>Computational Graph</strong></p>
<p>为什么要有计算图呢？谷歌在<a href="https://www.tensorflow.org/get_started/mnist/beginners" target="_blank" rel="external">下一篇</a>的介绍中有讲。<br>在Python中进行高效的数值运算，是用的NumPy，将耗时的计算（比如矩阵乘法）移到Python外，用更底层的语言，更高效地完成，之后再将结果倒回Python中。但这样倒过来倒过去的，也有很多开销。所以使用TensorFlow时，将所有的操作都先描述出来，然后将整个操作过程都移到外边进行，不用进行一次运算操作，来回倒一次，这样开销就会少很多。（很多其他的机器学习库都是类似这样的。）</p>
<p>图是由什么组成的呢？点(<strong>Node</strong>)和边。所以一些数据（<strong>常量constant</strong>、<strong>变量Variables</strong>）和操作(<strong>Operations</strong>)都放在node中。边呢就表示tensor的流动了。</p>
</li>
<li><p><strong>Session</strong></p>
<p>有了上边计算图的概念，这个Session就好理解了。因为计算图中的东西（节点）只是一种描述，并没有真正的运算。所以需要一个东西去告诉tensorflow去运行图中的操作，就是这个Session了。</p>
<p>两三个点可以组成一个子图，七八个点也可以组成一个子图。所以可以看到一个Session实例可以run好多次，这次run这两个点，下次run其他几个点，这都是可以的。</p>
<p>还有一个问题。当用session去run多个节点时要注意写法。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line">node1 = ...</div><div class="line">node2 = ...</div><div class="line">sess = tf.Session()</div><div class="line">// 错误！！！</div><div class="line">sess.run(node1, node2)</div><div class="line">// 正确</div><div class="line">sess.run([node1, node2])</div></pre></td></tr></table></figure>
<p><a href="">这里</a>是run()方法的api，可以接收好几个参数。但第一个参数是说想要执行的tensor和operation（即图中的节点）。可以是一个，或者是任意嵌套的列表、字典等。</p>
</li>
<li><p><strong>constant</strong></p>
<p>常量。没什么特别的。注意是小写。</p>
</li>
<li><p><strong>placeholder</strong></p>
<ul>
<li><p>看名字，这是一个空儿（茅坑），等会儿会有各种数据（shi||niao）填进来。</p>
</li>
<li><p>之后run的时候要用到它时，用<strong>dict字典</strong>来给它传数据。{xx:XXX,yy:YYY}</p>
</li>
<li><p>和变量的区别？当然也能给变量各种值。placeholder更简单？也不是。概念上更符合？</p>
</li>
</ul>
</li>
<li><p><strong>Variable</strong></p>
<p>变量。注意首字母大写。</p>
<p>需要专门的初始化。（常量不需要。）</p>
</li>
</ul>
<h3 id="2-线性模型"><a href="#2-线性模型" class="headerlink" title="2. 线性模型"></a>2. 线性模型</h3><p>机器学习，简单一点的，有这么一种情况。我们是从很多的数据中去学习（挖掘）一些知识。这些数据其实是满足一种分布的。我们要想学习到一些知识，最根本又最有用的方法就是根据这些数据推断出数据的分布情况。这样需要什么样的知识都可以从这个分布推断出来。</p>
<p>线性模型就是假设数据是线性分布的。我们的目的就是找出一条直线去拟合（regression回归问题）这些数据。即求出这条直线的斜率（W）和偏差（b）。用变量来定义这两个参数。因为是要不停的试、不停的变的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line">// 注意W被示例写为大写，而b是小写。因为W经常是个矩阵，b只是标量。</div><div class="line">// 上边常量是小写，变量首字母大写。这个原因是什么？</div><div class="line">W = tf.Variable([<span class="number">.3</span>], tf.float32)</div><div class="line">b = tf.Variable([<span class="number">-.3</span>], tf.float32)</div></pre></td></tr></table></figure></p>
<p>现在我们已有的东西是什么？一些数据。即一些x和其相应的y。用placeholder定义。等会儿run的时候再传具体的数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = tf.placeholder(tf.float32)</div><div class="line">y = tf.placeholder(tf.float32)</div></pre></td></tr></table></figure></p>
<p>我们的模型的是线性模型，根据x即W和b可以得到一些预测值。即<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">linear_model = W * x + b</div></pre></td></tr></table></figure></p>
<p>现在我们根据x和W、b得到一些预测值，但这些值和真正的值有多少差距？即我们的模型和真实的数据分布有什么差距（当前的W、b和真的W、b的差距）？用<strong>loss</strong>或<strong>cost</strong>来表示这个损失。这里用预测值和实际值的差值的平方和来表示。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">loss = tf.reduce_sum(tf.square(linear_model - y))</div></pre></td></tr></table></figure></p>
<p>若有差距，我们怎样减少这些差距？因为我们的<strong>终极目标</strong>就是<strong>使损失函数最小</strong>（其实就是一个优化问题）。TensorFlow提供了各种各样的<strong>优化器optimizers</strong>，这里使用的是最简单的<strong>梯度下降算法gradient descent</strong>。这也正是TensorFlow这些机器学习库厉害之处？想想自己code实现梯度下降算法……<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.01</span>)</div><div class="line">train = optimizer.minimize(loss)</div></pre></td></tr></table></figure></p>
<p>接下来就是进行训练了。根据这些数据x，沿着这个优化器optimizer的方向，不断的调整模型参数W和b。这些过程就在上边的train中自动完成了。这也是TensorFlow这些机器学习库厉害之处？</p>
<p>在run上边的train时，我们要给placeholder，x和y传入具体的训练数据。还有要将变量Variable，W和b进行初始化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 训练数据</div><div class="line">x_train = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">y_train = [<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>]</div><div class="line">// 准备初始化变量</div><div class="line">init = tf.global_variables_initializer()</div><div class="line">// 创建Session</div><div class="line">sess = tf.Session()</div><div class="line">// 真正初始化变量</div><div class="line">sess.run(init)</div><div class="line">// 训练过程</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</div><div class="line">    sess.run(train, &#123;x: x_train, y: y_train&#125;)</div></pre></td></tr></table></figure></p>
<p>这样就完成了一个简单的机器学习。当然之后还有验证学习到的模型的准确性、测试学习到的模型的泛化能力等等任务。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照&lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;官网&lt;/a&gt;的介绍、教程学习。整理、记录知识点。&lt;/p&gt;
&lt;p&gt;这一篇是最开始的一篇。&lt;a href=&quot;https://www.tensorflow.org/get_started/get_started&quot;&gt;Getting Started With TensorFlow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在的TesorFlow的API可以分为两个，一个低级一点的，称为TensorFlow Core，更适合研究人员使用，对所构建的模型有更深层的控制；另一个高级一点的，使用更简单，但还在开发中。学会了更底层的东西，更简答的用法可以很快掌握。这里只记录TensorFlow Core中的知识点。&lt;/p&gt;
&lt;p&gt;这篇文章其实可以分为两部分。一部分介绍TensorFlow中的一些名词、类、方法等等。另一部分介绍了一个简单的机器学习模型——线性回归。&lt;br&gt;
    
    </summary>
    
    
      <category term="tensorflow学习" scheme="http://yoursite.com/tags/tensorflow%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JS高程（四）</title>
    <link href="http://yoursite.com/2017/02/22/JS%E9%AB%98%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/22/JS高程（四）/</id>
    <published>2017-02-22T09:17:49.000Z</published>
    <updated>2017-02-27T07:40:33.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第5章-引用类型（一）（Object、Array、Date）"><a href="#第5章-引用类型（一）（Object、Array、Date）" class="headerlink" title="第5章 引用类型（一）（Object、Array、Date）"></a>第5章 引用类型（一）（Object、Array、Date）</h2><p><strong>引用类型</strong>是一种数据结构，和其他面向对象语言中的<strong>类</strong>很相似。之前介绍的JS中的6种数据类型，5种基本数据类型Undefined，Null，Boolean，String，Number，还有1种复杂数据类型<strong>Object</strong>，这里用Object是由于JS中大多数引用类型的值都是Object类型的实例。JS中可以通过Object创建用户自定义的引用类型，也有许多内置的<strong>原生引用类型</strong>：Array、Date、RegExp、Function、基本包装类型、单体内置对象。</p>
<a id="more"></a>
<h3 id="5-1-Object类型"><a href="#5-1-Object类型" class="headerlink" title="5.1 Object类型"></a>5.1 Object类型</h3><ul>
<li><p>创建的方法</p>
<ul>
<li><p>法一：new Object()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"DaShuaiBi"</span>;</div><div class="line">person.age = <span class="number">18</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>法二：对象字面量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person = &#123;<span class="attr">name</span>: <span class="string">"Dashuaibi"</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;; <span class="comment">// 属性名和属性值之间用冒号隔开； 不同属性之间用逗号隔开</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问对象属性的方法</p>
<ul>
<li><p>法一：点表示法 后边永远不是 字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 接上代码</span></div><div class="line">alert(person.name);</div></pre></td></tr></table></figure>
</li>
<li><p>法二：使用方括号 方括号中永远是 字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 接上代码</span></div><div class="line">alert(person[name]); <span class="comment">// !!! 注意 !!! 这样是undefiend</span></div></pre></td></tr></table></figure>
</li>
<li><p>方括号的优势</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方括号中可以是变量！！！ </span></div><div class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>; </div><div class="line">alert(person[propertyName]); <span class="comment">// DaShuaiBi</span></div><div class="line"><span class="keyword">var</span> propertyName2 = <span class="string">"age"</span>;</div><div class="line">alert(person.propertyName2); <span class="comment">// undefined</span></div><div class="line">person = &#123;<span class="attr">name</span>: <span class="string">"Dashuaibi"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;;</div><div class="line"><span class="keyword">var</span> propertyName3 = <span class="string">"age"</span>;</div><div class="line">alert(person.propertyName3); <span class="comment">// undefined</span></div><div class="line"><span class="comment">// 对象的属性名可以是字符串</span></div><div class="line">personX = &#123;<span class="string">"name"</span>: <span class="string">"DaShuaiBi"</span>, <span class="string">"age"</span>: <span class="number">16</span>&#125;;</div><div class="line">alert(personX.name); <span class="comment">// "DaShuaiBi"；点表示法仍可用</span></div><div class="line">alert(personX.<span class="string">"name"</span>); <span class="comment">// 错误！！</span></div><div class="line">alert(personX[name]); <span class="comment">// undefined</span></div><div class="line">alert(personX[<span class="string">"name"</span>]); <span class="comment">// "DaShuaiBi"</span></div><div class="line"><span class="comment">// 若是属性名很变态</span></div><div class="line">personY = &#123;<span class="string">"first name"</span>: <span class="string">"HeiHeiHei"</span>, <span class="attr">age</span>: <span class="number">16</span>&#125;;</div><div class="line">alert(personY.first name); <span class="comment">// 错误！！</span></div><div class="line">alert(personY.<span class="string">"first name"</span>); <span class="comment">// 错误！！</span></div><div class="line">alert(personY[<span class="string">"first name"</span>]); <span class="comment">// "HeiHeiHei"</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="5-2-Array类型"><a href="#5-2-Array类型" class="headerlink" title="5.2 Array类型"></a>5.2 Array类型</h3><ul>
<li><p>与其他语言中数组的异同</p>
<ul>
<li><p>同： 都是数据的有序列表</p>
</li>
<li><p>异： JS中数组可以存放不同数据类型的元素；JS中数组的大小（长度）是可变的</p>
</li>
</ul>
</li>
<li><p>创建数组的方法</p>
<ul>
<li><p>法一： new Array()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以下几种方法均可</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>法二： 数组字面量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [];</div><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>,]; <span class="comment">// 这样不好。很多情况下都不好，比如css的属性、json中的数据……</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>读取、设置数组元素</p>
<p>  使用方括号、基于0索引。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 读取</span></div><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">alert(colors[<span class="number">1</span>]); <span class="comment">// "blue"</span></div><div class="line"><span class="comment">// 设置1 修改</span></div><div class="line">colors[<span class="number">1</span>] = <span class="string">"shit_yellow"</span>;</div><div class="line">alert(colors[<span class="number">1</span>]); <span class="comment">// "shit_yellow"</span></div><div class="line"><span class="comment">// 设置2 新增</span></div><div class="line">alert(colors[<span class="number">3</span>]); <span class="comment">// undefined</span></div><div class="line">colors[<span class="number">3</span>] = <span class="string">"yima_red"</span>;</div><div class="line">alert(colors[<span class="number">3</span>]); <span class="comment">// "yima_red"</span></div></pre></td></tr></table></figure>
</li>
<li><p>数组的length属性</p>
<ul>
<li><p>返回数组的大小</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">alert(colors.length); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
</li>
<li><p>从数组末尾移除元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">colors.length = <span class="number">2</span>;</div><div class="line">alert(colors[<span class="number">2</span>]); <span class="comment">// undefined</span></div><div class="line">colors.length = <span class="number">1</span>;</div><div class="line">alert(colors[<span class="number">1</span>]); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
</li>
<li><p>在数组末尾添加新项</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">alert(colors.length); <span class="comment">// 3</span></div><div class="line">colors[colors.length] = <span class="string">"yellow"</span>;</div><div class="line">colors; <span class="comment">// ["red", "blue", "green", "yellow"]</span></div><div class="line">alert(colors.length); <span class="comment">// 4</span></div></pre></td></tr></table></figure>
</li>
<li><p>增大length的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">alert(colors.length); <span class="comment">// 3</span></div><div class="line">colors.length = <span class="number">5</span>; </div><div class="line">alert(colors[<span class="number">3</span>]); <span class="comment">// undefined</span></div><div class="line">alert(colors[<span class="number">4</span>]); <span class="comment">// undefined</span></div><div class="line">alert(colors[<span class="number">5</span>]); <span class="comment">// 也是undefined……</span></div></pre></td></tr></table></figure>
</li>
<li><p>给不在初始范围内的位置上赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">colors[<span class="number">999</span>] = <span class="string">"yellow"</span>;</div><div class="line">alert(colors.length); <span class="comment">// 1000</span></div><div class="line">alert(colors[<span class="number">555</span>]); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="5-2-1-检测数组"><a href="#5-2-1-检测数组" class="headerlink" title="5.2.1 检测数组"></a>5.2.1 检测数组</h4><p>说明：xxx表示变量名；XXX表示某种引用类型，如Array、Function…</p>
<ul>
<li><p><strong>typeof</strong>操作符<br>  type of xxx;</p>
</li>
<li><p><strong>instanceof</strong>操作符<br>  xxx instanceof XXX</p>
</li>
<li><p><strong>Array.isArray()</strong>方法<br>  Array.isArray(xxx)</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nickName = [<span class="string">"DaShuaiBi"</span>, <span class="string">"HeiHeiHei"</span>, <span class="string">"Ob"</span>];</div><div class="line"><span class="keyword">var</span> xiaoName = <span class="string">"xiaofei"</span>;</div><div class="line"></div><div class="line">alert(<span class="keyword">typeof</span> nickName); <span class="comment">// object</span></div><div class="line">alert(<span class="keyword">typeof</span> xiaoName); <span class="comment">// string</span></div><div class="line"></div><div class="line">alert(nickName <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></div><div class="line">alert(xiaoName <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></div><div class="line">alert(xiaoName <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">// false !!!</span></div><div class="line"></div><div class="line">alert(<span class="built_in">Array</span>.isArray(nickName)); <span class="comment">// true</span></div><div class="line">alert(<span class="built_in">Array</span>.isArray(xiaoName)); <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-2-2-转换方法"><a href="#5-2-2-转换方法" class="headerlink" title="5.2.2 转换方法"></a><span id="5.2.2">5.2.2 转换方法</span></h4><p>toString()、toLocaleString()、valueOf()、join()方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">alert(colors.join()); <span class="comment">// "red,blue,green" ；大多数的默认的，用逗号分隔</span></div><div class="line">alert(colors.join(<span class="string">"||"</span>)); <span class="comment">// "red||blue||green"</span></div></pre></td></tr></table></figure>
<p>toLocaleString()比较特殊。但不想看……</p>
<h4 id="5-2-3-和5-2-4-栈方法和队列方法"><a href="#5-2-3-和5-2-4-栈方法和队列方法" class="headerlink" title="5.2.3 和5.2.4 栈方法和队列方法"></a>5.2.3 和5.2.4 栈方法和队列方法</h4><p>用数组Array模拟栈和队列。</p>
<p>栈：数据只能从栈顶进出；后进先出。</p>
<p>队列：数据只能从队首出，只能从队尾进；先进先出。</p>
<p>三个方法：<strong>push()</strong>模拟压栈；<strong>pop()</strong>模拟出栈和队列在队尾新增元素；<strong>shift()</strong>模拟队列删除队首元素</p>
<p>注意这几个函数的返回值！！！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模拟栈</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// push 将元素压入栈，并返回当前数组的长度</span></div><div class="line">alert(count); <span class="comment">// 2</span></div><div class="line">colors; <span class="comment">// ["red", "green"]</span></div><div class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"blue"</span>);</div><div class="line">alert(count); <span class="comment">// 3</span></div><div class="line">colors; <span class="comment">// ["red", "green", "blue"]</span></div><div class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">// 从栈顶删除元素即数组的最后边，并返回被退栈的元素</span></div><div class="line">alert(item); <span class="comment">// "blue" !!!</span></div><div class="line">colors; <span class="comment">// ["red", "green"]</span></div><div class="line"></div><div class="line"><span class="comment">// 模拟队列</span></div><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 这里和模拟栈一样</span></div><div class="line">alert(count); <span class="comment">// 2</span></div><div class="line">colors; <span class="comment">// ["red", "green"]</span></div><div class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"blue"</span>);</div><div class="line">alert(count); <span class="comment">// 3</span></div><div class="line">colors; <span class="comment">// ["red", "green", "blue"] 至此还和栈一样</span></div><div class="line"><span class="keyword">var</span> item = colors.shift(); <span class="comment">// 从队首删除元素即数组的最前边，并返回该元素</span></div><div class="line">alert(item); <span class="comment">// "red" !!!</span></div><div class="line">colors; <span class="comment">// ["green", "blue"]</span></div></pre></td></tr></table></figure>
<p>另外还有一个函数<strong>unshift()</strong>，在数组前端添加元素，并返回数组的长度。</p>
<p>可以使用unshift()和pop()反向模拟队列。从队尾（数组后边）删除，从队首（数组前边）加入。</p>
<p>可以使用unshift()和shfit模拟倒着的栈？</p>
<p>这四个函数的关系：push() ~ unshift()；pop() ~ shift()</p>
<h4 id="5-2-5-重排序方法"><a href="#5-2-5-重排序方法" class="headerlink" title="5.2.5 重排序方法"></a>5.2.5 重排序方法</h4><p>有两个方法，sort()和reverse()。</p>
<ul>
<li><p><strong>reverse()</strong>方法<br>只是将数组元素反转，并不管大小顺序。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">values.reverse();</div><div class="line">alert(values); <span class="comment">// 5, 4, 3, 2, 1</span></div><div class="line">alert(values.reverse()); <span class="comment">// 返回值 排序后的数组 1, 2, 3, 4, 5</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>sort()</strong>方法</p>
<blockquote>
<p>sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。</p>
</blockquote>
<p>所以有时候并不是人们期望的结果。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort();</div><div class="line">alert(values); <span class="comment">// 0, 1, 10, 15, 5</span></div><div class="line">alert(values.sort()); <span class="comment">// 返回值 排序后的数组 0, 1, 10, 15, 5</span></div></pre></td></tr></table></figure>
<p>为了解决上述问题。sort()方法接收一个<strong>比较函数</strong>作为参数，以便指定排序规则。</p>
<blockquote>
<p><strong>比较函数</strong>接收两个参数，返回值可以是负数、0、正数。若是正数，则规定第一个参数在第二个参数之后；若是负数，则规定第一个参数在第二个参数之前。</p>
</blockquote>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 升序</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareUp</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 降序</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareDown</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>];</div><div class="line">values.sort(compareUp);</div><div class="line">alert(values); <span class="comment">// 1,2,3,4,5</span></div><div class="line">values.sort(compareDown);</div><div class="line">alert(values); <span class="comment">// 5,4,3,2,1</span></div><div class="line"></div><div class="line"><span class="comment">// 更简单的方法，适合数值类型</span></div><div class="line"><span class="comment">// 升序</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareUp2</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value1 - value2;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 降序</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareDown2</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value2 - value1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-2-6-操作方法"><a href="#5-2-6-操作方法" class="headerlink" title="5.2.6 操作方法"></a>5.2.6 操作方法</h4><p>类似python中的切片。</p>
<p>三个函数：concat()、slice()、splice()。concat–合并；slice–薄片、切开；splice–拼接</p>
<ul>
<li><p><strong>concat()</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> skills1 = [<span class="string">"code"</span>, <span class="string">"ps"</span>,<span class="string">"football"</span>];</div><div class="line"><span class="keyword">var</span> skills2 = skills1.concat(<span class="string">"dream"</span>,[<span class="string">"piebi"</span>, <span class="string">"kandan"</span>]);</div><div class="line"></div><div class="line">alert(skills1); <span class="comment">// code,ps,football</span></div><div class="line">alert(skills2); <span class="comment">// code,ps,football,dream,piebi,kandan</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>slice()</strong></p>
<p>两种情况</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"white"</span>, <span class="string">"black"</span>];</div><div class="line"><span class="comment">// 情况1 只有一个参数</span></div><div class="line"><span class="keyword">var</span> colors1 = colors.slice(<span class="number">1</span>);</div><div class="line">alert(colors); <span class="comment">// red,blue,green,white,black</span></div><div class="line">alert(colors1); <span class="comment">// blue,green,white,black</span></div><div class="line"><span class="comment">// 情况2 有两个参数</span></div><div class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>, <span class="number">3</span>);</div><div class="line">alert(colors); <span class="comment">// red,blue,green,white,black</span></div><div class="line">alert(colors2); <span class="comment">// blue,green</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>splice()</strong><br>第一个参数：要删除的第一项的位置；第二个参数：要删除的项数；第三、四…个参数：要增加的项目。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</div><div class="line"><span class="comment">// 删除 只需指定前两个参数</span></div><div class="line"><span class="keyword">var</span> removed1 = colors.splice(<span class="number">0</span>, <span class="number">1</span>);</div><div class="line">alert(colors); <span class="comment">// green,blue</span></div><div class="line">alert(removed1); <span class="comment">// red</span></div><div class="line"></div><div class="line"><span class="comment">// 插入 即第二项 要删除的项数为0</span></div><div class="line"><span class="keyword">var</span> removed2 = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>);</div><div class="line">alert(colors); <span class="comment">// green,yellow,purple,blue</span></div><div class="line">alert(removed2); <span class="comment">// []</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> removed3 = colors.splice(<span class="number">0</span>, <span class="number">0</span>, [<span class="string">"white"</span>, <span class="string">"black"</span>]);</div><div class="line">colors; <span class="comment">// [["white","black"],"green","yellow","purple","blue"]</span></div><div class="line">alert(colors); <span class="comment">// white,black,green,yellow,purple,blue</span></div><div class="line">alert(removed3); <span class="comment">// []</span></div><div class="line"></div><div class="line"><span class="comment">// 替换 需要三个参数</span></div><div class="line"><span class="keyword">var</span> removed4 = colors.splice(<span class="number">0</span>, <span class="number">1</span>, <span class="string">"orange"</span>);</div><div class="line"><span class="comment">// 注意！！！ 这里的第一个元素是一个数组,当成一个整体。</span></div><div class="line">colors; <span class="comment">// ["orange","green","yellow","purple","blue"] </span></div><div class="line">alert(removed4); <span class="comment">// white,black</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-2-7-位置方法"><a href="#5-2-7-位置方法" class="headerlink" title="5.2.7 位置方法"></a>5.2.7 位置方法</h4><p>两个函数：indexOf()和lastIndexOf()，一个从前往后，一个从后往前。</p>
<p>两种情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>];</div><div class="line"><span class="comment">// 情况1 只有一个参数  表示要找的元素而不是索引位置</span></div><div class="line">alert(numbers.indexOf(<span class="number">3</span>)); <span class="comment">// 1 而不是 5</span></div><div class="line"><span class="comment">// 情况2 两个参数 第一个是要查找的元素，第二个是查找起点位置</span></div><div class="line">alert(numbers.indexOf(<span class="number">3</span>, <span class="number">0</span>)); <span class="comment">// 1</span></div><div class="line">alert(numbers.indexOf(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// 6</span></div><div class="line">alert(numbers.indexOf(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// -1 找不到了，不会再返回0号位置找</span></div></pre></td></tr></table></figure>
<h4 id="5-2-8-迭代方法-amp-5-2-9-归并方法"><a href="#5-2-8-迭代方法-amp-5-2-9-归并方法" class="headerlink" title="5.2.8 迭代方法 &amp; 5.2.9 归并方法"></a>5.2.8 迭代方法 &amp; 5.2.9 归并方法</h4><p>好多函数：every()、filter()、forEach()、map()、some()和reduce()、reduceRight()。都不是很了解。。。都会接收一个函数参数？？？</p>
<h3 id="5-3-Date类型"><a href="#5-3-Date类型" class="headerlink" title="5.3 Date类型"></a>5.3 Date类型</h3><p><strong>UTC</strong>(Coordinated Universal Time)和<strong>GMT</strong>(Greenwich Mean Time)的区别。GMT是时区(time zone)，UTC是时间标准(time standard)。更具体的参考<a href="https://www.timeanddate.com/time/gmt-utc-time.html" target="_blank" rel="external">这里</a>和<a href="http://pansci.asia/archives/84978" target="_blank" rel="external">这里</a>。</p>
<p>Date类型使用自UTC，1970.1.1,00:00:00开始的<strong>毫秒数</strong>。</p>
<ul>
<li><p>创建方法</p>
<ul>
<li><p>使用 new Date()方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不传参数 获取当前的日期时间</span></div><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">date; <span class="comment">// Thu Feb 23 2017 14:58:01 GMT+0800 (中国标准时间)</span></div><div class="line"><span class="comment">// 传递参数 需要传递想要时间的距离1970.1.1,00:00:00的毫秒数</span></div><div class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">123456789</span>);</div><div class="line">date1; <span class="comment">// Fri Jan 02 1970 18:17:36 GMT+0800 (中国标准时间)</span></div></pre></td></tr></table></figure>
</li>
<li><p>还是使用 new Date()方法，但参数更容易理解 Date.parse()和Date.UTC()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 传递的是 表示日期的字符串参数 用Date.parse()处理</span></div><div class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"Feb 11, 2017"</span>)); <span class="comment">// 还有其他格式的日期。。。</span></div><div class="line">date2; <span class="comment">// Sat Feb 11 2017 00:00:00 GMT+0800 (中国标准时间)</span></div><div class="line"><span class="comment">// 传递的是 表示日期的数字 年 月 天 时 分 秒 毫秒</span></div><div class="line"><span class="keyword">var</span> date3 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">03</span>, <span class="number">35</span>)); <span class="comment">// 前两个参数 是必须的 后边的参数可以省略 默认0 月份是从0-11</span></div><div class="line">date3; <span class="comment">// Sat Feb 11 2017 11:35:00 GMT+0800 (中国标准时间) 注意这里想要的是凌晨3点，但是中国的标准时间是上午11点。这是基于GMT创建的，是GMT+0时区的时间，浏览器（或者说JS寄宿环境）会将其转换为本地的时间，中国是GMT+8。</span></div></pre></td></tr></table></figure>
</li>
<li><p>其实上边的Date.parse()和Date.UTC()放法可以省略…有些许不同</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> date4 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"Feb,11,2017"</span>);</div><div class="line">date4; <span class="comment">// Sat Feb 11 2017 00:00:00 GMT+0800 (中国标准时间) 和之前完全一样</span></div><div class="line"><span class="keyword">var</span> date5 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">03</span>, <span class="number">35</span>);</div><div class="line">date5; <span class="comment">// Sat Feb 11 2017 03:35:00 GMT+0800 (中国标准时间) 注意这里时间就是凌晨3点了。这是基于本地时区创建的。与之前不同</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>做性能度量</strong> </p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now(); <span class="comment">// 也可用 +new Date() 获取Date对象的时间戳？</span></div><div class="line">doSomething();</div><div class="line"><span class="keyword">var</span> stop = <span class="built_in">Date</span>.now(); <span class="comment">// 也可用 +new Date()</span></div><div class="line"><span class="keyword">var</span> cost = stop - start; <span class="comment">// 所用的毫秒数</span></div></pre></td></tr></table></figure>
</li>
<li><p>继承的方法</p>
<p>上边的数组也有这些 在<a href="#5.2.2">5.2.2</a> 转换方法中<br>toString()、toLocaleString()、valueOf()（返回日期的毫秒数）</p>
</li>
<li><p>日期格式化</p>
<p>专门用于将日期格式化为字符串<br>toDateString()、toTimeString()、toLocaleDateString()、toLocaleTimeString()、toUTCString() 用的时候再看？不同浏览器或许还不同？</p>
</li>
<li><p>日期/时间组件方法</p>
<p>  FullYear、Month、Date（天数 1-31）、Day（星期几 0日-6六）、Hours、Minutes、Seconds、Milliseconds（<strong>日期中的</strong>毫秒数）、Time（<strong>日期的</strong>毫秒数）、TimezoneOffset（？） 都有get、set方法，还有UTCXX。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">date.getMilliseconds(); <span class="comment">// 118</span></div><div class="line">date.getTime(); <span class="comment">// 1487832517118</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第5章-引用类型（一）（Object、Array、Date）&quot;&gt;&lt;a href=&quot;#第5章-引用类型（一）（Object、Array、Date）&quot; class=&quot;headerlink&quot; title=&quot;第5章 引用类型（一）（Object、Array、Date）&quot;&gt;&lt;/a&gt;第5章 引用类型（一）（Object、Array、Date）&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;引用类型&lt;/strong&gt;是一种数据结构，和其他面向对象语言中的&lt;strong&gt;类&lt;/strong&gt;很相似。之前介绍的JS中的6种数据类型，5种基本数据类型Undefined，Null，Boolean，String，Number，还有1种复杂数据类型&lt;strong&gt;Object&lt;/strong&gt;，这里用Object是由于JS中大多数引用类型的值都是Object类型的实例。JS中可以通过Object创建用户自定义的引用类型，也有许多内置的&lt;strong&gt;原生引用类型&lt;/strong&gt;：Array、Date、RegExp、Function、基本包装类型、单体内置对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JS基础" scheme="http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android还踢球app总结（三）</title>
    <link href="http://yoursite.com/2017/01/18/Android%E8%BF%98%E8%B8%A2%E7%90%83app%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/18/Android还踢球app总结（三）/</id>
    <published>2017-01-18T07:17:13.000Z</published>
    <updated>2017-02-20T05:37:44.462Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇介绍一下用到的开发模式。做这款软件时对于Android开发的了解仅仅只是看了郭霖大神的《第一行代码》，对于开发模式，或者说软件架构什么的都不了解。不过之前帮一个老师做类似校园BBS时，听他介绍过MVC，自己也查过一些关于MVC的资料。其目的是为了让各个模块儿互相更独立，高内聚低耦合。而<strong>M(Model)模型</strong>、<strong>V(View)视图</strong>、<strong>C(Controller)控制器</strong>，应该是<strong>数据访问</strong>、<strong>界面展示</strong>、<strong>业务逻辑</strong>三者的对应，正是一个软件不可少的东西。</p>
<h3 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1. 预备知识"></a>1. 预备知识</h3><p>在敲代码之前，是先做了一些功能模块的划分，再做了UI，然后就在想用什么方式组织代码，可以提高效率。同时也在想如果是在公司做的话，会用什么方式分配这些不同模块、不同功能的代码任务。之后就在网上查到了应用于Android的MVP模式。它其实是从MVC模式演化而来。</p>
<blockquote>
<p>在Android中Activity或者Fragment是用来做界面展示的，但是其生命周期对于整个软件是很关键的，所以会将一些业务逻辑写在Activity中，这样做很直观，但是其代价就是Activity会越来越臃肿……</p>
</blockquote>
<a id="more"></a>
<p>Android的MVP中<strong>V(View)</strong>就是Activity或者Fragment，<strong>P(Presenter)</strong>相当于MVC中的控制器，<strong>M(Model)</strong>就是MVC中的Model，但<strong>M(Model)</strong>和<strong>V(View)</strong>是完全解耦的，它们之间要打交道的话都要通过<strong>P(Presenter)</strong>。MVP和MVC的区别，一个是M和V更加独立，另一个是将MVP三者都先抽象成了接口，再用具体的类是实现。（第二点，感觉MVC也可以这样做？？或者这种东西其实不是很死板的，适合的才是最好的。）</p>
<p>看了很多资料，直到看到下面这张图，整个思路才算理清。(但是找不到真正的出处是哪儿的了……)</p>
<p><img src="..\Android还踢球app总结（三）\login-classes.png" width="100%" height="100%"></p>
<p>在上图中，首先是有<em>LoginView</em>、<em>LoginPresenter</em>、<em>LoginInteractor</em>三个接口，对应上边的<strong>V</strong>、<strong>P</strong>、<strong>M</strong>。V获得账号密码，传递给P，P再传递给M，M验证之后通过<em>OnLoginFinishedListener</em>接口告知P结果，最后P再根据结果告诉V做什么。</p>
<p>LoginActiviy类实现了<em>LoginView</em>接口、LoginPresenterImp类实现了<em>LoginPresenter</em>接口和<em>OnLoginFinishedListener</em>接口、LoginInteractor类实现了<em>LoginIteractor</em>接口。LoginActivity中持有LoginPresenter的引用(其实是LoginPresenterImp)，而LoginPresenterImp中持有LoginView(其实是LoginActivity)和LoginInteractor(其实是LoginInteractorImp)的引用，这样就能实现信息的传递，而LoginInteractor(其实是LoginInteractorImp)中的消息是通过监听器传给LoginPresenterImp的。</p>
<p>再介绍下UML类图中的关系，三角形箭头虚线箭身是具体的类实现接口，实线箭头是关联，虚线箭头是依赖。</p>
<p><img src="..\Android还踢球app总结（三）\class diagram relations.png"></p>
<p><a href="http://www.cnblogs.com/liuzhang/archive/2013/03/17/2964095.html" target="_blank" rel="external">这篇文章</a>有介绍关联和依赖之间的区别。简单点说就是以依赖关系更弱，关联关系更强。像上图中的LoginPresenterImp中持有LoginInteractor的引用，两者关系强，是关联；而LoginInteractor只是其中一个方法用到了OnLoginFinishedListener做参数，两者关系弱，是依赖。</p>
<h3 id="2-还踢球app"><a href="#2-还踢球app" class="headerlink" title="2. 还踢球app"></a>2. 还踢球app</h3><p>本软件就是完全按照上边那张图进行MVP的使用。还有一个问题，是应该按照不同的功能模块儿打包还是按照MVP这三者进行打包。网上两种方式都有使用者。我先按照功能模块建了包，然后再在里边按照MVP建了包，这样虽然层级深了，但感觉组织性更强了。</p>
<p><img src="..\Android还踢球app总结（三）\module package.PNG"></p>
<p>在找组织模块中，有一个entity包，还有三个子功能包，其中每个子功能包中都有三个包：Model、View和Presenter。本来觉得Java Bean 实体类应该算在Model中，但后来想比如entity中的Post类，有一些属性还有get、set方法，这些在每个子功能中都会用到，不知道该放到哪个里边。所以还不如这样，将所有的实体类放到一个包中，是其他类公用的，至于子功能中的Model就是单单做数据的访问，比如查询、添加等等。</p>
<p><img src="..\Android还踢球app总结（三）\findallgames pakage.PNG"></p>
<p>其他两个功能模块的代码组织和找组织功能一样，这里就不在叙述。</p>
<h3 id="3-找组织功能模块"><a href="#3-找组织功能模块" class="headerlink" title="3. 找组织功能模块"></a>3. 找组织功能模块</h3><p>本小节详细介绍下找组织功能的MVP模式的设计，以及实际的流程。其他两个功能模块大同小异。其模块中具体的类如下图所示。</p>
<p><img src="..\Android还踢球app总结（三）\findallgames class.PNG"></p>
<p>首先，有三个接口(interface)分别对应MVP。<em>AllPostsModel</em>—M、<em>AllPostsView</em>—V、<em>AllPostsPresenter</em>—P。还有一个<em>OnAllPostsListener</em>接口，是M(AllPostsModel)用来通知P(AllPostsPresenter)查询结果的。</p>
<p><img src="..\Android还踢球app总结（三）\find all games interface.jpg"></p>
<p>接下来，分别实现了各个接口。AllPostsFragment类实现AllPostsView接口（这里使用的Fragment做View，就是上一节介绍的ViewPager结合Fragment做tabs）、AllPostsPresenterImp类实现AllPostsPresenter接口和OnAllPostsListenter接口、AllPostsModelImp类实现AllPostsModel接口。</p>
<p>在AllPostsFragment中持有AllPostsPresenter的引用，在AllPostsPresenterImp中持有AllPostsView和AllPostsModel的引用。</p>
<p>打开软件，要执行AllPostsFragment中的onCreateView方法，在这个方法中，首先获取了AllPostsPresenter的引用，然后调用了该类中的getAllPosts方法，还有一些其他关于Fragment和其空间的初始化操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">     <span class="comment">// 实现对AllPostsPresenterImp的引用</span></div><div class="line">    mAllPostsPresenter = <span class="keyword">new</span> AllPostsPresenterImp(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">// 调用AllPostsPresenterImp中的getAllPosts方法</span></div><div class="line">    mAllPostsPresenter.getAllPosts();</div><div class="line">     ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AllPostsPresenterImp中的getAllPosts方法会调用AllPostsModel中的loadAllPosts方法。其中有一个参数，需要传入OnAllPostsListener，因为AllPostsPresenterImp实现了OnAllPostsListener，所以就传入this。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllPosts</span><span class="params">()</span></span>&#123;</div><div class="line">    mAllPostsView.showLoading();</div><div class="line">    <span class="comment">// 调用AllPostsModelImp中的loadAllPosts方法</span></div><div class="line">    mAllPostsModel.loadAllPosts(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在AllPostsModelImp的loadAllPosts方法中，根据现在的日期时间，去Bmob服务器上查询约球时间在当前时刻之后的帖子。然后将查询结果通过OnAllPostsListener告知给AllPostsPresenterImp。（若是成功，就将排好序的Post是放入List中，传递给OnAllPostsListener的onSuccess方法）其中有两处对所查询的帖子进行排序，query.order(“dateTime”)和Collections.sort(…)，应该是query.order()不顶用，才又使用了Collections.sort()？？？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadAllPosts</span><span class="params">(<span class="keyword">final</span> OnAllPostsListener listener)</span></span>&#123;</div><div class="line">    <span class="comment">// 获取当前的时间，并转化为 yyyy-MM-dd HH:mm:ss的格式</span></div><div class="line">    Calendar calendar=Calendar.getInstance();</div><div class="line">    calendar.setTime(<span class="keyword">new</span> Date());</div><div class="line">    String startDate =String.valueOf(calendar.get(Calendar.YEAR))+<span class="string">"-"</span>+</div><div class="line">            <span class="comment">// 月份要加一</span></div><div class="line">            String.valueOf(calendar.get(Calendar.MONTH)+<span class="number">1</span>)+<span class="string">"-"</span>+</div><div class="line">            String.valueOf(calendar.get(Calendar.DAY_OF_MONTH))+<span class="string">" "</span>+</div><div class="line">            String.valueOf(calendar.get(Calendar.HOUR_OF_DAY))+<span class="string">":"</span>+</div><div class="line">            String.valueOf(calendar.get(Calendar.MINUTE))+<span class="string">":"</span>+<span class="string">"00"</span>;</div><div class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</div><div class="line">    Date date  = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        date = sdf.parse(startDate);</div><div class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Bmob实现查询</span></div><div class="line">    BmobQuery&lt;Post&gt; query = <span class="keyword">new</span> BmobQuery&lt;&gt;();</div><div class="line">    <span class="comment">// 查询约球时间在当前时刻之后的帖子</span></div><div class="line">    query.addWhereGreaterThanOrEqualTo(<span class="string">"dateTime"</span>,<span class="keyword">new</span> BmobDate(date));</div><div class="line">    query.order(<span class="string">"dateTime"</span>);</div><div class="line">    query.findObjects(ContextHolder.getContext(), <span class="keyword">new</span> FindListener&lt;Post&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(List&lt;Post&gt; object)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            <span class="keyword">if</span> (object.size() != <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// 返回的是一个Post的List，对其按照约球时间进行排顺序。</span></div><div class="line">                Collections.sort(object, <span class="keyword">new</span> Comparator&lt;Post&gt;() &#123;</div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Post arg0, Post arg1)</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> arg0.getDate().compareTo(arg1.getDate());</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line"></div><div class="line">                listener.onSuccess(object);</div><div class="line"></div><div class="line">                postList = object;</div><div class="line"></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Toast.makeText(ContextHolder.getContext(), <span class="string">"还没有约球组织"</span>, Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>&#123;</div><div class="line">            <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">            listener.onError(msg);</div><div class="line">            Toast.makeText(ContextHolder.getContext(), msg + <span class="string">" "</span> + code, Toast.LENGTH_LONG).show();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AllPostsPresenterImp实现了OnAllPostsListener接口，其在onSuccess方法中调用了AllPostsView的setAllPosts方法。将查询到的Post的List传递过去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(List&lt;Post&gt; objects)</span></span>&#123;</div><div class="line">    mAllPostsView.hideLoading();</div><div class="line">    mAllPostsView.setAllPosts(objects);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AllPostsFragment的中的setAllPosts方法就是把查询到的Post的List通过RecycleView的Adapter的构造函数传递过去。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAllPosts</span><span class="params">(List&lt;Post&gt; objects)</span></span>&#123;</div><div class="line">    mRecyclerView.setAdapter(<span class="keyword">new</span> AllPostsRecyclerViewAdapter(getActivity(),objects));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一次查询就算是走了一遍。其实整个过程和之前的例子是一模一样的。类图如下所示。</p>
<p><img src="..\Android还踢球app总结（三）\find all games class diagram.jpg"></p>
<h3 id="4-其他功能模块"><a href="#4-其他功能模块" class="headerlink" title="4. 其他功能模块"></a>4. 其他功能模块</h3><p>发起组织功能模块中类图如下图所示。</p>
<p><img src="..\Android还踢球app总结（三）\lauch a game class.png"></p>
<p>查询一个帖子详情功能的类图如下所示。</p>
<p><img src="..\Android还踢球app总结（三）\a game details.png"></p>
<p>这两者的设计、运行过程和找组织功能都一样，就不再详细叙述了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇介绍一下用到的开发模式。做这款软件时对于Android开发的了解仅仅只是看了郭霖大神的《第一行代码》，对于开发模式，或者说软件架构什么的都不了解。不过之前帮一个老师做类似校园BBS时，听他介绍过MVC，自己也查过一些关于MVC的资料。其目的是为了让各个模块儿互相更独立，高内聚低耦合。而&lt;strong&gt;M(Model)模型&lt;/strong&gt;、&lt;strong&gt;V(View)视图&lt;/strong&gt;、&lt;strong&gt;C(Controller)控制器&lt;/strong&gt;，应该是&lt;strong&gt;数据访问&lt;/strong&gt;、&lt;strong&gt;界面展示&lt;/strong&gt;、&lt;strong&gt;业务逻辑&lt;/strong&gt;三者的对应，正是一个软件不可少的东西。&lt;/p&gt;
&lt;h3 id=&quot;1-预备知识&quot;&gt;&lt;a href=&quot;#1-预备知识&quot; class=&quot;headerlink&quot; title=&quot;1. 预备知识&quot;&gt;&lt;/a&gt;1. 预备知识&lt;/h3&gt;&lt;p&gt;在敲代码之前，是先做了一些功能模块的划分，再做了UI，然后就在想用什么方式组织代码，可以提高效率。同时也在想如果是在公司做的话，会用什么方式分配这些不同模块、不同功能的代码任务。之后就在网上查到了应用于Android的MVP模式。它其实是从MVC模式演化而来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Android中Activity或者Fragment是用来做界面展示的，但是其生命周期对于整个软件是很关键的，所以会将一些业务逻辑写在Activity中，这样做很直观，但是其代价就是Activity会越来越臃肿……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android还踢球app总结（二）</title>
    <link href="http://yoursite.com/2017/01/03/Android%E8%BF%98%E8%B8%A2%E7%90%83app%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2017/01/03/Android还踢球app总结（二）/</id>
    <published>2017-01-03T07:43:14.000Z</published>
    <updated>2017-01-17T10:33:24.415Z</updated>
    
    <content type="html"><![CDATA[<p>第二篇介绍下界面设计及其实现。当然是想遵循Material Design。但它不是单单的大色块，或者是某些控件的应用。还有层级、动画之类的设计。我做的呢其实是很简单，而且主要是copy了好多介绍这类设计的demo。比如Google出的一个<a href="https://github.com/chrisbanes/cheesesquare" target="_blank" rel="external">Cheesesquare</a>，这个主要是介绍<strong>Android Design library</strong>。然后几乎就按照这样的设计做的。。目前实现了<strong>找组织</strong>模块。<br><a id="more"></a></p>
<h2 id="1-浏览帖子"><a href="#1-浏览帖子" class="headerlink" title="1. 浏览帖子"></a>1. 浏览帖子</h2><p>难点或者说比较新的东西就在这块。<br>实现效果如下图所示。</p>
<p><img src="..\Android还踢球app总结（二）\find_all_games.jpg" width="30%" height="30%"></p>
<p>用到的一些控件如下图所示。有<strong>CoordinatorLayout</strong>(design包)、<strong>AppBarLayout</strong>(design包)、<strong>Toolbar</strong>(v7包)、<strong>TabLayout</strong>(design包)、<strong>ViewPager</strong>(v4包)、Fragments、<strong>RecyclerView</strong>(v7包)、<strong>FloatingActionButton</strong>(design包)。它们的位置和层级关系如下。</p>
<p><img src="..\Android还踢球app总结（二）\find_all_games_wiget.jpg" width="30%" height="30%"></p>
<p><img src="..\Android还踢球app总结（二）\find_all_games_wiget2.jpg" width="30%" height="30%"></p>
<p>上边的不是最顶层的layout。MainActivity的布局，最外边是<strong>DrawerLayout</strong>，然后里边include了上边的布局，以及一个<strong>NavigationView</strong>。DrawerLayout和NavigationView提供了侧滑菜单。这里就不介绍了。主要介绍下上边的这个布局。</p>
<h3 id="1-1-CoordinatorLayout"><a href="#1-1-CoordinatorLayout" class="headerlink" title="1.1 CoordinatorLayout"></a>1.1 CoordinatorLayout</h3><p>CoordinatorLayout能够让AppBarLayout和底下的内容同步的移动。还有其他的作用，在<a href="https://android-developers.googleblog.com/2015/05/android-design-support-library.html" target="_blank" rel="external">这里</a>有更多的介绍；</p>
<h3 id="1-2-AppBarLayout"><a href="#1-2-AppBarLayout" class="headerlink" title="1.2 AppBarLayout"></a>1.2 AppBarLayout</h3><p> AppBarLayout应该和CoordinatorLayout一起使用，并且有一些同级的控件，这样就可以一起滑动；上边那篇文章中也有CoordinatorLayout和AppBarLayout以及Toolbar，还有RecyclerView的应用介绍。</p>
<h3 id="1-3-Toolbar"><a href="#1-3-Toolbar" class="headerlink" title="1.3 Toolbar"></a>1.3 Toolbar</h3><p>Toolbar是action bar的一个泛化(generalization)，应该有很多种用法，这里只是用来代替action bar的。<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2006.html" target="_blank" rel="external">这里</a>有Toolbar详细的介绍。</p>
<p>自己踩过的坑：首先要将style.xml中resources下style里AppTheme的<strong>windowActionBar</strong>设置为false，<strong>windowNoTitle</strong>设置为true；设置左边的汉堡图标时，按照<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1118/2006.html" target="_blank" rel="external">这里</a>介绍的用Toolbar的<strong>setNavigationIcon</strong>就可以，而Cheesesquare的demo里还是先找到了ActionBar的实例，再用<strong>setHomeAsUpIndicator</strong>设置图标的；</p>
<h3 id="1-4-TabLayout"><a href="#1-4-TabLayout" class="headerlink" title="1.4 TabLayout"></a>1.4 TabLayout</h3><p>TabLayout也是在<a href="https://android-developers.googleblog.com/2015/05/android-design-support-library.html" target="_blank" rel="external">这里</a>先介绍的。</p>
<p>我实现时是和下边的ViewPager一起的。就像该文章介绍的，获得TabLayout后，不用<strong>addTab()</strong>了，调用<strong>setupWithViewPager</strong>，和<strong>setTabsFromPagerAdapter</strong>这两个方法，将TabLayout和ViewPager绑定，并从ViewPager中获得相应的tab的名称；</p>
<h3 id="1-5-ViewPager"><a href="#1-5-ViewPager" class="headerlink" title="1.5 ViewPager"></a>1.5 ViewPager</h3><p>ViewPager允许用户左右滑动以显示不同的数据，需要实现一个<strong>PagerAdapter</strong>产生要显示的数据页面，而ViewPager常常和Fragment一块使用，可以方便的提供和管理每个页面的生命周期，相应的提供的Adapter有<strong>FragmentPagerAdapter</strong>和<strong>FragmentStatePagerAdapter</strong>，后者更适合具有更多的页面的情况（来自官方文档）。</p>
<p>实现时，是建一个FragmentAdapter继承自FragmentPagerAdapter，在构造方法中传入titles（List &lt;String &gt;）(就是tabs的名称)，其中有个方法就是<strong>getPageTitle</strong>，根据postion，返回titles中相应的title，即tab的名字；然后创建一个fragments（List &lt;Fragment&gt;）的List，加入相应的Fragment，同样是在FragmentAdapter的构造方法中传入fragments；这样adapter算是闹好了，最后调用ViewPager的<strong>setAdapter</strong>，传入上边的adapter即可；</p>
<h3 id="1-6-RecyclerView"><a href="#1-6-RecyclerView" class="headerlink" title="1.6 RecyclerView"></a>1.6 RecyclerView</h3><p>RecyclerView应该是一种更“高级”的ListView，网上也有很多教程，如<a href="http://www.jianshu.com/p/16712681731e" target="_blank" rel="external">这个</a>和<a href="http://www.cnblogs.com/kimmy/p/4556240.html" target="_blank" rel="external">这个</a>。</p>
<p>实现时，在Fragment中，inflate的布局中就只包含一个RecyclerView的控件（之后增加了一个SwipeRefreshLayout控件，把RecycView包住，但是有时候下拉刷新时总感觉很别扭，上下滑动时没想要刷新，但就会触动刷新，体验不好，找问题？？？）。在Fragment中设置布局管理器<strong>setLayoutManager</strong>，以及适配器<strong>setAdapter</strong>。</p>
<p>主要是Adapter的设计。新建一个RecyclerViewAdapter继承自<strong>RecyclerView.Adapter<recyclerview.viewholder></recyclerview.viewholder></strong>。在构造函数中，可以把数据posts（List &lt;Post&gt;）（Post是帖子的实体类）的List传进来。此外还有三个重要的函数<strong>onCreateViewHolder</strong>，<strong>onBindViewHolder</strong>，<strong>getItemViewType</strong>，以及两个<strong>ViewHolder</strong>：<strong>NormalItemHolder</strong>，<strong>GroupItemHolder</strong>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NormalItemHolder，不带标题（第几周），一个CardView，里边包含其他控件</span></div><div class="line"><span class="comment">// 它是继承自RecyclerView的ViewHolder，构造函数传的参数就是上一行所说布局的view</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalItemHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</div><div class="line">    CircleImageView cardUserIcon;</div><div class="line">    TextView cardUserName;</div><div class="line">    TextView cardInfo;</div><div class="line">    TextView cardRemark;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> View mView;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalItemHolder</span><span class="params">(<span class="keyword">final</span> View itemView)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(itemView);</div><div class="line">        cardUserIcon = (CircleImageView) itemView.findViewById(R.id.card_user_avatar);</div><div class="line">        cardUserName = (TextView) itemView.findViewById(R.id.card_user_name);</div><div class="line">        cardInfo = (TextView) itemView.findViewById(R.id.card_info);</div><div class="line">        cardRemark = (TextView) itemView.findViewById(R.id.card_remark);</div><div class="line">        mView = itemView;</div><div class="line">        itemView.findViewById(R.id.card_item_container).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                showDetail(itemView, getAdapterPosition());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// GroupItemHolder只比NormalItemHolder多一个标题，所以直接继承NormalItemHolder就行，再额外获取其标题的实例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupItemHolder</span> <span class="keyword">extends</span> <span class="title">NormalItemHolder</span> </span>&#123;</div><div class="line">    TextView cardTitle;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupItemHolder</span><span class="params">(View itemView)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(itemView);</div><div class="line">        cardTitle = (TextView) itemView.findViewById(R.id.card_title);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// getItemViewType方法根据项目元素的position，返回其ViewHolder的类型，NormalItemHolder，或者GroupItemHolder</span></div><div class="line"><span class="comment">// 这里的逻辑是，首先，第一个项目元素一定是带标题的，其次检查之后每个项目元素的约球的时间（通过查询从构造函数中传过来的posts的相应位置的post）是全年的第几周，查看是否和上一条项目元素相同，若相同就是NormalItemViewHolder，否则是GroupItemViewHolder</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">    <span class="comment">//第一个要第几周</span></div><div class="line">    <span class="keyword">if</span> (position == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> GROUP_ITEM;</div><div class="line">    <span class="comment">//判断一个card要用哪一个布局</span></div><div class="line">    <span class="keyword">int</span> current = Util.getWeekOfYear(postList.get(position).getDate());</div><div class="line">    <span class="keyword">int</span> prevIndex = position - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> prev = Util.getWeekOfYear(postList.get(prevIndex).getDate());</div><div class="line">    <span class="keyword">boolean</span> isDifferent;</div><div class="line">    <span class="keyword">if</span> (current == prev) &#123;</div><div class="line">        isDifferent = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        isDifferent = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> isDifferent ? GROUP_ITEM : NORMAL_ITEM;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// onCreateViewHolder函数接受一个viewGroup，及从getItemViewType函数得到的相应的viewType，根据viewType放回相应项目元素的ViewHolder，NormalItemHolder或者GroupItemHolder</span></div><div class="line"><span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(viewGroup viewGroup, <span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (viewType == NORMAL_ITEM) &#123;</div><div class="line">        View view =</div><div class="line">                LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.all_posts_item_card, viewGroup, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NormalItemHolder(view);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        View view =</div><div class="line">                LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.all_posts_title_item_card, viewGroup, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GroupItemHolder(view);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// onBindViewHolder函数根据项目元素的viewHolder和其postion，将posts中对应的post的数据加入其viweHolder中</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">final</span> <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">    Post post = postList.get(position);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == post)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> (viewHolder <span class="keyword">instanceof</span> GroupItemHolder) &#123;</div><div class="line">        bindGroupItem(post, (GroupItemHolder) viewHolder);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        NormalItemHolder holder = (NormalItemHolder) viewHolder;</div><div class="line">        bindNormalItem(post, holder);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RecyclerView和ListView类似，所以上边的代码都是针对每个项目元素而言的。至于有多少个应该就根据Adapter的构造函数中传递的数据List中项目的个数而定了吧？<br>另，<strong>ViewGroup</strong>，<strong>ViewHolder</strong>的概念？？？</p>
<h2 id="2-发帖"><a href="#2-发帖" class="headerlink" title="2. 发帖"></a>2. 发帖</h2><p>发帖的界面就简单多了。如下图所示。</p>
<p><img src="..\Android还踢球app总结（二）\launch_a_game.jpg" width="30%" height="30%"></p>
<p>一个<strong>ScrollView</strong>包住里边的AppBarLayout、各种TextView、ImageView。当然是ScrollView下是一个LinearLayout，里边在包括AppBarLayout，及4、5个LinearLayout，然后LinearLayout再包括具体的内容。</p>
<p>日期的选择是用的<strong>DatePickerDialog</strong>，时间的选择用的<strong>TimePickerDialog</strong>，赛制的选择用的<strong>AlertDialog.Builder</strong>。</p>
<p>填写手机号是个EditText控件，有个方法<strong>setError</strong>，挺好。</p>
<p><img src="..\Android还踢球app总结（二）\lauch_a_game2.png" width="30%" height="30%"></p>
<p>另外就是地点的选择，用的高德地图。自己弄得界面很丑，不过搜索、放大啥的都可以用。点击图上的某个地点，有个<strong>onMarkerClick</strong>回调方法，可以获取该地点的经纬度、地址描述，把这些三个信息再返回给发起组织界面的地点的TextView。</p>
<p><img src="..\Android还踢球app总结（二）\determine_a_location.png" width="30%" height="30%"></p>
<p>有个bug是，打开软件，自动定位，然后查询所在城市当天当时之后的约球信息。所以自己发帖时应该只能够选择所在城市的地点。但是在现在搜索是可以搜索到其他城市的地点的。怎样限制搜索在一个城市内呢？？？</p>
<h2 id="3-查看详情"><a href="#3-查看详情" class="headerlink" title="3. 查看详情"></a>3. 查看详情</h2><p>查看详情的界面也比较简单。</p>
<p><img src="..\Android还踢球app总结（二）\game_detail.jpg" width="30%" height="30%"></p>
<p>有个问题，<a href="http://docs.heweather.com/224292" target="_blank" rel="external">和风天气</a>的天气状况一共有51种，而软件中没有采用和风提供的图标，是在<a href="https://material.uplabs.com/posts/material-design-weather-icon-set" target="_blank" rel="external">MaterialUp</a>找的一套图标，而只有24个，所以有的天气情况还没有配相应的图标。</p>
<p>地图上的“在这儿题“，就是一个Marker。</p>
<p>带我去（导航功能）、加入组织、举报功能、跳转微信、电话、短信的功能 还没有实现……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二篇介绍下界面设计及其实现。当然是想遵循Material Design。但它不是单单的大色块，或者是某些控件的应用。还有层级、动画之类的设计。我做的呢其实是很简单，而且主要是copy了好多介绍这类设计的demo。比如Google出的一个&lt;a href=&quot;https://github.com/chrisbanes/cheesesquare&quot;&gt;Cheesesquare&lt;/a&gt;，这个主要是介绍&lt;strong&gt;Android Design library&lt;/strong&gt;。然后几乎就按照这样的设计做的。。目前实现了&lt;strong&gt;找组织&lt;/strong&gt;模块。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JS高程（三）</title>
    <link href="http://yoursite.com/2016/11/14/JS%E9%AB%98%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/11/14/JS高程（三）/</id>
    <published>2016-11-14T03:08:26.000Z</published>
    <updated>2016-12-22T09:23:24.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第4章-变量、作用域和内存问题"><a href="#第4章-变量、作用域和内存问题" class="headerlink" title="第4章 变量、作用域和内存问题"></a>第4章 变量、作用域和内存问题</h2><h3 id="1-基本类型值和引用类型值"><a href="#1-基本类型值和引用类型值" class="headerlink" title="1. 基本类型值和引用类型值"></a>1. 基本类型值和引用类型值</h3><p>注意区别：ECMAScript有6种<strong>数据类型</strong>（5种基本数据类型，1种复杂数据类型）；ECMAScript变量可能包含2种不同<strong>数据类型的值</strong>，即<br><strong>基本类型值</strong> 是指简单的数据段<br><strong>引用类型值</strong>是指那些可能由多个值构成的对象</p>
<p>5种基本数据类型：Undefined、Null、Boolean、Number、String是<strong>基本类型值</strong>，是<strong>按值访问</strong>的，因为可以操作保存在变量中的实际的值。<br>1种复杂数据类型：Object是<strong>引用类型值</strong>，是<strong>按引用访问</strong>的，因为操作对象时，实际上是在操作对象的引用而不是实际的对象。<br><a id="more"></a></p>
<h4 id="1-1-复制变量值"><a href="#1-1-复制变量值" class="headerlink" title="1.1 复制变量值"></a>1.1 复制变量值</h4><ul>
<li><p>基本类型值的复制</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> num2 = num1;</div><div class="line">alert(num1); <span class="comment">// 5</span></div><div class="line">alert(num2); <span class="comment">// 5</span></div><div class="line">num1 = <span class="number">10</span>;</div><div class="line">alert(num1); <span class="comment">// 10</span></div><div class="line">alert(num2); <span class="comment">// 5    num1和num2的值各一份 互不影响</span></div></pre></td></tr></table></figure>
</li>
<li><p>引用类型值的复制</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">obj1.name = <span class="string">"HeiHei"</span>;</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line">alert(obj1.name); <span class="comment">// "HeiHei"</span></div><div class="line">alert(obj2.name); <span class="comment">// "HeiHei"</span></div><div class="line">obj1.name = <span class="string">"DaShuaiBi"</span>;</div><div class="line">alert(obj1.name); <span class="comment">// "DaShuaiBi"</span></div><div class="line">alert(obj2.name); <span class="comment">// "DaShuaiBi"  与基本类型值的区别 obj1和obj2存的实际是指针，指向同一个对象</span></div><div class="line"><span class="comment">// 怎样画图 插图？</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-2-函数传递参数"><a href="#1-2-函数传递参数" class="headerlink" title="1.2 函数传递参数"></a>1.2 函数传递参数</h4><p>ECMAScript中所有函数的参数都是<strong>按值传递</strong>的。访问变量有按值和按引用两种方式，而参数只能按值传递。</p>
<ul>
<li><p>向参数传递基本类型值</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    num += <span class="number">10</span>;</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">&#125;    </div><div class="line"></div><div class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> result = addTen(count);</div><div class="line">alert(count); <span class="comment">// 20，是按值传递的，count并没有变</span></div><div class="line">alert(result); <span class="comment">// 30</span></div></pre></td></tr></table></figure>
</li>
<li><p>向参数传递引用类型值</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    obj.name = <span class="string">"HeiHei"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name); <span class="comment">// "HeiHei"</span></div><div class="line"><span class="comment">// 按照上边的代码，在局部作用域中修改过的对象会在全局作用域中反映出来，就说明参数是按引用传递的？</span></div><div class="line"><span class="comment">// 这是不对的，看下边的</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    obj.name = <span class="string">"HeiHei"</span>;</div><div class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name = <span class="string">"DaShuaiBi"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line">alert(person.name); <span class="comment">// "HeiHei" 这里并不是"DaShuaiBi"</span></div><div class="line"><span class="comment">// 如果person是按引用传递的，那么person将会自动被修改为指向其name属性为"DaShuaiBi"的新对象</span></div><div class="line"><span class="comment">// 在函数内部修改了参数的值，但原始的引用仍然保持不变</span></div><div class="line"><span class="comment">// 当在函数内部重写obj时，这个变量引用的就是一个局部对象了，在函数执行完毕后立即被销毁</span></div><div class="line"><span class="comment">// 画图更能表现。。。。。</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-检测类型"><a href="#1-3-检测类型" class="headerlink" title="1.3 检测类型"></a>1.3 检测类型</h4><p><strong>typeof 操作符</strong>用来检测一个变量是不是基本数据类型。（注意typeof用来检测null时会返回object。null是一个空的对象的引用，一个指向空的对象的指针？ <strong>引用</strong>和<strong>指针</strong>在JS中差不多是一个意思？）</p>
<p><strong>instanceof 操作符</strong>用来检测引用类型的值。</p>
<p>typeof操作符检测引用类型的值（对象）时，会返回object，而我们不仅想知道这个值是object，还想知道它<strong>是什么类型的对象</strong>，这时，要用instanceof操作符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 语法；具体还得看constructor；不像 typeof 变量名，而是 变量名 instanceof XXX</span></div><div class="line">result = variable <span class="keyword">instanceof</span> <span class="keyword">constructor</span></div><div class="line">// 例子</div><div class="line">alert(person instanceof Object);</div><div class="line">alert(colors instanceof Array);</div><div class="line">alert(pattern instanceof RegExp);</div></pre></td></tr></table></figure></p>
<h3 id="2-执行环境及作用域"><a href="#2-执行环境及作用域" class="headerlink" title="2. 执行环境及作用域"></a>2. 执行环境及作用域</h3><p>几个概念：执行环境、变量对象、全局执行环境、函数的执行环境、作用域链</p>
<ul>
<li><strong>执行环境</strong>：（环境）定义了变量或函数有权访问的其他数据，决定了他们各自的行为。</li>
<li><strong>变量对象</strong>：每个执行环境都有一个变量对象，环境中定义的变量和函数都保存在这个对象中。</li>
<li><strong>全局执行环境</strong>：最外围的一个执行环境。如Web浏览器中就是window对象。</li>
<li><strong>函数的执行环境</strong>：每个函数都有自己的执行环境。</li>
<li><strong>作用域链</strong>：代码在<strong>执行环境</strong>中执行时，会创建<strong>变量对象</strong>的一个作用域链。用来保证对执行环境有权访问的所有变量和函数（即变量对象中保存的变量和函数）<strong>有序访问</strong>。作用域链的前端始终都是当前执行的代码所在的执行环境的变量对象；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</li>
</ul>
<p>一个问题：<strong>没有块级作用域</strong>。前一篇提到过，for循环中计数的i。块级作用域应该就是{ }中的代码吧。</p>
<p>另一个问题，前一篇也提到过，声明变量时用var操作符和不用var操作符。前者的变量会自动被添加到<strong>最接近的环境</strong>（执行环境）中，后者的变量会被添加<strong>全局执行环境</strong>中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例子1 </span></div><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> tempColor = anotherColor;</div><div class="line">        anotherColor = color;</div><div class="line">        color = tempColor;</div><div class="line">        <span class="comment">// 这里可以访问 tempColor、anotherColor、color；这三个在swapColor()函数执行环境的变量对像的作用域链上能找到</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    swapColor();</div><div class="line">    <span class="comment">// 这里可以访问 anotherColor、color；这两个在changeColor()函数执行环境的变量对象的作用域链上能找到，tempColor找不到了。</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">changeColor();</div><div class="line"><span class="comment">// 这里只能访问 color；这个在全局执行环境的变量对象的作用域链上能找到，tempColor和anotherColor找不到了。</span></div><div class="line"></div><div class="line">alert(<span class="string">"Color is now "</span> + color); <span class="comment">// "Color is now red"</span></div><div class="line"></div><div class="line"><span class="comment">// 例子2 查询标识符</span></div><div class="line"><span class="comment">// 情形1</span></div><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getColor()); <span class="comment">// "blue"</span></div><div class="line"><span class="comment">// 情形2</span></div><div class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> color = <span class="string">"red"</span>;</div><div class="line">    <span class="keyword">return</span> color;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getColor()); <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<h3 id="3-垃圾收集"><a href="#3-垃圾收集" class="headerlink" title="3. 垃圾收集"></a>3. 垃圾收集</h3><ul>
<li><p>JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。C和C++开发人员需要手动跟踪内存的使用情况（free(xxx)?）。</p>
</li>
<li><p>两种垃圾收集算法。<strong>标记清除</strong>：给当前不使用的值加上标记，然后再回收其内存；<strong>引用计数</strong>：跟踪记录所有值被引用的次数。 代码中有循环引用时，引用计数算法就会出问题。现在几乎没有使用引用计数的了。</p>
</li>
<li><p>怎样优化内存占用？想法：为执行中的代码只保存必要的数据。做法：<strong>解除引用</strong>：一旦数据不再有用，通过将其值设置为null来释放其引用。适用于<strong>全局变量</strong>和<strong>全局对象的属性</strong>。<strong>局部变量</strong>会在离开执行环境时自动被解除引用。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//例子</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> localPerson = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    localPerson.name = name;</div><div class="line">    <span class="keyword">return</span> localPerson;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> globalPerson = createPerson(<span class="string">"DaShuaiBi"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 手工解除globalPerson的引用</span></div><div class="line">globalPerson = <span class="literal">null</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第4章-变量、作用域和内存问题&quot;&gt;&lt;a href=&quot;#第4章-变量、作用域和内存问题&quot; class=&quot;headerlink&quot; title=&quot;第4章 变量、作用域和内存问题&quot;&gt;&lt;/a&gt;第4章 变量、作用域和内存问题&lt;/h2&gt;&lt;h3 id=&quot;1-基本类型值和引用类型值&quot;&gt;&lt;a href=&quot;#1-基本类型值和引用类型值&quot; class=&quot;headerlink&quot; title=&quot;1. 基本类型值和引用类型值&quot;&gt;&lt;/a&gt;1. 基本类型值和引用类型值&lt;/h3&gt;&lt;p&gt;注意区别：ECMAScript有6种&lt;strong&gt;数据类型&lt;/strong&gt;（5种基本数据类型，1种复杂数据类型）；ECMAScript变量可能包含2种不同&lt;strong&gt;数据类型的值&lt;/strong&gt;，即&lt;br&gt;&lt;strong&gt;基本类型值&lt;/strong&gt; 是指简单的数据段&lt;br&gt;&lt;strong&gt;引用类型值&lt;/strong&gt;是指那些可能由多个值构成的对象&lt;/p&gt;
&lt;p&gt;5种基本数据类型：Undefined、Null、Boolean、Number、String是&lt;strong&gt;基本类型值&lt;/strong&gt;，是&lt;strong&gt;按值访问&lt;/strong&gt;的，因为可以操作保存在变量中的实际的值。&lt;br&gt;1种复杂数据类型：Object是&lt;strong&gt;引用类型值&lt;/strong&gt;，是&lt;strong&gt;按引用访问&lt;/strong&gt;的，因为操作对象时，实际上是在操作对象的引用而不是实际的对象。&lt;br&gt;
    
    </summary>
    
    
      <category term="JS基础" scheme="http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JS高程（二）</title>
    <link href="http://yoursite.com/2016/11/03/JS%E9%AB%98%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/11/03/JS高程（二）/</id>
    <published>2016-11-03T03:50:23.000Z</published>
    <updated>2016-11-14T10:01:00.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第3章-基本概念"><a href="#第3章-基本概念" class="headerlink" title="第3章 基本概念"></a>第3章 基本概念</h2><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><ul>
<li><p>区分大小写</p>
</li>
<li><p>多行注释</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 这两行的星星是没有必要的，</div><div class="line"> * 但就是好看啊。</div><div class="line"> */</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-关键字和保留字"><a href="#2-关键字和保留字" class="headerlink" title="2. 关键字和保留字"></a>2. 关键字和保留字</h3><p>这两个的异同是什么呢？<br>异：</p>
<blockquote>
<p>关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等</p>
<p>保留字有可能将来被用作关键字</p>
</blockquote>
<p>同：都是小写的。。</p>
<h3 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h3><a id="more"></a>
<ul>
<li><p>变量是<strong>松散类型</strong>，可以用来保存任何类型的数据。</p>
</li>
<li><p>用 var 定义的变量将成为该变量作用域中的<strong>局部变量</strong>；省略 var操作符，创建的是<strong>全局变量</strong>。（对函数而言？）</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> message = <span class="string">"hi"</span>; <span class="comment">// 局部变量</span></div><div class="line">&#125;</div><div class="line">test();</div><div class="line">alert(message); <span class="comment">// 错误！</span></div></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  message = <span class="string">"hi"</span>; <span class="comment">// 全局变量</span></div><div class="line">&#125;</div><div class="line">test();</div><div class="line">alert(message); <span class="comment">// "hi"</span></div></pre></td></tr></table></figure>
</li>
<li><p>可用一条语句定义多个变量，用<strong>逗号</strong>分开。（可以初始化也可以不初始化）</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="string">"hi"</span>,   </div><div class="line">    age,</div><div class="line">    found = <span class="literal">false</span>;  <span class="comment">// 这里的换行和缩进是不必要的，但是好看啊。</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h3><p>5种简单数据类型（基本数据类型）：<strong>Undefined</strong>、<strong>Null</strong>、<strong>Boolean</strong>、<strong>Number</strong>、<strong>String</strong>。<br>1种复杂数据类型：<strong>Object</strong>。</p>
<blockquote>
<p>ECMAScript中，所有值最终都将是上述6种数据类型之一。</p>
</blockquote>
<p>说XX类型时，首字母都大写，但Undefined、Null、Boolean的值都是小写。</p>
<h4 id="4-1-typeof操作符"><a href="#4-1-typeof操作符" class="headerlink" title="4.1 typeof操作符"></a>4.1 typeof操作符</h4><ul>
<li><p>用来检测给定变量的数据类型。</p>
</li>
<li><p>返回值有：”undefined”、”boolean”、”string”、”number”、”object”(如果变量是对象或null)、”fucntion”。（也是6种，但和上边的6中数据类型不完全对应）</p>
<blockquote>
<p>null被认为是一个空的对象引用，所以返回object</p>
<p>函数在ECMAScript中是对象，但又有其特殊性，所以返回function</p>
</blockquote>
</li>
<li><p>返回值都是<strong>字符串</strong>类型的</p>
</li>
<li><p>typeof是一个<strong>操作符</strong>，而<strong>不是</strong>一个<strong>函数</strong>，<strong>不是</strong>一个<strong>方法</strong>。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message;</div><div class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// 正确的写法；"undefined"  </span></div><div class="line">alert(<span class="keyword">typeof</span>(message)); <span class="comment">// 函数的话，有可能要传参，虽然能返回"undefined"，但不好</span></div><div class="line">alert(message.typeof); <span class="comment">// 按照方法来写，错误</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-2-Undefined-类型"><a href="#4-2-Undefined-类型" class="headerlink" title="4.2 Undefined 类型"></a>4.2 Undefined 类型</h4><ul>
<li><p>只有一个值：undefined 。</p>
</li>
<li><p>使用var声明变量，但未初始化，这个变量的值就是undefined。</p>
</li>
<li><p>尚未声明（定义）的变量，是不能对其操作的，但对其执行typeof操作符，返回”undefined”。因此<strong>建议</strong>：</p>
<blockquote>
<p>显示地初始化变量，这样当typeof操作符返回”undefined”值时，就知道被检测的变量是还没有被声明，而不是尚未初始化。</p>
</blockquote>
</li>
</ul>
<h4 id="4-3-Null-类型"><a href="#4-3-Null-类型" class="headerlink" title="4.3 Null 类型"></a>4.3 Null 类型</h4><ul>
<li><p>只有一个值：null 。</p>
</li>
<li><p>null和Object的关系：null表示一个空对象指针。所以typeof时，会返回”object”。</p>
</li>
<li><p>null和undefined关系：undefined值是派生自null的值的。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>但是用全等的话就不行了。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">null</span> === <span class="literal">undefined</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>相等（==）会进行类型转换，全等（===）类型也要相同才等。</p>
</li>
<li>null和Object及undefined另一个关系：没有必要把一个变量的值显式地设置为undefined；但要把还没有来得及保存对象的变量设置为null，可以体现null作为空对象指针的惯例。  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message = <span class="literal">undefined</span>; <span class="comment">// 没有必要</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> student = <span class="literal">null</span>; <span class="comment">//student准备存放对象，但现在还不知道要存的具体内容。</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 一些操作……</div><div class="line"> */</div><div class="line">student = &#123;<span class="attr">id</span>:<span class="number">666</span>,<span class="attr">name</span>:<span class="string">"DaShuaiBi"</span>&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-4-Boolean-类型"><a href="#4-4-Boolean-类型" class="headerlink" title="4.4 Boolean 类型"></a>4.4 Boolean 类型</h4><ul>
<li><p>两个值：true和false 。</p>
</li>
<li><p><strong>转型函数</strong>Boolean()。是个<strong>函数</strong>。可对任何数据类型的值调用Boolean()函数。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Undefined类型</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>); <span class="comment">// false</span></div><div class="line"><span class="comment">// Null类型 和 Object类型</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>); <span class="comment">// false</span></div><div class="line"><span class="keyword">var</span> student = &#123;<span class="attr">id</span>:<span class="number">666</span>,<span class="attr">name</span>:<span class="string">"DaShuaiBi"</span>&#125;;</div><div class="line"><span class="built_in">Boolean</span>(student); <span class="comment">// true</span></div><div class="line"><span class="comment">// String类型</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="string">"HeiHeiHei"</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="string">""</span>); <span class="comment">// false</span></div><div class="line"><span class="comment">// Number类型</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="number">666</span>); <span class="comment">// true</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>); <span class="comment">// false</span></div><div class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
<li><p>流控制语句会自动执行相应的Boolean转换。</p>
</li>
</ul>
<h4 id="4-5-Number-类型"><a href="#4-5-Number-类型" class="headerlink" title="4.5 Number 类型"></a>4.5 Number 类型</h4><ul>
<li><p>十进制（<strong>Decimal</strong>）、八进制（<strong>Octal</strong>）、十六进制（<strong>Hexadecimal</strong>）</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">// 整数 十进制</span></div><div class="line"><span class="comment">// 八进制 Octal</span></div><div class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">// 八进制，十进制的56</span></div><div class="line"><span class="keyword">var</span> octalNum2 = <span class="number">079</span>; <span class="comment">// 不是八进制，0~7，忽略0，是十进制79</span></div><div class="line"><span class="keyword">var</span> octalNum3 = <span class="number">08</span>; <span class="comment">// 不是八进制，是十进制8</span></div><div class="line"><span class="comment">// 十六进制 Hexadecimal</span></div><div class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>; <span class="comment">// 十六进制的10</span></div><div class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">// 十六进制的31</span></div></pre></td></tr></table></figure>
<p>二进制（<strong>Binary</strong>）</p>
</li>
<li><p>浮点数值</p>
<blockquote>
<p>数值中必须包含一个小数点，小数点后必须至少有一位数字</p>
<p>保存浮点数值需要的内存空间是保存整数值的<strong>两倍</strong>，ECMAScript会不失时机地将浮点数值转换为整数</p>
<p>可以用e表示法，科学表示法 </p>
<p>浮点数数值的最高精度是<strong>17位</strong>小数，但在进行算术计算时其精确度远远不如整数</p>
</blockquote>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 不是0.3，而是0.30000000000000004；小数点后17位，15个0</span></div><div class="line">alert(<span class="number">0.15</span> + <span class="number">0.15</span>); <span class="comment">// 是0.3</span></div></pre></td></tr></table></figure>
<p>  对浮点数的建议：</p>
<blockquote>
<p>永远不要测试某个特定的浮点数值</p>
</blockquote>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (a + b == <span class="number">0.3</span>) &#123; <span class="comment">// 卡起码~</span></div><div class="line">    alert(<span class="string">"You got 0.3"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>数值范围：Number.MIN_VALUE ~ Number.MAX_VALUE；有正负无穷大-Infinity, Infinity；有个isFinite()<strong>函数</strong>。</p>
</li>
<li><p><strong>NaN</strong>是一个特殊的数值。NaN（Not a Number）。表示一个本来要返回数值的操作数未返回数值的情况（这样不会抛出错误）。（之前看ID3算法时，有个Java代码，其中要统计留下的数据中拥有某属性的总数作为分母，若是没有就为NaN，之后一直是NaN。这样虽然没报错，但其实还是不对。）</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">// NaN </span></div><div class="line">alert(<span class="number">5</span> / <span class="number">0</span>); <span class="comment">// Infinity</span></div><div class="line">alert(<span class="number">-5</span> / <span class="number">0</span>); <span class="comment">// -Infinity</span></div></pre></td></tr></table></figure>
<p>两个特点：</p>
<blockquote>
<p>任何涉及NaN的操作（例如NaN/10）都会返回NaN</p>
<p>NaN与任何值都不相等，包括NaN本身</p>
</blockquote>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">NaN</span> / <span class="number">10</span>); <span class="comment">// NaN</span></div><div class="line">alert(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>有个isNaN()<strong>函数</strong>。</p>
</li>
<li><p>把XX转换成数值，3种方式：<strong>转型函数</strong>Number()、专门用于<strong>把字符串转换成数值</strong>的parseInt()、parseFloat()</p>
<p><strong>Number()函数</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Undefined类型</span></div><div class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></div><div class="line"><span class="comment">// Null类型</span></div><div class="line"><span class="built_in">Number</span>(<span class="literal">null</span>); <span class="comment">// 0</span></div><div class="line"><span class="comment">// Boolean类型</span></div><div class="line"><span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">// 1</span></div><div class="line"><span class="built_in">Number</span>(<span class="literal">false</span>); <span class="comment">// 0</span></div><div class="line"><span class="comment">// 字符串类型</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">""</span>); <span class="comment">// 0 空字符串</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">"HeiHeiHei"</span>); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">"woca9453"</span>); <span class="comment">// NaN 第一个不是数字就不会是数字了</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">"9453"</span>); <span class="comment">// 9453</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">"017"</span>); <span class="comment">// 17 不会认为是八进制，会把0全部忽略</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">"00017"</span>); <span class="comment">// 17</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">"0xf"</span>); <span class="comment">// 15 会识别十六进制，转换为相应的十进制</span></div><div class="line"><span class="comment">// Object类型</span></div><div class="line"><span class="comment">// 先调用对象的valueOf()方法，再用上边的规则转化，若是NaN，再用对象的toString()方法，再用上边的规则转化</span></div></pre></td></tr></table></figure>
<p><strong>parseInt()函数</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 虽然是专门用来转换字符串，处理整数时用，但</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="literal">null</span>); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="literal">true</span>); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="literal">false</span>);<span class="comment">// NaN</span></div><div class="line"><span class="comment">// 处理字符串</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">""</span>); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"HeiHeiHei"</span>); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"9453"</span>); <span class="comment">// 9453</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"woca9453"</span>); <span class="comment">//NaN</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"9453woca"</span>); <span class="comment">// 9453</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"070"</span>); <span class="comment">// 56 会识别八进制 ECMAScript 3是这样的；ECMAScript 5就不会识别八进制了，认为是70，忽略0</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"00017"</span>); <span class="comment">// 17 </span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"0xf"</span>); <span class="comment">// 15 会识别十六进制</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"22.25"</span>); <span class="comment">// 22 会识别成整数，识别到第一个不是数字字符的地方就会停下来</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"3.125e7"</span>); <span class="comment">// 3 虽说是科学计数法的整数 但同上</span></div><div class="line"><span class="comment">// 更好的用法，转换时使用基数</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">2</span>); <span class="comment">// 2 二进制</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">8</span>); <span class="comment">// 8 八进制</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">10</span>); <span class="comment">// 10 十进制</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">16</span>); <span class="comment">// 16 十六进制</span></div><div class="line"><span class="comment">// 事实上，3、4、5……进制都行</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">3</span>); <span class="comment">// 3</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">4</span>); <span class="comment">// 4</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">5</span>); <span class="comment">// 5</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">36</span>); <span class="comment">// 36 </span></div><div class="line"><span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">37</span>); <span class="comment">// NaN 大于36之后的基数就都是NaN了</span></div></pre></td></tr></table></figure>
<p>  可以看到parseInt()和Number()对于一些数据是有区别的，<strong>应该只把parseInt()用于处理字符串整数</strong>，并且最好带上第二个参数，指明基数。</p>
<p><strong>parseFloat()函数</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 和parseInt()基本一样，不过是处理浮点数</span></div><div class="line"><span class="built_in">parseFloat</span>(<span class="string">"9453heiheihei"</span>); <span class="comment">// 9453</span></div><div class="line"><span class="built_in">parseFloat</span>(<span class="string">"22.25"</span>); <span class="comment">// 22.25</span></div><div class="line"><span class="built_in">parseFloat</span>(<span class="string">"22.25.35"</span>); <span class="comment">// 22.25</span></div><div class="line"><span class="built_in">parseFloat</span>(<span class="string">"09453.9453"</span>); <span class="comment">// 9453.9453</span></div><div class="line"><span class="built_in">parseFloat</span>(<span class="string">"0xf"</span>); <span class="comment">// 0 而不像parseInt()认为是15 因为parseFloat()只解析十进制数</span></div><div class="line"><span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>); <span class="comment">// 31250000 而不像parseInt()认为是3</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-6-String-类型"><a href="#4-6-String-类型" class="headerlink" title="4.6 String 类型"></a>4.6 String 类型</h4><ul>
<li><p>表示由零或多个16位Unicode字符组成的字符序列，即字符串。Uncicode字符是一个字符占2个字节，定长；UTF-8相当于是可变的Unicod字符。</p>
</li>
<li><p>每个字符串都有一个<strong>length</strong>的<strong>属性</strong>，但它是返回字符串的长度，而不是返回字符串占多少个字节。</p>
</li>
<li><p>String类型有一些特殊的<strong>字符字面量</strong>，也叫<strong>转义序列</strong>，用于表示非打印字符或其他用途。<br>比如\r（回车）、\n（换行）。回车换行来自于之前的打印机，回车：carriage return，换行：line feed。回车是把打印头定义在左边界，换行是把纸下移一行。看的<a href="http://www.ruanyifeng.com/blog/2006/04/post_213.html" target="_blank" rel="external">这里</a>。<br>转义序列只占一个字符：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="string">"This is the letter sigma: \u03a3."</span>;</div><div class="line">alert(text.length); <span class="comment">// 输出28 \u03a3 算是一个</span></div></pre></td></tr></table></figure>
</li>
<li><p>转换为字符串。两种方法：<strong>转型函数</strong>String()；<strong>几乎每个</strong>值都有的toString()<strong>方法</strong>。<br>xx的<strong>toString()</strong>方法</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Undefined类型的值undefined和Null类型的值null没有这个方法</span></div><div class="line"><span class="comment">// Boolean类型</span></div><div class="line"><span class="keyword">var</span> found = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> foundAsString = foud.toString(); <span class="comment">// 字符串"true"</span></div><div class="line"><span class="comment">// Number类型</span></div><div class="line"><span class="keyword">var</span> age = <span class="number">11</span>;</div><div class="line"><span class="keyword">var</span> ageAsString = age.toString(); <span class="comment">// 字符串"11"</span></div><div class="line"><span class="comment">// Number类型 可以给toString()方法传递一个参数：输出数值的基数</span></div><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">alert(num.toString()); <span class="comment">// "10"</span></div><div class="line">alert(num.toString(<span class="number">2</span>)); <span class="comment">// "1010"</span></div><div class="line">alert(num.toString(<span class="number">8</span>)); <span class="comment">// "12"</span></div><div class="line">alert(num.toString(<span class="number">10</span>)); <span class="comment">// "10"</span></div><div class="line">alert(num.toString(<span class="number">16</span>)); <span class="comment">// "a"</span></div><div class="line"><span class="comment">// 事实上，3、4、5……进制都行</span></div><div class="line">alert(num.toString(<span class="number">3</span>)); <span class="comment">// "101"</span></div><div class="line">alert(num.toString(<span class="number">4</span>)); <span class="comment">// "22"</span></div><div class="line">alert(num.toString(<span class="number">5</span>)); <span class="comment">// "20"</span></div><div class="line">alert(num.toString(<span class="number">11</span>)); <span class="comment">// "a" 之后大于11制的都是"a" 最大的基还是36</span></div><div class="line"><span class="comment">// Object类型</span></div><div class="line"><span class="keyword">var</span> student = &#123;<span class="attr">id</span>:<span class="number">666</span>,<span class="attr">name</span>:<span class="string">"DaShuaiBi"</span>&#125;;</div><div class="line">student.toString(); <span class="comment">// 返回"[object Object]" ？？？</span></div><div class="line">student.id.toString(); <span class="comment">// 返回"666"</span></div></pre></td></tr></table></figure>
<p><strong>String()函数</strong></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Undefined类型</span></div><div class="line"><span class="keyword">var</span> value1;</div><div class="line">alert(<span class="built_in">String</span>(value1)); <span class="comment">// 弹出 "undefined"</span></div><div class="line"><span class="comment">// Null类型</span></div><div class="line"><span class="keyword">var</span> value2 = <span class="literal">null</span>;</div><div class="line">alert(<span class="built_in">String</span>(value2)); <span class="comment">// 弹出 "null"</span></div><div class="line"><span class="comment">//Boolean类型、Number类型、Object类型再用这个函数时，都是调用该值的toString()方法。</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-7-Object-类型"><a href="#4-7-Object-类型" class="headerlink" title="4.7 Object 类型"></a>4.7 Object 类型</h4><ul>
<li><p>是一组数据和功能的集合。键值对、json、Java中所谓的bean实体类、Python中的字典……</p>
</li>
<li><p>可以通过执行new操作符后跟要创建的对象类型的名称来创建。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.name = <span class="string">"DaShuaiBi"</span>;</div><div class="line">o.age = <span class="number">11</span>;</div><div class="line"><span class="comment">//更深入一点的？</span></div></pre></td></tr></table></figure>
</li>
<li><p>Object的每个实例都具有下列属性和方法：constructor函数、hasOwnProperty(propertyName)、isProtypeOf(object)、propertyIsEnumerable(propertyName)、toLocaleString()、toString()、valueOf()。更具体的之后再讲。</p>
</li>
</ul>
<h3 id="5-操作符"><a href="#5-操作符" class="headerlink" title="5. 操作符"></a>5. 操作符</h3><h4 id="5-1-一元操作符"><a href="#5-1-一元操作符" class="headerlink" title="5.1 一元操作符"></a>5.1 一元操作符</h4><ul>
<li>递增和递减操作符 ++ –<br>++num和num++异同；<br>用于非数值时，将值转换为数字</li>
<li>一元加和减操作符 + - 放在数值前面<br>就是正负号……；<br>用于非数值时，将值转换为数字</li>
</ul>
<h4 id="5-2-位操作符"><a href="#5-2-位操作符" class="headerlink" title="5.2 位操作符"></a>5.2 位操作符</h4><p><strong>最好不要在JS中用位操作符？</strong></p>
<ul>
<li>按位非（NOT） ~<br>按位非的本质：操作数的<strong>负值减1</strong>。速度更快。这个有个<a href="http://www.cnblogs.com/hutaoer/p/3390710.html" target="_blank" rel="external">小例子</a>。</li>
<li>按位与（AND） &amp;</li>
<li>按位或（OR） |</li>
<li>按位异或（XOR） ^</li>
<li>左移 &lt;&lt;</li>
<li>有符号的右移 &gt;&gt;</li>
<li>无符号的右移 &gt;&gt;&gt;</li>
</ul>
<h4 id="5-3-布尔操作符"><a href="#5-3-布尔操作符" class="headerlink" title="5.3 布尔操作符"></a>5.3 布尔操作符</h4><ul>
<li>逻辑非 !<br>记住Boolean()函数对每种数据类型的结果，再取反就是了。<br><strong>Boolean(variable)</strong>和<strong>!! variable</strong> 是等价的。</li>
<li><p>逻辑与 &amp;&amp;<br>逻辑与是<strong>短路操作符</strong>，怎么说，看例子：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个操作数是true，才会对第二个操作数求值</span></div><div class="line"><span class="keyword">var</span> found = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> result = (found &amp;&amp; someUndefinedVariable); <span class="comment">//这里发生错误，someUndefinedVariable就没有声明</span></div><div class="line">alert(result); <span class="comment">// 不会执行</span></div><div class="line"><span class="comment">// 第一个操作数是flase，不会对第二个操作数求值，整个表达式一定是false</span></div><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> result = (found &amp;&amp; someUndefinedVariable); <span class="comment">// 不会发生错误，根本不管someUndefinedVariable</span></div><div class="line">alert(result); <span class="comment">// 弹出false</span></div></pre></td></tr></table></figure>
<p>有操作数不是布尔值时：（这里的第一个操作数都是true，要是是false的话，不管第二个操作数是啥，整个表达式都会返回false）</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> student = &#123;<span class="attr">name</span>:<span class="string">"DaShuaiBi"</span>,<span class="attr">age</span>:<span class="number">11</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Undefined类型 有一个操作数是undefined</span></div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">undefined</span>; <span class="comment">// 返回 undefined 不是说Boolean(undefined) 是false，然后再算</span></div><div class="line"></div><div class="line"><span class="literal">undefined</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// 返回 undefined 不是说Boolean(undefined)是false，然后整个都是false</span></div><div class="line"><span class="literal">undefined</span> &amp;&amp; <span class="literal">null</span>; <span class="comment">// 返回 undefined</span></div><div class="line"><span class="literal">undefined</span> &amp;&amp; <span class="literal">NaN</span>; <span class="comment">// 返回 undefined</span></div><div class="line"><span class="literal">undefined</span> &amp;&amp; <span class="number">0</span>; <span class="comment">// 返回 undefined</span></div><div class="line"><span class="literal">undefined</span> &amp;&amp; student; <span class="comment">// 返回 undefined</span></div><div class="line"></div><div class="line"><span class="comment">// Null类型 有一个操作数是null</span></div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">null</span>; <span class="comment">// 返回 null 不是说Boolean(null) 是false，然后再算</span></div><div class="line"></div><div class="line"><span class="literal">null</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// 返回 null 不是说Boolean(null) 是false，然后整个都是false</span></div><div class="line"><span class="literal">null</span> &amp;&amp; <span class="literal">undefined</span>; <span class="comment">// 返回 null</span></div><div class="line"><span class="literal">null</span> &amp;&amp; <span class="literal">NaN</span>; <span class="comment">// 返回 null</span></div><div class="line"><span class="literal">null</span> &amp;&amp; <span class="number">0</span>; <span class="comment">// 返回 null</span></div><div class="line"><span class="literal">null</span> &amp;&amp; student; <span class="comment">// 返回 null</span></div><div class="line"></div><div class="line"><span class="comment">// Number类型 </span></div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="number">9453</span>; <span class="comment">// 返回 9453 不是说Boole(9453) 是true，然后再算</span></div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="number">0</span>; <span class="comment">// 返回 0 不是说Boolean(0) 是false，然后再算</span></div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="literal">NaN</span>; <span class="comment">// 返回 NaN 不是说Boolean(NaN) 是false，然后再算</span></div><div class="line"></div><div class="line"><span class="number">0</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// 返回 0</span></div><div class="line"><span class="number">0</span> &amp;&amp; <span class="literal">undefined</span>; <span class="comment">// 返回 0</span></div><div class="line"><span class="number">0</span> &amp;&amp; <span class="literal">null</span>; <span class="comment">// 返回 0</span></div><div class="line"><span class="number">0</span> &amp;&amp; <span class="literal">NaN</span>; <span class="comment">// 返回 0</span></div><div class="line"><span class="number">0</span> &amp;&amp; student; <span class="comment">// 返回 0</span></div><div class="line"></div><div class="line"><span class="literal">NaN</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// 返回 NaN</span></div><div class="line"><span class="literal">NaN</span> &amp;&amp; <span class="literal">undefined</span>; <span class="comment">// 返回 NaN</span></div><div class="line"><span class="literal">NaN</span> &amp;&amp; <span class="literal">null</span>; <span class="comment">// 返回 NaN</span></div><div class="line"><span class="literal">NaN</span> &amp;&amp; <span class="number">0</span>; <span class="comment">// 返回 NaN</span></div><div class="line"><span class="literal">NaN</span> &amp;&amp; student; <span class="comment">// 返回 NaN</span></div><div class="line"></div><div class="line"><span class="comment">// 9453 &amp;&amp; xx 就相当于 true &amp;&amp; xx</span></div><div class="line"></div><div class="line"><span class="comment">// String 类型</span></div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="string">""</span>; <span class="comment">// 返回 "" 不是说Boolean("") 是false，然后再算</span></div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="string">"heiheihei"</span>; <span class="comment">// 返回 "heiheihei" 不是说Boolean("heiheihei") 是true，然后再算</span></div><div class="line"></div><div class="line"><span class="string">""</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// 返回 ""</span></div><div class="line"><span class="string">""</span> &amp;&amp; <span class="literal">undefined</span>; <span class="comment">// 返回 ""</span></div><div class="line"><span class="string">""</span> &amp;&amp; <span class="literal">null</span>; <span class="comment">// 返回 ""</span></div><div class="line"><span class="string">""</span> &amp;&amp; <span class="literal">NaN</span>; <span class="comment">// 返回 ""</span></div><div class="line"><span class="string">""</span> &amp;&amp; student; <span class="comment">// 返回 ""</span></div><div class="line"></div><div class="line"><span class="comment">// "heiheihei" &amp;&amp; xx 就相当于 true &amp;&amp; xx</span></div><div class="line"></div><div class="line"><span class="comment">// Object类型</span></div><div class="line"><span class="literal">true</span> &amp;&amp; student; <span class="comment">// 返回student1 不是说Boolean(student1) 是true，然后再算</span></div><div class="line"></div><div class="line"><span class="comment">// student1 &amp;&amp; xx 就相当于 true &amp;&amp; xx</span></div></pre></td></tr></table></figure>
</li>
<li><p>逻辑或 ||<br>逻辑或和逻辑非一样，也是<strong>短路操作符</strong>，看例子：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个操作数是true，就不会对第二个操作数求值了，整个表达式一定是true</span></div><div class="line"><span class="keyword">var</span> found = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> result = (found || someUndefinedVariable); <span class="comment">// 不会发生错误，根本不管someUndefinedVariable</span></div><div class="line">alert(result); <span class="comment">// 弹出true</span></div><div class="line"><span class="comment">// 第一个操作数是flase，才会对第二个操作数求值</span></div><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> result = (found || someUndefinedVariable); <span class="comment">// 这里发生错误，someUndefinedVariable就没有声明</span></div><div class="line">alert(result); <span class="comment">// 不会执行</span></div></pre></td></tr></table></figure>
<p>有操作数不是布尔值时，（若是第一个操作数是true，就不会管第二个操作数了，整个表达式的值一定是true）</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> student = &#123;<span class="attr">name</span>:<span class="string">"DaShuaiBi"</span>,<span class="attr">age</span>:<span class="number">11</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Undefined类型 </span></div><div class="line"><span class="literal">false</span> || <span class="literal">undefined</span>; <span class="comment">// 返回 undefined</span></div><div class="line"><span class="literal">undefined</span> || <span class="literal">false</span>; <span class="comment">// 返回 false</span></div><div class="line"></div><div class="line"><span class="literal">undefined</span> || <span class="literal">undefined</span>; <span class="comment">// 返回 undefined</span></div><div class="line"></div><div class="line"><span class="literal">null</span> || <span class="literal">undefined</span>; <span class="comment">// 返回 undefined</span></div><div class="line"><span class="literal">undefined</span> || <span class="literal">null</span>; <span class="comment">// 返回 null</span></div><div class="line"></div><div class="line"><span class="number">0</span> || <span class="literal">undefined</span>; <span class="comment">// 返回 undefined</span></div><div class="line"><span class="literal">undefined</span> || <span class="number">0</span>; <span class="comment">// 返回 0</span></div><div class="line"></div><div class="line"><span class="literal">NaN</span> || <span class="literal">undefined</span>; <span class="comment">// 返回 undefined</span></div><div class="line"><span class="literal">undefined</span> || <span class="literal">NaN</span>; <span class="comment">// 返回 NaN</span></div><div class="line"></div><div class="line"><span class="string">""</span> || <span class="literal">undefined</span>; <span class="comment">// 返回 undefined</span></div><div class="line"><span class="literal">undefined</span> || <span class="string">""</span>; <span class="comment">// 返回 ""</span></div><div class="line"></div><div class="line"><span class="number">9453</span> || <span class="literal">undefined</span>; <span class="comment">// 返回 9453 不是说Boolean(9453) 是true，然后返回true</span></div><div class="line"><span class="string">"heiheihei"</span> || <span class="literal">undefined</span>; <span class="comment">// 返回 "heiheihei" 不是说Boolean("heiheihei") 是true，然后再返回true</span></div><div class="line">student || <span class="literal">undefined</span>; <span class="comment">// 返回student 不是说Boolean(student)是true，然后再返回true</span></div><div class="line"><span class="literal">undefined</span> || <span class="number">9453</span>; <span class="comment">// 返回 9453</span></div><div class="line"><span class="literal">undefined</span> || <span class="string">"heiheihei"</span>; <span class="comment">// 返回 "heiheihei"</span></div><div class="line"><span class="literal">undefined</span> || student; <span class="comment">// 返回 student</span></div><div class="line"></div><div class="line"><span class="comment">// Null类型</span></div><div class="line"><span class="literal">false</span> || <span class="literal">null</span>; <span class="comment">// 返回 null</span></div><div class="line"><span class="literal">null</span> || <span class="literal">false</span>; <span class="comment">// 返回 false</span></div><div class="line"></div><div class="line"><span class="literal">null</span> || <span class="literal">null</span>; <span class="comment">// 返回 null</span></div><div class="line"></div><div class="line"><span class="number">0</span> || <span class="literal">null</span>; <span class="comment">// 返回 null</span></div><div class="line"><span class="literal">null</span> || <span class="number">0</span>; <span class="comment">// 返回 0</span></div><div class="line"></div><div class="line"><span class="literal">NaN</span> || <span class="literal">null</span>; <span class="comment">// 返回 null</span></div><div class="line"><span class="literal">null</span> || <span class="literal">NaN</span>; <span class="comment">// 返回 NaN</span></div><div class="line"></div><div class="line"><span class="string">""</span> || <span class="literal">null</span>; <span class="comment">// 返回 null</span></div><div class="line"><span class="literal">null</span> || <span class="string">""</span>; <span class="comment">// 返回 ""</span></div><div class="line"></div><div class="line"><span class="number">9453</span> || <span class="literal">null</span>; <span class="comment">// 返回 9453 不是说Boolean(9453) 是true，然后返回true</span></div><div class="line"><span class="literal">null</span> || <span class="number">9453</span>; <span class="comment">// 返回 9453</span></div><div class="line"></div><div class="line"><span class="string">"heiheihei"</span> || <span class="literal">null</span>; <span class="comment">// 返回 "heiheihei" 不是说Boolean("heiheihei") 是true，然后再返回true</span></div><div class="line"><span class="literal">null</span> || <span class="string">"heiheihei"</span>; <span class="comment">// 返回 "heiheihei"</span></div><div class="line"></div><div class="line">student || <span class="literal">null</span>; <span class="comment">// 返回student 不是说Boolean(student)是true，然后再返回true</span></div><div class="line"><span class="literal">null</span> || student; <span class="comment">// 返回 student</span></div><div class="line"></div><div class="line"><span class="comment">// Number类型</span></div><div class="line"><span class="literal">false</span> || <span class="number">0</span>; <span class="comment">// 返回 0</span></div><div class="line"><span class="number">0</span> || <span class="literal">false</span>; <span class="comment">// 返回 false</span></div><div class="line"></div><div class="line"><span class="string">""</span> || <span class="number">0</span>; <span class="comment">// 返回 0</span></div><div class="line"><span class="number">0</span> || <span class="string">""</span>; <span class="comment">// 返回 null</span></div><div class="line"></div><div class="line"><span class="literal">false</span> || <span class="literal">NaN</span>; <span class="comment">// 返回 NaN</span></div><div class="line"><span class="literal">NaN</span> || <span class="literal">false</span>; <span class="comment">// 返回 false</span></div><div class="line"></div><div class="line"><span class="string">""</span> || <span class="literal">NaN</span>; <span class="comment">// 返回 NaN</span></div><div class="line"><span class="literal">NaN</span> || <span class="string">""</span>; <span class="comment">// 返回 null</span></div><div class="line"></div><div class="line"><span class="literal">false</span> || <span class="number">9453</span>; <span class="comment">// 返回 9453，不是说 Boolean(9453) 是true，然后返回true</span></div><div class="line"><span class="number">9453</span> || <span class="literal">false</span>; <span class="comment">// 返回 9453</span></div><div class="line"></div><div class="line"><span class="number">9453</span> || <span class="number">183</span>; <span class="comment">// 返回 9453</span></div><div class="line"><span class="number">183</span> || <span class="number">9453</span>; <span class="comment">// 返回 183</span></div><div class="line"></div><div class="line"><span class="number">9453</span> || <span class="string">""</span>; <span class="comment">// 返回 9453</span></div><div class="line"><span class="string">""</span> || <span class="number">9453</span>; <span class="comment">// 返回 9453</span></div><div class="line"></div><div class="line"><span class="number">9453</span> || <span class="string">"heiheihei"</span>; <span class="comment">// 返回 9453</span></div><div class="line"><span class="string">"heiheihei"</span> || <span class="number">9453</span>; <span class="comment">// 返回 "heiheihei"</span></div><div class="line"></div><div class="line"><span class="number">9453</span> || student; <span class="comment">// 返回 9453</span></div><div class="line">student || <span class="number">9453</span>; <span class="comment">// 返回 student</span></div><div class="line"></div><div class="line"><span class="comment">// String类型</span></div><div class="line"><span class="literal">false</span> || <span class="string">""</span>; <span class="comment">// 返回 ""</span></div><div class="line"><span class="string">""</span> || <span class="literal">false</span>; <span class="comment">// 返回 false</span></div><div class="line"></div><div class="line"><span class="string">""</span> || <span class="string">"heiheihei"</span>; <span class="comment">// 返回 "heiheihei"</span></div><div class="line"><span class="string">"heiheihei"</span> || <span class="string">""</span>; <span class="comment">// 返回 "heiheihei"</span></div><div class="line"></div><div class="line"><span class="string">""</span> || student; <span class="comment">// 返回 student</span></div><div class="line">student || <span class="string">""</span>; <span class="comment">// 返回 student</span></div><div class="line"></div><div class="line"><span class="literal">false</span> || <span class="string">"heiheihei"</span>; <span class="comment">// 返回 "heiheihei"</span></div><div class="line"><span class="string">"heiheihei"</span> || <span class="literal">false</span>; <span class="comment">// 返回 "heiheihei"</span></div><div class="line"></div><div class="line"><span class="string">"heiheihei"</span> || <span class="string">"DaShuaiBi"</span>; <span class="comment">// 返回 "heiheihei"</span></div><div class="line"><span class="string">"DaShuaiBi"</span> || <span class="string">"heiheihei"</span>; <span class="comment">// 返回 "DaShuaiBi"</span></div><div class="line"></div><div class="line"><span class="string">"heiheihei"</span> || student; <span class="comment">// 返回 "heiheihei"</span></div><div class="line">student || <span class="string">"heiheihei"</span>; <span class="comment">// 返回 student</span></div><div class="line"></div><div class="line"><span class="comment">// Object类型</span></div><div class="line"><span class="comment">// 上边都有了</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-4-乘性操作符"><a href="#5-4-乘性操作符" class="headerlink" title="5.4 乘性操作符"></a>5.4 乘性操作符</h4><ul>
<li><p>乘法 *</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">Infinity</span> * <span class="number">0</span>); <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
</li>
<li><p>除法 /</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">Infinity</span> / <span class="literal">Infinity</span>); <span class="comment">// NaN</span></div><div class="line">alert(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">// NaN</span></div><div class="line">alert(<span class="number">5</span> / <span class="number">0</span>); <span class="comment">// Infinity</span></div><div class="line">alert(<span class="number">-5</span> / <span class="number">0</span>); <span class="comment">// Infinity</span></div></pre></td></tr></table></figure>
</li>
<li><p>求模 %</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">Infinity</span> % <span class="number">5</span>); <span class="comment">// NaN</span></div><div class="line">alert(<span class="literal">Infinity</span> % <span class="number">0</span>); <span class="comment">// NaN</span></div><div class="line">alert(<span class="number">5</span> % <span class="number">0</span>); <span class="comment">// NaN</span></div><div class="line">alert(<span class="number">5</span> % <span class="literal">Infinity</span>); <span class="comment">// 5</span></div><div class="line">alert(<span class="number">0</span> % <span class="number">5</span>); <span class="comment">// 0</span></div><div class="line">alert(<span class="number">0</span> % <span class="literal">Infinity</span>); <span class="comment">// 0</span></div><div class="line">alert(<span class="literal">Infinity</span> % <span class="literal">Infinity</span>); <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-5-加性操作符"><a href="#5-5-加性操作符" class="headerlink" title="5.5 加性操作符"></a>5.5 加性操作符</h4><ul>
<li><p>加法 +</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">alert(-<span class="literal">Infinity</span> + -<span class="literal">Infinity</span>); <span class="comment">// -Infinity</span></div><div class="line"></div><div class="line"><span class="comment">// 如果两个操作数都是字符串，拼接；如果只有一个操作数是字符串，将另一个转换成字符串，再拼接</span></div><div class="line"><span class="keyword">var</span> student = &#123;<span class="attr">name</span>:<span class="string">"DaShuaiBi"</span>,<span class="attr">age</span>:<span class="number">11</span>&#125;;</div><div class="line"></div><div class="line">alert(<span class="literal">undefined</span> + <span class="string">"heiheihei"</span>); <span class="comment">// "undefinedheiheihei"</span></div><div class="line">alert(<span class="literal">undefined</span> + <span class="string">""</span>); <span class="comment">// "undefined"</span></div><div class="line">alert(<span class="literal">null</span> + <span class="string">"heiheihei"</span>); <span class="comment">// "nullheiheihei"</span></div><div class="line">alert(<span class="literal">null</span> + <span class="string">""</span>); <span class="comment">// "null"</span></div><div class="line">alert(<span class="literal">true</span> + <span class="string">"heiheihei"</span>); <span class="comment">// "trueheiheihei"</span></div><div class="line">alert(<span class="literal">true</span> + <span class="string">""</span>); <span class="comment">// "true"</span></div><div class="line">alert(<span class="number">5</span> + <span class="string">"5"</span>); <span class="comment">// "55" 而不是 10</span></div><div class="line">alert(<span class="number">5</span> + <span class="string">""</span>); <span class="comment">// "5" </span></div><div class="line">alert(<span class="number">0</span> + <span class="string">"5"</span>); <span class="comment">// "05"</span></div><div class="line">alert(<span class="number">0</span> + <span class="string">""</span>); <span class="comment">// "0"</span></div><div class="line">alert(<span class="literal">NaN</span> + <span class="string">"5"</span>); <span class="comment">// "NaN5"</span></div><div class="line">alert(<span class="literal">NaN</span> + <span class="string">""</span>); <span class="comment">// "NaN"</span></div><div class="line">alert(<span class="string">"Da"</span> + <span class="string">"ShuaiBi"</span>); <span class="comment">// "DaShuaiBi"</span></div><div class="line">alert(student + <span class="string">"heiheihei"</span>); <span class="comment">// "[object Object]heiheihei"</span></div><div class="line">alert(student + <span class="string">""</span>); <span class="comment">// "[object Object]"</span></div><div class="line"></div><div class="line"><span class="comment">// 两个操作数都不是字符串，也不是Number类型呢？ 都用Number()函数转换</span></div><div class="line"><span class="literal">undefined</span> + <span class="literal">undefined</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> + <span class="literal">null</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> + <span class="literal">true</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> + <span class="literal">false</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> + <span class="number">0</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> + <span class="literal">NaN</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> + <span class="number">5</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> + student; <span class="comment">// "undefined[object Object]" 感觉不是用Number()转型了</span></div><div class="line"></div><div class="line"><span class="literal">null</span> + <span class="literal">true</span>; <span class="comment">// 1</span></div><div class="line"><span class="literal">null</span> + <span class="literal">false</span>; <span class="comment">// 0</span></div><div class="line"><span class="literal">null</span> + <span class="number">0</span>; <span class="comment">// 0</span></div><div class="line"><span class="literal">null</span> + <span class="literal">NaN</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">null</span> + <span class="number">5</span>; <span class="comment">// 5</span></div><div class="line"><span class="literal">null</span> + student; <span class="comment">// "null[object Object]" 感觉不是用Number()转型了</span></div><div class="line"></div><div class="line"><span class="literal">true</span> + <span class="literal">false</span>; <span class="comment">// 1</span></div><div class="line"><span class="literal">true</span> + <span class="number">5</span>; <span class="comment">// 6</span></div><div class="line"><span class="literal">false</span> + <span class="number">5</span>; <span class="comment">// 5</span></div><div class="line"><span class="literal">true</span> + <span class="number">0</span>; <span class="comment">// 1</span></div><div class="line"><span class="literal">false</span> + <span class="number">0</span>; <span class="comment">// 0</span></div><div class="line"><span class="literal">true</span> + <span class="literal">NaN</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">false</span> + <span class="literal">NaN</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">true</span> + student; <span class="comment">// "true[object Object]"</span></div><div class="line"><span class="literal">false</span> + student; <span class="comment">// "false[object Object]"</span></div><div class="line"></div><div class="line"><span class="number">0</span> + student; <span class="comment">// "0[object Object]" </span></div><div class="line"><span class="literal">NaN</span> + student; <span class="comment">// "NaN[object Object]"</span></div><div class="line"><span class="number">5</span> + student; <span class="comment">// "5[object Object]"</span></div></pre></td></tr></table></figure>
</li>
<li><p>减法 -</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">Infinity</span> - <span class="literal">Infinity</span>); <span class="comment">// NaN</span></div><div class="line">alert(-<span class="literal">Infinity</span> - -<span class="literal">Infinity</span>); <span class="comment">// NaN</span></div><div class="line"></div><div class="line"><span class="comment">// 如果有一个操作数是字符串、布尔值、null或undefined，先用Number()函数转成数值，再相减。</span></div><div class="line"><span class="keyword">var</span> student = &#123;<span class="attr">name</span>:<span class="string">"DaShuaiBi"</span>,<span class="attr">age</span>:<span class="number">11</span>&#125;;</div><div class="line"></div><div class="line"><span class="number">5</span> - <span class="literal">undefined</span>; <span class="comment">// NaN</span></div><div class="line"><span class="number">5</span> - <span class="literal">null</span>; <span class="comment">// 5</span></div><div class="line"><span class="number">5</span> - <span class="literal">true</span>; <span class="comment">// 4</span></div><div class="line"><span class="number">5</span> - <span class="literal">false</span>; <span class="comment">// 5</span></div><div class="line"><span class="number">5</span> - <span class="string">"heiheihei"</span>; <span class="comment">// NaN</span></div><div class="line"><span class="number">5</span> - <span class="string">"222"</span>; <span class="comment">// -217</span></div><div class="line"><span class="number">5</span> - <span class="string">""</span>; <span class="comment">// 5</span></div><div class="line"><span class="number">5</span> - student; <span class="comment">// NaN 噢噢噢噢？</span></div><div class="line"></div><div class="line"><span class="comment">// 两个操作数都不是数字呢？</span></div><div class="line"><span class="literal">undefined</span> - <span class="literal">undefined</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> - <span class="literal">null</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> - <span class="literal">true</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> - <span class="literal">false</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> - <span class="string">"heiheihei"</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> - <span class="string">"222"</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> - <span class="string">""</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">undefined</span> - student; <span class="comment">// NaN</span></div><div class="line"></div><div class="line"><span class="literal">null</span> - <span class="literal">null</span>; <span class="comment">// 0</span></div><div class="line"><span class="literal">null</span> - <span class="literal">true</span>; <span class="comment">// -1</span></div><div class="line"><span class="literal">null</span> - <span class="literal">false</span>; <span class="comment">// 0</span></div><div class="line"><span class="literal">null</span> - <span class="string">"heiheihei"</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">null</span> - <span class="string">"222"</span>; <span class="comment">// -222</span></div><div class="line"><span class="literal">null</span> - <span class="string">""</span>; <span class="comment">// 0</span></div><div class="line"><span class="literal">null</span> - student; <span class="comment">// NaN</span></div><div class="line"></div><div class="line"><span class="literal">true</span> - <span class="literal">true</span>; <span class="comment">// 0</span></div><div class="line"><span class="literal">true</span> - <span class="literal">false</span>; <span class="comment">// 1</span></div><div class="line"><span class="literal">true</span> - <span class="string">"heiheihei"</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">false</span> - <span class="string">"heiheihei"</span>; <span class="comment">// NaN</span></div><div class="line"><span class="literal">true</span> - <span class="string">"222"</span>; <span class="comment">// -221</span></div><div class="line"><span class="literal">false</span> - <span class="string">"222"</span>; <span class="comment">// -222</span></div><div class="line"><span class="literal">true</span> - <span class="string">""</span>; <span class="comment">// 1</span></div><div class="line"><span class="literal">false</span> - <span class="string">""</span>; <span class="comment">// 0</span></div><div class="line"><span class="literal">true</span> - student; <span class="comment">// NaN</span></div><div class="line"><span class="literal">false</span> - student; <span class="comment">// NaN</span></div><div class="line"></div><div class="line"><span class="string">"DaShuaiBi"</span> - <span class="string">"Bi"</span>; <span class="comment">// NaN 要是"DaShuai"就不错哦</span></div><div class="line"><span class="string">"heiheihie"</span> - <span class="string">"222"</span>; <span class="comment">// NaN</span></div><div class="line"><span class="string">"heiheihie"</span> - <span class="string">""</span>; <span class="comment">// NaN</span></div><div class="line"><span class="string">"heiheihie"</span> - student; <span class="comment">// NaN</span></div><div class="line"><span class="string">"222"</span> - <span class="string">"2"</span>; <span class="comment">// 220</span></div><div class="line"><span class="string">"222"</span> - <span class="string">""</span>; <span class="comment">// 222</span></div><div class="line"><span class="string">"222"</span> - student; <span class="comment">// NaN</span></div><div class="line"><span class="string">""</span> - student; <span class="comment">// NaN</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> people = &#123;<span class="attr">name</span>:<span class="string">"DaShuaiBi"</span>,<span class="attr">age</span>:<span class="string">"23"</span>&#125;;</div><div class="line">people - student; <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-6-关系操作符"><a href="#5-6-关系操作符" class="headerlink" title="5.6 关系操作符"></a>5.6 关系操作符</h4><p>小于（&lt;）、大于（&gt;）、小于等于（&lt;=）、大于等于（&gt;=）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一些特殊的情况</span></div><div class="line"><span class="string">"Brick"</span> &lt; <span class="string">"alphabet"</span>; <span class="comment">// true 字符串的比较 比较字符串对应的字符编码值 大写字母的字符编码全部小于小写字母的字符编码</span></div><div class="line"><span class="string">"23"</span> &lt; <span class="string">"3"</span>; <span class="comment">// true 两个操作数都是字符串，比较的是对应的字符编码，"2"的字符编码是小于"3"的字符编码的</span></div><div class="line"><span class="string">"23"</span> &lt; <span class="number">3</span>; <span class="comment">// false 有一个是数字，"23"转换成23，再与3比较</span></div><div class="line"><span class="comment">// 有关NaN</span></div><div class="line"><span class="string">"a"</span> &lt; <span class="number">3</span>; <span class="comment">// false 有3，数值，需要把"a"转换成数值，然而"a"转换为Number类型是NaN， NaN与任何操作数进行关系比较，结果都是false</span></div><div class="line"><span class="comment">// 如果一个值不小于另一个值，则一定是大于或等于那个值。然而 NaN：</span></div><div class="line"><span class="literal">NaN</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></div><div class="line"><span class="literal">NaN</span> &gt;= <span class="number">3</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h4 id="5-7-相等操作符"><a href="#5-7-相等操作符" class="headerlink" title="5.7 相等操作符"></a>5.7 相等操作符</h4><ul>
<li><p>相等和不相等 == !=<br>会先转换操作数（<strong>强制转型</strong>），然后再比较相等性</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一些特殊情况</span></div><div class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">// true</span></div><div class="line"><span class="literal">undefined</span> == <span class="number">0</span>; <span class="comment">// false</span></div><div class="line"><span class="literal">null</span> == <span class="number">0</span>; <span class="comment">// false</span></div><div class="line"><span class="string">"NaN"</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></div><div class="line"><span class="number">5</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></div><div class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></div><div class="line"><span class="literal">NaN</span> != <span class="literal">NaN</span>; <span class="comment">// true</span></div><div class="line"><span class="literal">false</span> == <span class="number">0</span>; <span class="comment">// true</span></div><div class="line"><span class="literal">true</span> == <span class="number">1</span>; <span class="comment">// true</span></div><div class="line"><span class="literal">true</span> == <span class="number">2</span>; <span class="comment">// false</span></div><div class="line"><span class="string">"5"</span> == <span class="number">5</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>全等和不全等 === !==<br>不进行转换操作数</p>
</li>
</ul>
<blockquote>
<p>为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。</p>
</blockquote>
<h4 id="5-8-条件操作符"><a href="#5-8-条件操作符" class="headerlink" title="5.8 条件操作符"></a>5.8 条件操作符</h4><p>xx?xx:xx</p>
<h4 id="5-9-赋值操作符"><a href="#5-9-赋值操作符" class="headerlink" title="5.9 赋值操作符"></a>5.9 赋值操作符</h4><ul>
<li>简单赋值操作符 =</li>
<li>复合赋值操作符 *= /= %= += -= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</li>
</ul>
<h4 id="5-10-逗号操作符"><a href="#5-10-逗号操作符" class="headerlink" title="5.10 逗号操作符"></a>5.10 逗号操作符</h4><p>比如声明多个变量时为啥用逗号隔开，还有对象中的不同属性之间用逗号隔开……<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>,</div><div class="line">    num2 = <span class="number">2</span>,</div><div class="line">    num3;</div><div class="line"><span class="keyword">var</span> student = &#123;<span class="attr">name</span>:<span class="string">"DaShuaiBi"</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;</div></pre></td></tr></table></figure></p>
<h3 id="6-语句"><a href="#6-语句" class="headerlink" title="6. 语句"></a>6. 语句</h3><h4 id="6-1-if语句"><a href="#6-1-if语句" class="headerlink" title="6.1 if语句"></a>6.1 if语句</h4><h4 id="6-2-do-while语句"><a href="#6-2-do-while语句" class="headerlink" title="6.2 do-while语句"></a>6.2 do-while语句</h4><p>后测试循环</p>
<h4 id="6-3-while语句"><a href="#6-3-while语句" class="headerlink" title="6.3 while语句"></a>6.3 while语句</h4><p>前测试循环</p>
<h4 id="6-4-for语句"><a href="#6-4-for语句" class="headerlink" title="6.4 for语句"></a>6.4 for语句</h4><p>前测试循环</p>
<blockquote>
<p>由于ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">    alert(i);</div><div class="line">&#125;</div><div class="line">alert(i); <span class="comment">// 10 i是在循环体内定义的，在循环体外也可访问到</span></div></pre></td></tr></table></figure>
<h4 id="6-5-for-in语句"><a href="#6-5-for-in语句" class="headerlink" title="6.5 for-in语句"></a>6.5 for-in语句</h4><blockquote>
<p>for-in语句是一种精确的迭代语句，可以用来<strong>枚举</strong> <strong>对象的</strong> <strong>属性</strong></p>
</blockquote>
<h4 id="6-6-label语句"><a href="#6-6-label语句" class="headerlink" title="6.6 label语句"></a>6.6 label语句</h4><p>多与break和continue联合使用。多发生在<strong>循环嵌套</strong>情况下。比如可以从内层循环直接跳出外层循环。</p>
<h4 id="6-7-break和continue语句"><a href="#6-7-break和continue语句" class="headerlink" title="6.7 break和continue语句"></a>6.7 break和continue语句</h4><h4 id="6-8-with语句"><a href="#6-8-with语句" class="headerlink" title="6.8 with语句"></a>6.8 with语句</h4><blockquote>
<p>with语句的作用是将代码的作用域设置到一个特定的对象中</p>
<p>大量使用with语句会导致性能下降……不建议使用</p>
</blockquote>
<h4 id="6-9-switch语句"><a href="#6-9-switch语句" class="headerlink" title="6.9 switch语句"></a>6.9 switch语句</h4><p>避免写很多if、else if语句<br>switch、case、break、default<br>要是case后不加break，找到符合的case，之后的每个case都会执行。</p>
<blockquote>
<p>可以在switch语句中使用任何数据类型（很多其他语言只能使用数值）</p>
<p>每个case的值不一定是常量，可以是变量，甚至是表达式</p>
<p>switch语句在比较值时使用的是全等操作符</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例子1 弹出"Greeting was found."</span></div><div class="line"><span class="keyword">switch</span> (<span class="string">"hello world"</span>) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"hello"</span> + <span class="string">" world"</span>:</div><div class="line">        alert(<span class="string">"Greeting was found."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">"goodbye"</span>:</div><div class="line">        alert(<span class="string">"Closing was found."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        alert(<span class="string">"Unexpected message was found."</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 例子2 弹出"More than 20."</span></div><div class="line"><span class="keyword">var</span> num = <span class="number">25</span>;</div><div class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">case</span> num &lt; <span class="number">0</span>:</div><div class="line">        alert(<span class="string">"Less than 0."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> num &gt;=<span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</div><div class="line">        alert(<span class="string">"Between 0 and 10."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</div><div class="line">        alert(<span class="string">"Between 10 and 20."</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        alert(<span class="string">"More than 20."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h3><ul>
<li><p>函数的声明、调用、返回值。</p>
<blockquote>
<p>函数使用function关键字声明，后跟一组参数以及函数体</p>
<p>函数可以通过其函数名来调用，后面还要加上一对圆括号和参数</p>
<p>函数定义时不必指定是否返回值，在任何时候都可以通过return语句后跟要返回的值来实现返回值</p>
</blockquote>
</li>
<li><p>理解参数<br>(1) 其他语言可能需要事先创建一个<strong>函数签名</strong>（大概就是参数的类型吧），ECMAScript中不用</p>
<p>(2) ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型</p>
<blockquote>
<p>ECMAScript中的<strong>参数在内部</strong>是用一个<strong>数组</strong>来表述的。函数接收的始终是这个数组，而不关心数组中包含哪些参数（如果有参数的话）</p>
</blockquote>
<p>(3) <strong>在函数体内</strong>，可以通过<strong>arguments对象</strong>访问这个数组。可以用<strong>方括号语法</strong>[]访问它的每一元素；可以使用<strong>length属性</strong>确定传递进来多少个参数</p>
<p>(4) 函数中命名的参数只<strong>提供便利</strong>，但不是必需的</p>
<p>(5) ECMAScript函数<strong>没有重载</strong>。其他函数的重载是通过声明定义相同的函数名，而有不同的参数类型或不同的参数数量实现的。</p>
<blockquote>
<p>ECMAScript中由于函数没有签名，其参数是由包含零或多个值的数组表示的。没有函数签名，真正的重载是不可能做到的。</p>
</blockquote>
<p>但可以通过检查传入函数中参数的类型和数量并作出不同的反应，从而模拟重载。比如：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123;</div><div class="line">        alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="number">10</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.lenght == <span class="number">2</span>) &#123;</div><div class="line">        alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">doAdd(<span class="number">10</span>); <span class="comment">// 20</span></div><div class="line">doAdd(<span class="number">30</span>, <span class="number">20</span>); <span class="comment">// 50</span></div></pre></td></tr></table></figure>
<p>(6) 关于<strong>arguments</strong>对象</p>
<blockquote>
<p>arguments的<strong>值</strong>永远与对应的<strong>命名参数</strong>（大概就是形参吧）的值保持同步</p>
</blockquote>
<p>  看例子：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</div><div class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</div><div class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">doAdd(<span class="number">10</span>,<span class="number">20</span>); </div><div class="line"><span class="comment">/* </span></div><div class="line"> * 20 arguments对象中的值会自动反映到对应的命名参数本来传进来的参数是[10,20]，即arguments中是[10,20],但是</div><div class="line"> * 修改了arguments[1]为10，则num2也被修改为10，最后alert的是10+10等于20</div><div class="line"> */</div><div class="line"></div><div class="line"></div><div class="line">doAdd(<span class="number">10</span>,<span class="string">"heihei"</span>); </div><div class="line"><span class="comment">/*</span></div><div class="line"> * 20 arguments刚开始是[10,"heihei"]，之后arguments[1]被修改为10，num2也跟着被修改为10，</div><div class="line"> * 最后alert的是10+10等于20</div><div class="line"> */</div></pre></td></tr></table></figure>
<blockquote>
<p>arguments对象的<strong>长度</strong>是由<strong>传入的参数个数</strong>决定的，不是由定义函数时的命名参数的个数决定的</p>
</blockquote>
<p>  看例子：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 还是上边的函数</span></div><div class="line"></div><div class="line"></div><div class="line">doAdd(<span class="number">10</span>,<span class="number">100</span>,<span class="number">20</span>);</div><div class="line"> <span class="comment">/*</span></div><div class="line">  * 20 arguments刚开始是[10,100,20],之后被修改为[10,10,20]，</div><div class="line">  * 再将num1、num2和arguments中的值对应，arguments[2]就没有用到，之后num2是10，最后alert的等于20</div><div class="line">  */ </div><div class="line"></div><div class="line"></div><div class="line">doAdd(<span class="number">10</span>); </div><div class="line"><span class="comment">/*</span></div><div class="line"> * NaN 如果只是传递了一个值，这时arguments中是[10],就没有arguments[1]，因此函数中第一句就没用。</div><div class="line"> * 而对于没有传递值的命名参数将自动被赋予undefined值，也就是说这时num2中是undefined，alert的是 10 + undefined，</div><div class="line"> * 先用Number(undefined)转型，为NaN，之后10 + NaN是NAN</div><div class="line"> */</div></pre></td></tr></table></figure>
<blockquote>
<p>ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第3章-基本概念&quot;&gt;&lt;a href=&quot;#第3章-基本概念&quot; class=&quot;headerlink&quot; title=&quot;第3章 基本概念&quot;&gt;&lt;/a&gt;第3章 基本概念&lt;/h2&gt;&lt;h3 id=&quot;1-语法&quot;&gt;&lt;a href=&quot;#1-语法&quot; class=&quot;headerlink&quot; title=&quot;1. 语法&quot;&gt;&lt;/a&gt;1. 语法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;区分大小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多行注释&lt;/p&gt;
  &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * 这两行的星星是没有必要的，&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * 但就是好看啊。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-关键字和保留字&quot;&gt;&lt;a href=&quot;#2-关键字和保留字&quot; class=&quot;headerlink&quot; title=&quot;2. 关键字和保留字&quot;&gt;&lt;/a&gt;2. 关键字和保留字&lt;/h3&gt;&lt;p&gt;这两个的异同是什么呢？&lt;br&gt;异：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等&lt;/p&gt;
&lt;p&gt;保留字有可能将来被用作关键字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同：都是小写的。。&lt;/p&gt;
&lt;h3 id=&quot;3-变量&quot;&gt;&lt;a href=&quot;#3-变量&quot; class=&quot;headerlink&quot; title=&quot;3. 变量&quot;&gt;&lt;/a&gt;3. 变量&lt;/h3&gt;
    
    </summary>
    
    
      <category term="JS基础" scheme="http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android还踢球app总结（一）</title>
    <link href="http://yoursite.com/2016/10/30/Android%E8%BF%98%E8%B8%A2%E7%90%83app%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/30/Android还踢球app总结（一）/</id>
    <published>2016-10-30T08:27:03.000Z</published>
    <updated>2016-10-30T08:27:35.222Z</updated>
    
    <content type="html"><![CDATA[<p>这个小项目做完快半年多了，一直想总结一下，记录一些想法和技能。大概分五篇完成，第一篇介绍目标人群、需求分析还有功能介绍；第二篇介绍界面设计及简单的代码实现；第三篇介绍”开发模式“；第四篇介绍用到的第三方服务；第五篇介绍一些小的功能点和知识点。</p>
<h2 id="1-目标人群"><a href="#1-目标人群" class="headerlink" title="1.目标人群"></a>1.目标人群</h2><p>当然是广大的足球爱好者，是真正想下场踢球的足球爱好者。</p>
<p>稍微扯点别的，为什么取“还踢球”这个名字？现在中国足球很让人失望（貌似从自己真正看球时就一直让人失望，除了之前高洪波带着打韩国、德国、法国那几场……），但真正爱球的人谁不希望他变得更好呢，再差也想看，想着能变得好一点。“还踢球”是星爷《功夫》里的一句台词，一群小孩在踢球，球被踢到星爷这边，然后近景是星爷的腿，远处一群小孩，两栋破楼，星爷来了一段freestyle，很帅，小孩问：“叔叔，可不可教我们踢球啊？”。没想到星爷回的是：”还踢球？！“，然后一脚把球踩“泄”了。这应该能够表达很多人对中国足球的感受了……但真要这样的话，中国足球是不可能有出头之日了。有时候有中国队的比赛，周围不看球的人总会说“啊，中国队连XX都踢不过啊”，“不用看了，肯定输了”，稍微瞥一眼直播，“这都停不住”，“这配合也太烂了吧”……诸如此类，网上的喷子更不用说了。很心烦，但感觉说什么都没用。我们能做得是真的去踢踢球，然后能够慢慢影响周围的人觉得说踢好球真不是件容易的事，而又是一件令人激动、令人开心的事。</p>
<h2 id="2-需求分析"><a href="#2-需求分析" class="headerlink" title="2.需求分析"></a>2.需求分析</h2><p>真的开发一款软件时，需求分析很重要的。但没有亲身经历过，只是看过课本上的讲的。出一份需求分析文档更麻烦了。这里的需求分析都是自己凭空想的，起码自己曾经也算个足球“超级狂der”爱好者吧。文档里主要有写可行性分析和功能需求（用用例图和用例描述进行介绍）。</p>
<p>自己想要做这一款app时主要是由于自己需求。想踢球时不知道谁有空，在哪里可以踢，尤其是刚到一个新的城市时。虽然踢一次，大家可以留联系方式，但其实不可能与所有踢球的朋友联系上。所以我最想要的功能是可以发布一些约球的信息，填写时间、地点、几人制的，大家可以报名，人多了，去了也可以分拨。然后按照约球的时间排序，大家也可以浏览什么时间什么地点有球踢，可以选择的去参加。这个功能其实就类似一个论坛，能够发帖、浏览帖子。</p>
<a id="more"></a>
<h2 id="3-功能介绍"><a href="#3-功能介绍" class="headerlink" title="3.功能介绍"></a>3.功能介绍</h2><p>最后介绍下预想一些的功能。</p>
<ul>
<li>找组织<ul>
<li>发帖</li>
<li>浏览帖子</li>
<li>查看详情 <ul>
<li>查看帖子详情</li>
<li>查看约球当天天气详情</li>
<li>查看约球地点地图详情</li>
</ul>
</li>
<li>报名参加</li>
<li>目的地导航</li>
</ul>
</li>
<li>找场地 <ul>
<li>浏览场地</li>
<li>查看详情</li>
<li>目的地导航</li>
<li>评价场地</li>
</ul>
</li>
<li>本地比赛<ul>
<li>查看比赛</li>
<li>查看球队</li>
<li>查看选手</li>
</ul>
</li>
</ul>
<p>目前主要实现了找组织功能模块。当然还有用户管理模块。</p>
<p>一些说明：</p>
<p>找组织功能中，天气的获取想用<a href="http://www.heweather.com/" target="_blank" rel="external">和风天气</a>的API，而天气一般都是7天之内的，所以关于约球的时间也得限制在7天之内；关于约球帖子的信息，必须要有时间和地点。刚开始想的地点只是文字描述，然而这显然是不够精确。所以关于地点的选择用了<a href="http://lbs.amap.com/" target="_blank" rel="external">高德</a>的API，每次都在地图上选择，可以获取经纬度，保存，展示地点时又可根据经纬度确定在地图上的位置。关于用户、帖子的管理用到了<a href="http://www.bmob.cn/" target="_blank" rel="external">Bmob</a>，是一种<a href="https://en.wikipedia.org/wiki/Mobile_backend_as_a_service" target="_blank" rel="external">MBaaS</a>服务。这些之后再详细介绍。</p>
<p>找场地功能中，场地可以是一些商家提供，也可以是确定能踢球的一些学校或者广场之类的地方。（需人工确定、不断更新）可以看场地的一些实拍图，还有球友的评价。</p>
<p>本地比赛功能中，可以发布本地球友们组织的赛事，比如关于招募球队报名、赛事进程等等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个小项目做完快半年多了，一直想总结一下，记录一些想法和技能。大概分五篇完成，第一篇介绍目标人群、需求分析还有功能介绍；第二篇介绍界面设计及简单的代码实现；第三篇介绍”开发模式“；第四篇介绍用到的第三方服务；第五篇介绍一些小的功能点和知识点。&lt;/p&gt;
&lt;h2 id=&quot;1-目标人群&quot;&gt;&lt;a href=&quot;#1-目标人群&quot; class=&quot;headerlink&quot; title=&quot;1.目标人群&quot;&gt;&lt;/a&gt;1.目标人群&lt;/h2&gt;&lt;p&gt;当然是广大的足球爱好者，是真正想下场踢球的足球爱好者。&lt;/p&gt;
&lt;p&gt;稍微扯点别的，为什么取“还踢球”这个名字？现在中国足球很让人失望（貌似从自己真正看球时就一直让人失望，除了之前高洪波带着打韩国、德国、法国那几场……），但真正爱球的人谁不希望他变得更好呢，再差也想看，想着能变得好一点。“还踢球”是星爷《功夫》里的一句台词，一群小孩在踢球，球被踢到星爷这边，然后近景是星爷的腿，远处一群小孩，两栋破楼，星爷来了一段freestyle，很帅，小孩问：“叔叔，可不可教我们踢球啊？”。没想到星爷回的是：”还踢球？！“，然后一脚把球踩“泄”了。这应该能够表达很多人对中国足球的感受了……但真要这样的话，中国足球是不可能有出头之日了。有时候有中国队的比赛，周围不看球的人总会说“啊，中国队连XX都踢不过啊”，“不用看了，肯定输了”，稍微瞥一眼直播，“这都停不住”，“这配合也太烂了吧”……诸如此类，网上的喷子更不用说了。很心烦，但感觉说什么都没用。我们能做得是真的去踢踢球，然后能够慢慢影响周围的人觉得说踢好球真不是件容易的事，而又是一件令人激动、令人开心的事。&lt;/p&gt;
&lt;h2 id=&quot;2-需求分析&quot;&gt;&lt;a href=&quot;#2-需求分析&quot; class=&quot;headerlink&quot; title=&quot;2.需求分析&quot;&gt;&lt;/a&gt;2.需求分析&lt;/h2&gt;&lt;p&gt;真的开发一款软件时，需求分析很重要的。但没有亲身经历过，只是看过课本上的讲的。出一份需求分析文档更麻烦了。这里的需求分析都是自己凭空想的，起码自己曾经也算个足球“超级狂der”爱好者吧。文档里主要有写可行性分析和功能需求（用用例图和用例描述进行介绍）。&lt;/p&gt;
&lt;p&gt;自己想要做这一款app时主要是由于自己需求。想踢球时不知道谁有空，在哪里可以踢，尤其是刚到一个新的城市时。虽然踢一次，大家可以留联系方式，但其实不可能与所有踢球的朋友联系上。所以我最想要的功能是可以发布一些约球的信息，填写时间、地点、几人制的，大家可以报名，人多了，去了也可以分拨。然后按照约球的时间排序，大家也可以浏览什么时间什么地点有球踢，可以选择的去参加。这个功能其实就类似一个论坛，能够发帖、浏览帖子。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>不同电脑上test2</title>
    <link href="http://yoursite.com/2016/10/29/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E4%B8%8Atest2/"/>
    <id>http://yoursite.com/2016/10/29/不同电脑上test2/</id>
    <published>2016-10-29T11:27:52.000Z</published>
    <updated>2016-10-29T11:31:32.332Z</updated>
    
    <content type="html"><![CDATA[<p>不同电脑上test2 来自笔记本</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不同电脑上test2 来自笔记本&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不同电脑同步test</title>
    <link href="http://yoursite.com/2016/10/29/%E4%B8%8D%E5%90%8C%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5test/"/>
    <id>http://yoursite.com/2016/10/29/不同电脑同步test/</id>
    <published>2016-10-29T10:07:23.000Z</published>
    <updated>2016-10-29T10:08:18.821Z</updated>
    
    <content type="html"><![CDATA[<p>不同电脑同步test. 来自实验室</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不同电脑同步test. 来自实验室&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Test Again</title>
    <link href="http://yoursite.com/2016/10/29/Test-Again/"/>
    <id>http://yoursite.com/2016/10/29/Test-Again/</id>
    <published>2016-10-29T09:29:11.000Z</published>
    <updated>2016-10-29T09:58:33.470Z</updated>
    
    <content type="html"><![CDATA[<p>重装电脑 test again</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重装电脑 test again&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS高程（一）</title>
    <link href="http://yoursite.com/2016/10/26/JS%E9%AB%98%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/26/JS高程（一）/</id>
    <published>2016-10-26T13:24:23.000Z</published>
    <updated>2016-12-22T09:21:35.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h2><h3 id="1-几个人东"><a href="#1-几个人东" class="headerlink" title="1. 几个人东"></a>1. 几个人东</h3><ul>
<li>布兰登 艾奇 (Brendan Eich)</li>
<li>ECMA(European Computer Manufactures Association) 欧洲计算机制造商协会</li>
<li>ISO/IEC(International Organization for Standardization and International Electrotechnical Commission) 国际标准化组织和国际电工委员会</li>
</ul>
<h3 id="2-JavaScript-ECMAScript-DOM-BOM"><a href="#2-JavaScript-ECMAScript-DOM-BOM" class="headerlink" title="2. JavaScript = ECMAScript + DOM + BOM"></a>2. JavaScript = ECMAScript + DOM + BOM</h3><ul>
<li>ECMAScript：Web浏览器只是ECMAScript <strong>宿主环境之一</strong>, Node和Adobe Flash 也是ECMAScript的宿主环境。</li>
<li>DOM(Document Object Model)：文档对象模型。<ul>
<li><strong>是个API</strong>。针对XML但经过扩展用于HTMl的API。</li>
<li>由W3C(World Wide Web Consortium)万维网联盟闹的。避免Netscape和微软的两强割据。（两家闹不同的DHTML Dynamic HTML）</li>
<li>DOM级别。自己理解所谓级别是不同阶段的标准，或者说后来又加入的新功能；DOM1，DOM2，DOM3级。DOM0级呢？没有，其实对应上边的DHTML。 </li>
<li>不光是JavaScript有DOM，有其他语言也实现了DOM。SVG(Scalable Vector Graphic)可伸缩矢量图是一种语言，实现了DOM，有自己的标准。？？？</li>
</ul>
</li>
<li>BOM(Browser Object Model)：浏览器对象模型。<a id="more"></a>
</li>
</ul>
<h2 id="第2章-在HTML中使用JavaScript"><a href="#第2章-在HTML中使用JavaScript" class="headerlink" title="第2章 在HTML中使用JavaScript"></a>第2章 在HTML中使用JavaScript</h2><h3 id="1-当然是分-在页面（HTML）中嵌入JavaScript-和-包含外部JavaScript文件两种。"><a href="#1-当然是分-在页面（HTML）中嵌入JavaScript-和-包含外部JavaScript文件两种。" class="headerlink" title="1. 当然是分 在页面（HTML）中嵌入JavaScript 和 包含外部JavaScript文件两种。"></a>1. 当然是分 在页面（HTML）中嵌入JavaScript 和 包含外部JavaScript文件两种。</h3><ul>
<li><p>在页面中嵌入JavaScript时，想输出或弹出“<code>&lt;/script&gt;</code>”，怎么转义呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="string">"&lt;\/script&gt;"</span>)</div></pre></td></tr></table></figure>
<p>注意不是<code>“\&lt;/script&gt;”</code>，重点是<code>/script&gt;</code>。</p>
</li>
<li><code>&lt;script&gt;</code> 标签放在哪里？一种：<code>&lt;head&gt;</code>尾部；另一种<code>&lt;body&gt;</code>尾部。</li>
</ul>
<blockquote>
<p>在文档的<code>&lt;head&gt;</code>元素中包含所有JavaScript文件，意味着必须等到全部JavaScript代码都被下载、解析和执行完成以后，才能开始呈现页面的内容（浏览器在遇到<code>&lt;body&gt;</code>标签时才开始呈现内容）。</p>
</blockquote>
<p>  这样在加载很多JS文件是，浏览器窗口将是一片空白。</p>
<blockquote>
<p>现在Web应用程序一般都把全部JavaScript引用放在<code>&lt;body&gt;</code>元素中页面内容的后面。</p>
</blockquote>
<p>  但是，尝试本地的JS文件或者嵌入JS就不是这样的。。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">	诶哟，厉害啦。我出现了！！！！！</div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        alert(<span class="string">"Hi"</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>  或者<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    诶哟，厉害啦。我出现了！！！！！</div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"test.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//test.js</span></div><div class="line">alert(<span class="string">"Hello"</span>);</div></pre></td></tr></table></figure>
<p>  这两种本来以为先显示“诶哟，厉害啦。我出现了！！！！！”，再alert出对话框，但都不是。。。<br>  本来还想试试<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        alert(<span class="string">"Hi"</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    诶哟，厉害啦。我出现了！！！！！</div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"test.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>  想的是先弹出“Hi”，再显示出“诶哟，厉害啦。我出现了！！！！！”，最后再弹出“Hello”。。。后边的<strong>defer</strong>属性也是这样的。或许因为是本地文件的原因。</p>
<h3 id="2-延迟脚本和异步脚本"><a href="#2-延迟脚本和异步脚本" class="headerlink" title="2. 延迟脚本和异步脚本"></a>2. 延迟脚本和异步脚本</h3><p>在<code>&lt;script&gt;</code>标签中加入<code>defer</code>和<code>async</code>属性。只适用于外部脚本文件。但还是和上一个问题一样，试本地的JS文件没有用。。。具体的效果之后还得再看。</p>
<h3 id="3-文档模式"><a href="#3-文档模式" class="headerlink" title="3. 文档模式"></a>3. 文档模式</h3><p>这是说HTML的。有<strong>混杂模式</strong>，<strong>标准模式</strong>，<strong>准标准模式</strong>。但到底有什么用呢？</p>
<blockquote>
<p>主要影响CSS内容的呈现。但在某些情况下也会影响到JavaScript的解释执行。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div></pre></td></tr></table></figure>
<p>对于HTML 5，这条代码就是用来开启文档类型的标准模式。。。</p>
<h3 id="4-浏览器禁用JS时"><a href="#4-浏览器禁用JS时" class="headerlink" title="4. 浏览器禁用JS时"></a>4. 浏览器禁用JS时</h3><p>浏览器中能够设置禁用JavaScript的。这种情况下，用的JS都不起作用，Web应用程序很可能一些效果或功能都没了。而可以使用<code>&lt;noscript&gt;</code>元素设置一些提醒给用户，提高用户体验。。。但是在支持JavaScript时，不会呈现<code>&lt;noscript&gt;</code>中的内容。（在<code>&lt;noscript&gt;</code>元素中一些html标签当然还能用比如<code>&lt;h1&gt;</code>、<code>&lt;p&gt;</code>；但是JS中的就不行了，比如alert..）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第1章-简介&quot;&gt;&lt;a href=&quot;#第1章-简介&quot; class=&quot;headerlink&quot; title=&quot;第1章 简介&quot;&gt;&lt;/a&gt;第1章 简介&lt;/h2&gt;&lt;h3 id=&quot;1-几个人东&quot;&gt;&lt;a href=&quot;#1-几个人东&quot; class=&quot;headerlink&quot; title=&quot;1. 几个人东&quot;&gt;&lt;/a&gt;1. 几个人东&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;布兰登 艾奇 (Brendan Eich)&lt;/li&gt;
&lt;li&gt;ECMA(European Computer Manufactures Association) 欧洲计算机制造商协会&lt;/li&gt;
&lt;li&gt;ISO/IEC(International Organization for Standardization and International Electrotechnical Commission) 国际标准化组织和国际电工委员会&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-JavaScript-ECMAScript-DOM-BOM&quot;&gt;&lt;a href=&quot;#2-JavaScript-ECMAScript-DOM-BOM&quot; class=&quot;headerlink&quot; title=&quot;2. JavaScript = ECMAScript + DOM + BOM&quot;&gt;&lt;/a&gt;2. JavaScript = ECMAScript + DOM + BOM&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;ECMAScript：Web浏览器只是ECMAScript &lt;strong&gt;宿主环境之一&lt;/strong&gt;, Node和Adobe Flash 也是ECMAScript的宿主环境。&lt;/li&gt;
&lt;li&gt;DOM(Document Object Model)：文档对象模型。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;是个API&lt;/strong&gt;。针对XML但经过扩展用于HTMl的API。&lt;/li&gt;
&lt;li&gt;由W3C(World Wide Web Consortium)万维网联盟闹的。避免Netscape和微软的两强割据。（两家闹不同的DHTML Dynamic HTML）&lt;/li&gt;
&lt;li&gt;DOM级别。自己理解所谓级别是不同阶段的标准，或者说后来又加入的新功能；DOM1，DOM2，DOM3级。DOM0级呢？没有，其实对应上边的DHTML。 &lt;/li&gt;
&lt;li&gt;不光是JavaScript有DOM，有其他语言也实现了DOM。SVG(Scalable Vector Graphic)可伸缩矢量图是一种语言，实现了DOM，有自己的标准。？？？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BOM(Browser Object Model)：浏览器对象模型。
    
    </summary>
    
    
      <category term="JS基础" scheme="http://yoursite.com/tags/JS%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于hexo的一些问题</title>
    <link href="http://yoursite.com/2016/03/13/%E5%85%B3%E4%BA%8Ehexo%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/03/13/关于hexo的一些问题/</id>
    <published>2016-03-13T13:24:23.000Z</published>
    <updated>2016-10-29T09:58:33.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-hexo的deploy问题"><a href="#1-hexo的deploy问题" class="headerlink" title="1.hexo的deploy问题"></a>1.hexo的deploy问题</h2><p>之前在修改完主题之后，deploy就有过问题。</p>
<p><strong>解决：</strong></p>
<p>查资料后说是ssh key的问题。然后按照github上的关于ssh keys的<a href="https://help.github.com/categories/ssh/" target="_blank" rel="external">help</a>重新产生了一个ssh key，问题解决。<br>但这次写完上篇笔记再deploy时，又出现了问题。但是我去<strong>C:\Users\Administrator.ssh</strong>目录查看,ssh key的几个文件都在，值和github自己账户上的ssh keys的值也完全一样。应该不是ssh key的问题了。<br><del>网上有个方法是将github上的clone url改为HTTPS，同时配置hexo的_config.yml，并将.deploy_git文件夹删除。再进行deploy，然而还不行。</del><br>最后是看见有人分享是因为Git的版本太高，降级到1.9几就好了。本来我用的是2.5的，降级到1.9.5的确解决了！！！</p>
<a id="more"></a>
<p><strong>之后还是要学一下ssh的知识</strong></p>
<h2 id="2-hexo的markdown格式"><a href="#2-hexo的markdown格式" class="headerlink" title="2.hexo的markdown格式"></a>2.hexo的markdown格式</h2><p>hexo的官网上说明</p>
<blockquote>
<p>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>
</blockquote>
<p>不知道这个markdown的格式和markdown本身的格式具体是什么区别。我也是刚刚学markdown写作，开始还得照着简明语法手册来编辑。我用的编辑器是作业部落Cmd Markdown。再写第一篇笔记时，在Cmd Markdown上的预览上比如标题、引用、公式都能显示出正常的状态。但是hexo后好多都不显示该有的格式。</p>
<p><strong>解决：</strong></p>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>hexo上的Markdown的符号之后要有空格，比如###2.XXX 就不能正常显示，而要写成### 2.XXX才可以。（但这里并没有变成标题，是因为要写在开头才行吧）<br>而这也是hexo很多配置的文件中的格式，<strong>属性后的值要先跟一个空格</strong>。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>我改了主题，而引用的效果是要自己写的，应用其实就是HTML上加了一对<em>blockquote</em>标签（具体是在article.styl中的.article-entry下的blockquote修改）。我用了<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external">Apollo</a>的引用的样式。（好吧，标题的hover也是，感觉和我的背景的树和hamburger比较搭……）</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>文章中有一个无序列表，我发现不管我在 - 后空不空格，都不能显示标点。才想起来是在写主题时，在css Reset时候写了</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ol</span>,<span class="selector-tag">li</span> &#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; <span class="attribute">list-style</span>:none;&#125;</div></pre></td></tr></table></figure>
<p>这样当然不能显示标点了。。删掉后发现在文章的标签处也有了圆点标记了。标签也是列表结构的，还是在在article.styl中.article-tag-list属性下添加  list-style: none；然后还有hamburger上的导航也是列表也有圆点标记，再找到代码添加。<strong>这样是不是还不如整体上ol,li的list-none，具体要的标记的地方再写样式。问题是list-style最基本的有什么值都不知道。。</strong></p>
<blockquote>
<p>list-style定义和用法<br>list-style 简写属性在一个声明中设置所有的列表属性。<br>该属性是一个简写属性，涵盖了所有其他列表样式属性。由于它应用到所有 display 为 list-item 的元素，所以在普通的 HTML 和 XHTML 中只能用于 li 元素，不过实际上它可以应用到任何元素，并由 list-item 元素继承。<br>可以按顺序设置如下属性：<br>list-style-type<br>list-style-position<br>list-style-image<br>可以不设置其中的某个值，比如 “list-style:circle inside;” 也是允许的。未设置的属性会使用其默认值。<br>默认值：    disc outside none</p>
</blockquote>
<p>比如有圆形的标记，方块的标记；outside和inside的区别感觉就是把列表项往后移动了；还有一些自定义的标记。</p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>文章中有些公式。还是用Cmd Markdown编辑，按照它的说明写，预览是正确的。但在hexo后，显示不出来。</p>
<p>经查阅，Cmd Markdown是用的<a href="https://zh.wikipedia.org/wiki/LaTeX" target="_blank" rel="external">LaTeX</a> 公式，LaTeX是一种格式，</p>
<blockquote>
<p>利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。</p>
</blockquote>
<p>尤其是对生成数学公式比较厉害。（自己理解是，这是定一些规矩，按照这种规矩书写就可以被相应的工具解析成你想要的东西。）</p>
<p>而</p>
<blockquote>
<p>Hexo並沒有內建Tex解析功能</p>
</blockquote>
<p>所以要在hexo中加入解析Tex的功能，网上大家大部分用的是<a href="https://www.mathjax.org/" target="_blank" rel="external">MathJax</a>，按照<a href="http://lukang.me/2014/mathjax-for-hexo.html" target="_blank" rel="external">这篇文章</a>成功解决。</p>
<p>但其中有比如说 $3000H\times16=30000H$，我开始是写成了$3000H*16=30000H$了，后者在Cmd Markdown的预览下看着还是公式，然而在hexo下不是。<strong>因为</strong>在LaTeX中乘号不是用 * 表示的，而是用\times 表示。在网上找到了一篇<a href="http://mohu.org/info/symbols/symbols.htm" target="_blank" rel="external">常用数学符号的 LaTeX 表示方法</a>。（星号*表示斜体的开始，还要用\来转译的。）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-hexo的deploy问题&quot;&gt;&lt;a href=&quot;#1-hexo的deploy问题&quot; class=&quot;headerlink&quot; title=&quot;1.hexo的deploy问题&quot;&gt;&lt;/a&gt;1.hexo的deploy问题&lt;/h2&gt;&lt;p&gt;之前在修改完主题之后，deploy就有过问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查资料后说是ssh key的问题。然后按照github上的关于ssh keys的&lt;a href=&quot;https://help.github.com/categories/ssh/&quot;&gt;help&lt;/a&gt;重新产生了一个ssh key，问题解决。&lt;br&gt;但这次写完上篇笔记再deploy时，又出现了问题。但是我去&lt;strong&gt;C:\Users\Administrator.ssh&lt;/strong&gt;目录查看,ssh key的几个文件都在，值和github自己账户上的ssh keys的值也完全一样。应该不是ssh key的问题了。&lt;br&gt;&lt;del&gt;网上有个方法是将github上的clone url改为HTTPS，同时配置hexo的_config.yml，并将.deploy_git文件夹删除。再进行deploy，然而还不行。&lt;/del&gt;&lt;br&gt;最后是看见有人分享是因为Git的版本太高，降级到1.9几就好了。本来我用的是2.5的，降级到1.9.5的确解决了！！！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机系统结构</title>
    <link href="http://yoursite.com/2016/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2016/03/12/计算机系统结构/</id>
    <published>2016-03-12T04:30:08.000Z</published>
    <updated>2016-10-29T09:58:33.501Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>计算机系统结构研究的是<strong>软、硬件之间的功能分配</strong>以及<strong>对传统机器级界面</strong>的确定，为机器语言、汇编语言程序设计者或编译程序设计者生成提供使其设计或生成的程序能在机器上正确运行而应看到和遵循的<strong>计算机属性</strong>。</p>
</blockquote>
<p>记录一些自己想过的知识点<br><a id="more"></a></p>
<h1 id="计算机属性"><a href="#计算机属性" class="headerlink" title="计算机属性"></a>计算机属性</h1><h3 id="1-数据类型和格式"><a href="#1-数据类型和格式" class="headerlink" title="1.数据类型和格式"></a>1.数据类型和格式</h3><p>格式 例如：<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="external">754标准浮点数</a></p>
<h3 id="2-最小可寻址单位"><a href="#2-最小可寻址单位" class="headerlink" title="2.最小可寻址单位"></a>2.最小可寻址单位</h3><p>若是<strong>字节Byte</strong> 假如有两个字节，需要1根地址线，0和1即可找到；<br>若是<strong>位bit</strong> 假如还是两个字节，但是每个字节有8位，一共是16位，则需要$ log_2^{16}=4 $根地址线。</p>
<blockquote>
<p>问题: （假设最小寻址单位是字节）现有<strong>16根地址线</strong>，那么寻址空间就是$ 2^{16}B=64KB $，从0000 <em>H</em>~FFFF <em>H</em>（<em>是<strong>四位</strong>的16进制</em>）。现还有一块<strong>1MB的内存</strong>,怎样设计才能使内存不浪费？即用16根地址线能找到1MB的地址空间从00000 <em>H</em>~FFFFF <em>H</em>（<em>是<strong>五位</strong>的16进制</em>）。</p>
</blockquote>
<p>$$ 1MB=1024KB=2^{10}KB=2^{10}\times1024B=2^{10}\times2^{10}B=2^{20}B $$</p>
<p>本来是需要20根地址线的。</p>
<p>解决：采用段号+段内偏移地址的方法。<br>$ 2^{20}/2^{16}=2^4 $,将1MB的内存分成$ 2^4=16 $块（16个64KB就是1MB），即是0块，1块，2块……F块（刚好是16进制）。<strong>每一块内</strong>，是64KB，用16位地址表示，所以每块的段内地址是从0000 <em>H</em>~FFFF <em>H</em>（<em> <strong>四位</strong>十六进制 </em>）。<strong>再加上</strong>前面的0段、1段、2段……F段，即第一段的地址是0 0000 <em>H</em>~0 FFFF <em>H</em>，第二段是1 0000 <em>H</em>~1FFFF <em>H</em>，第三段是2 0000 <em>H</em>~2 FFFF <em>H</em>，最后一段是F 0000 <em>H</em>~ F FFFF <em>H</em>，（<em> <strong>五位</strong>的16进制</em>）但这样，<strong>每块的首地址</strong>都是以0结尾，所以恰巧<strong>段号</strong>就可以<strong>把最后一位省略</strong>。实际寻址时，采用段号+段内偏移地址的方法来寻址。</p>
<p>$ 实际地址=DS\times16+段内地址 $</p>
<p>DS中存的是<strong>段号</strong>，比如第一段是0000 <em>H</em>，第二段是1000 <em>H</em>，第三段是2000<em>H</em>，最后一段是F000 <em>H</em>；乘以16表示16进制的数<strong>左移一位再补零</strong>。</p>
<p>比如：有一个地址，段号是3，段内地址是152E <em>H</em>，它的实际内存址就是$ 3000H\times16=30000H $,再加上152E <em>H</em>，为3152E <em>H</em>。（<em>一个<strong>五位</strong>的十六进制</em>）</p>
<h3 id="3-寻址种类"><a href="#3-寻址种类" class="headerlink" title="3.寻址种类"></a>3.寻址种类</h3><ul>
<li>ADD AX, 3  寄存器寻址+立即寻址</li>
<li>ADD AX, [BX]  BX中存放数据的地址</li>
<li>ADD AX, BX+x  基址、变址寻址</li>
<li>等等</li>
</ul>
<h3 id="4-内存的容量和最大可编址空间不同"><a href="#4-内存的容量和最大可编址空间不同" class="headerlink" title="4.内存的容量和最大可编址空间不同"></a>4.内存的容量和最大可编址空间不同</h3><p>例如： 现有32位的CPU（32根地址线更为准确？），最大可编址空间就是$ 2^{32}=2^2\times2^{10}\times2^{10}\times2^{10}=4GB $ （最小可寻址单位为字节B。B、K、M、G)。<br>但现在我只有一块2GB的内存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;计算机系统结构研究的是&lt;strong&gt;软、硬件之间的功能分配&lt;/strong&gt;以及&lt;strong&gt;对传统机器级界面&lt;/strong&gt;的确定，为机器语言、汇编语言程序设计者或编译程序设计者生成提供使其设计或生成的程序能在机器上正确运行而应看到和遵循的&lt;strong&gt;计算机属性&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录一些自己想过的知识点&lt;br&gt;
    
    </summary>
    
    
      <category term="系统结构" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>換系統測試</title>
    <link href="http://yoursite.com/2016/02/23/%E6%8F%9B%E7%B3%BB%E7%B5%B1%E6%B8%AC%E8%A9%A6/"/>
    <id>http://yoursite.com/2016/02/23/換系統測試/</id>
    <published>2016-02-23T05:54:29.000Z</published>
    <updated>2016-10-29T09:58:33.495Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>怎么了</title>
    <link href="http://yoursite.com/2016/01/08/%E6%80%8E%E4%B9%88%E4%BA%86/"/>
    <id>http://yoursite.com/2016/01/08/怎么了/</id>
    <published>2016-01-08T11:21:53.000Z</published>
    <updated>2016-10-29T09:58:33.491Z</updated>
    
    <content type="html"><![CDATA[<p>真的是搞不懂 实在是搞不懂 完全搞不懂<br><a id="more"></a><br>哈哈哈</p>
<p>#哈哈哈</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的是搞不懂 实在是搞不懂 完全搞不懂&lt;br&gt;
    
    </summary>
    
      <category term="吐槽" scheme="http://yoursite.com/categories/%E5%90%90%E6%A7%BD/"/>
    
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
